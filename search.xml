<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Why do I dislike big data, AI etc</title>
    <url>/post/Why%20do%20I%20dislike%20big%20data,%20AI%20etc/</url>
    <content><![CDATA[<p>当时大二的时候，人工智能还不像现在这么火，big data也是个新玩意。作为一个尝鲜者我很早就开始对这些东西进行学习研究了。</p>
<p>但是我，出于自身的角度，不喜欢它们。并不是说他们的技术水平我达不到，让我对这些“企业级技术”感到不爽的他们在技术之外的门槛。</p>
<span id="more"></span>

<p>如果你做过AI，你肯定知道要训练一个合格的模型，需要大量的例子去验证准确度，需要将更大量的例子转化成矢量去喂给算法。这些例子还都得是经过清洗的具有代表性的。换句话说，这不是个小工程。</p>
<p>很多的企业级技术和这类似。这些所谓的成功技术路线其实就是把人往大公司的坑里带：我想要训练出好的产品，我就没办法脱离大公司的帮助，只有在大公司的数据支持下我才能向前进。</p>
<p>这结果是什么呢？当资本开始作恶我们无能为力，甚至被迫出卖自己劳动力。996至今愈演愈烈越喊越轻；字节招人却都大喊真香。</p>
<p>那么，什么样的是好技术？</p>
<p>首先我认为是数字货币和区块链。众所周知的财富革命。这里不展开多说。</p>
<p>其次我认为是vr ar还有mr。设备，体验，交互和认知上的革命。</p>
<p>还有物联网，这才是真正的赋予智能。<br>还有3d打印解放个人生产力。</p>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>big data</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>具有同态值的比特币 bitcoins with homomorphic value</title>
    <url>/post/bitcoins-with-homomorphic-value/</url>
    <content><![CDATA[<p><a href="https://bitcointalk.org/index.php?topic=305791.0" target="_blank" rel="noopener">原文链接</a></p>
<p>我已经不停地研究了几个月，因为它本身似乎是一个有趣的结构，是支付隐私的另一个不同的方面（例如，从用户的角度来看，或者如果我们希望商业实体能够从可审计但对商业敏感的信息中获取信息， 使用智能合约），而且除了可以直接使用以外，它还可以实现一些我们尚未想到的功能，或者可以提高ZeroCoin之类想法的效率（我不知道如何使用，但似乎与之相关 ）。</p>
<span id="more"></span>

<p>出发点是，据我们所知可以进行加法同态加密（additively homomorphic encryption），并且还存在基于小于的零知识证明（即下文ZK小于证明）。 （证明$E(a)+ E(b)= E(a+b)$还不够，您还必须证明攻击者在此过程中没有将n加到他的余额上，因为加法是除n的模）。计算小于2的幂的效率更高，但是通过组合可以得到任意值（毕竟，所有值都可以从2的幂范围构建而成）。</p>
<p>这两个（同态加和ZK小于证明）均基于已建立的保守加密假设，但是小于的通用ZKP很大（数字签名大小的证明数量与log(v)成比例，其中$v=\log_2(n \div vmax)+1=\log_2(n)-\log_2(vmax)+1$，因此在比特币中$\log_2(n)=256$，vmax取决于编码，但有2100万BTC小于$2^{51}$聪。 而且可能还很慢，因为它涉及验证v签名。</p>
<p>本来我以为这会变得缓慢而笨拙（有点像零币），所以我一直在讨论是否以及直到找到可行的有效方法为止。 贝里·斯科恩马克斯（Berry Schoenmakers）的效率也比ZKP差（他从来没有费心写过论文，natch）。 但是，在我看来，这是基于为Schnorr组选择非标准p＆q的更非标准的假设，并且也不适用于椭圆曲线，因此对ECDSA无效（仅对Schnorr（DSA是其变体））。</p>
<p>但是最后我认为我看到了比特币使用和验证硬币值的缺失步骤，您只需要证明每个硬币的两个最高有效位为0，并使用设置$vmax&lt;2^{254}$的编码即可（即提高比特币精度） 从51位到254位，私密密钥超出&lt;$2^{51}$聪之外的次要有效位，即提供203位安全性的编码，高于提供128位安全性的P256的ECDSA的安全性。</p>
<p>因此，最终有了一种不费吹灰之力的方式来处理EC-Schnorr签名，每个输入和输出的成本仅为2 ECS信号（成本和大小与ECDSA相同），其中#input &lt; 4和#output &lt; 4 。 对于#input &gt; 3，您还需要显示例如$ZKPoK \{ (a+b+c, d): a+b+c &lt; 2^{254}, d &lt; 2^{254} \}$，如果#output&gt; 3，则显示相同。 因此，2个$k + 2\log_3(k)$签名用于k个输入或输出。 （3因为$2^{254} \times 3 &lt; n$但$2^{254} \times 4 &gt; n$。）</p>
<p>顺便说一句，在ECDSA IMO上使用ECS是有充分的理由的，IMO仍然较为保守和简单，而且DSA都基于此。因为它更简单（没有* k ^ -1步骤），所以它更灵活并且轻松地支持多方签名（n of n）甚至阈值签名（k of n），从而允许在一个ECS签名的空间内进行多重签名（甚至不公开其存在）在n的k中，也没有k或n的偶数），有一些论点认为ECS在关于哈希属性的假设中比ECDSA更安全。要使用ECDSA进行多方访问是一个研究主题，即使多方DSA也非常复杂，并且取决于同构加密实例的安全性，该同等加密实例的大小足以容纳涉及q的幂的临时结果，例如具有大密钥的paillier密码系统和偶数阈值DSA。更复杂的Damgard-Jurik扩展了Paillier方案。 ECS的灵活性使其在许多方面都具有更大的灵活性，例如，基于表示问题（这是对Pederson承诺的一种概括，其本身是schnorr的一种概括）的零知识选择性披露和品牌证书的盲目认证功能。使用Brands证书进行智能合约可以做很多事情，通过使用布尔公式的ZK证明等来保留依赖智能合约的人的属性的隐私。</p>
<p>同样，为每个值额外签名的成本，您甚至可以拥有无条件的值保密性。 （即，一个假设的功能强大的实体能够以最小的努力执行离散日志，仍然无法告诉您您支付了多少钱）。 这是因为像OTP一样，所有可能的值都是同等可能的，例如，在pederson承诺，两个基点G, H然后$xG+yH$存在x和y的所有可能值的n个可能解（其中x是密钥，y是一个可以证明事情的价值）。 强大的对手只能解决并找到所有可能性，但您公开记录的ZKP并不会显示您知道哪个x值，也不会显示您转移的y。</p>
<p>目前将发布更多的加密级别细节，也许还会发布基于openSSL的实现。</p>
<p>亚当</p>
<hr>
<p>因此，如果您假设x知识的ZK证明存在（语法$x_i$是x的第i位，即LSB从0开始），那么$ZKPoK\{(x): x_i = 0\}$可以检查两个通过使用$ZKPoK{(x): x_{255} = 0 \And x_{254} = 0}$，有效位为0。</p>
<p>该证明适用于某些组中的值，我们使用schnorr组的EC实例（例如DSA，相同的键，参数，但签名更简单； DSA是Schnorr签名变体，与原始AFAIK相比没有任何优点，而我提到了许多缺点）在OP中）。因此，我们将调用值x，其中前两位必须为0 $x_{255} = x_{254} = 0$，并且$x_{253 … x202}$是以“聪”为单位的值（与现有精度相同）以及剩下的值$x_{201..x0}$是私钥。</p>
<p>xG将是公共的，并且也是币的公钥（与现有的比特币地址的公钥略有不同）。现在人们可以验证加密的输入值(A，B)等于加密的输出值(X，C)和费用f，其中X是加密支出，C是加密更改，而f是费用，因为$A = aG$和$A + B = X + C + fG$，因为$aG + bG = xG + cG + fG$。这将强制$a + b \mod n = x + c + f \mod n$。发送者必须包括$ZKPoK\{(a，b): a_{255} = a_{254} = 0\}$。发送者还必须加密x并将其发送给接收者，以便他依次花钱时可以证明有关它的信息。 f是公开的，因为任何人都必须能够通过采矿活动将其收集并附加到其地址上。</p>
<p>当接收者花费xG时，他将不得不类似地证明$x_{255} = x_{254} = 0$。</p>
<p>我们需要两位的原因是因为n不是2的幂。为简单起见，我们说$n = 250$。现在假设$a = 3$，$b = 1$，但是我们必须加n来防止欺诈，因为$a + b + n = 254$，$(a + b + n) \mod n = 4$，且$x = 127，c = 126，f = 1$，因此仅检查最高位1可以通过n由于$a + b + n = (x + c + f) \mod n$即$3 + 1 = (127 + 126 + 1) \mod 250$就能伪造价值。攻击者在没有使用$msb \neq 0$的任何值的情况下将其值增加了250（减去1手续费）。如果我们证明前两位为0，则最多可以防止3次输入攻击。 （因为$3 * 64 &lt;250$；但4次输入不行，因为$4 * 64&gt; 250$）。因此，对于3个以上的输入，我们还证明了3元表达式树中的每个中间计算也具有两个msbits = 0。例如Z(x)是$ZKPoK\{(x): x_{255} = 0和x_{254} = 0\}$的简写，Z(a)，Z(b)，Z(c)，Z(a + b + c)，Z(d)，Z(e)，Z(f)，Z(d + e + f)，Z(g)，Z(h)，Z(i)，Z(g + h + i)，Z((a + b + c)+(d + e + f)+(g + h + i))，因此正如我提到的，对于k个输入，必须有$k + log_3(k)$对证明（对，因为有一个对$x_{255} = 0$，$x_{254} = 1$）。</p>
<p>最后请注意，证明知识是一种签名，因此原则上您可以在得到他人认可的情况下向他人支付现有余额，而不是将值的控制权转移到新地址。也就是说，说您的收款人已经有余额y，并且您想为他们添加x，然后向他们透露x（通过为他们的公钥加密），然后他们就可以添加，因此您可以用以下方式替换硬币地址：现有余额以节省签名和密钥。</p>
<p>例如$ZKPoK[Y]\{(a，b，x，y，c), f：a + b = x + c + f \And Z(a) \And Z(b) \And Z(y）\}, E(x) $</p>
<p>其中[Y]表示与PoK结合的某些信息的辅助签名。因此，发件人绑定了他的X支出，表示可以将其添加到现有余额Y中（发件人不知道y）。</p>
<p>现在，区块验证将允许接收者将其余额替换为$Y’= Y + X =(x + y)G$。当发送方为接收方加密值x时，他现在可以进行转账。</p>
<p>通过将污点作为环转移的一种方式花在一些其他用户身上，也可以实现污染混合（尽管在规模上并不便宜）。 （环签名是一种方案，您可以在未经其许可的情况下将其他签名者隐含为签名的可能的发起者，其中发起者希望在可能的作者中隐藏其身份）。因此，这有点像coinjoin，但是您不需要其他用户的积极协作。如果E（值）是脱链的（例如，直接发送给接收者），则接收者可能会甚至可能无法使用额外的值，如果他不知道尘埃值（他只能通过参考先前的余额来拒绝它），但这并不能证明他仍然可以保留它-很难证明它是否定的。）我们可以选择将其附加到链上（以一定的大小代价），甚至可以加密，并带有证明收件人可以解密的证据。 （很容易证明$xG = xH$，其中$H = yG$，证明者不知道y，因此EC Egamal可以提供可证明的可解密值，在这种情况下，该软件可以合并硬币并阻止所有者使用较早版本）。</p>
<p>（尘埃是一个现在被认为很小的值，但是由于$x_{202..0}$由发送方随机分配，并且没有DL能力就无法计算，因此必须将其传达给接收方，以使其具有价值。）</p>
<p>通过开采，原始硬币的已知价值为25个比特币（且无尘），但是接收者仍然可以安全地使用它，而无需人们通过保留尘埃作为零钱来消除其当前余额（他可能永远不会花掉，因为它实际上是可忽略的小数的nano satoshi值）。</p>
<hr>
<p><em>验证节点如何将输入和输出值相加以确定费用？ 这是我唯一不清楚的部分。 网络不需要知道$输出总和-输入总和$吗？</em></p>
<p>与当前不同，您将必须明确传达费用，并让其作为输入与输出的总和进行验证。 （在我的第二篇文章中显示了f的通信，而输入a，b和输出x（支出）和c（更改）是加密形式的，但是可以证明A + B = X + C + fG。</p>
<p>亚当</p>
<hr>
<p><em>您打算如何证明高两位为零？ 我认为没有人知道如何对小于，位提取或mod x之类的内容进行有效的ZK证明。 有通用的ZK方案，例如Pinocchio和TinyRAM，但它们很昂贵。 你有什么考虑？</em></p>
<p>是的，给我一个机会我会实现这个。</p>
<p>小于1的现有ZKP使用0或1的证明作为构建基块（这就是为什么它们效率低下，它们根据范围执行了数十次）。 即，为了证明$x \leq 5 = 101b$的模数，对于n = 257（一个9位素数）的说明，他们证明$x = 000000101b$，首先证明$x &lt;100b$，方法是证明前6位为0，然后通过证明$xG-4G$的前8位为0来证明$xG-4G = 01b \leq 1$。</p>
<p>亚当</p>
<p>我认为，Brands PhD论文/MIT新闻书“重新思考公共密钥基础结构”的第3章提供了说明/脚注/参考，可以免费下载。 它的一个组成部分是ZK范围证明或ZK小于证明。</p>
<p><a href="http://www.credentica.com/the_mit_pressbook.html" target="_blank" rel="noopener">http://www.credentica.com/the_mit_pressbook.html</a></p>
<p>有空的话，我将其写出来。 （暂离一段时间）。</p>
<p>亚当</p>
]]></content>
      <tags>
        <tag>bitcointalk</tag>
        <tag>bitcoin</tag>
        <tag>crypto</tag>
        <tag>autonomy</tag>
        <tag>done</tag>
      </tags>
  </entry>
  <entry>
    <title>Wasm Runtime的创作: Build Wasm Runtime</title>
    <url>/post/build-wasm-runtime/</url>
    <content><![CDATA[<p>因为NGIN的contract系统也就是智能合约上需要嵌入的wasm engine支持fee cost on opcode(instr)，因此需要从wasmtime迁移到其他引擎。</p>
<p>虽然说找到了<a href="https://github.com/perlin-network/life" target="_blank" rel="noopener">life</a>完全符合我们的需要，但毕竟是人家的项目而且在host func嵌入的方面不如wasmtime顺手。</p>
<p>既然是从头做起(from scratch)的项目，那么再多做个wasm runtime应该也不过分。</p>
<span id="more"></span>

<h2 id="Compilation-Execution-modes"><a href="#Compilation-Execution-modes" class="headerlink" title="Compilation/Execution modes"></a>Compilation/Execution modes</h2><p>从<a href="https://github.com/appcypher/awesome-wasm-runtimes" target="_blank" rel="noopener">awesome-wasm-runtimes</a>的项目介绍里可以看到life的编译/执行模式是Interpreted，而wasmtime是JIT。</p>
<p>其实还有个叫AOT的，像Lucet这个引擎就是用的AOT。</p>
<p>Interpreted顾名思义就是被“解释”，就类似脚本语言那样一句一句地输入并执行。换句话说就是引擎会读取源码或IR（介于高级语言和二进制机器码之间的中间表达，比如bytecode，wasm binary可以认为是IR）并立即把这些语句执行掉。</p>
<p>JIT一边读取源代码或IR，一边对已读取内容飞速编译再执行，即在执行时编译。可以认为是JIT是对内容与当前执行环境做了优化之后再进行执行。</p>
<p>AOT则接近gcc这种编译器。AOT在程序执行之前进行完整编译。</p>
<p>所以很明显JIT引擎在优化后很容易比Interpreted快很多，wagon和wasmtime，wasmer的<a href="https://github.com/wasmerio/wasmer-go#benchmarks" target="_blank" rel="noopener">速度根本没法比</a>(虽然也有语言速度上差距)。但是从wasmtime的issue记录来看负优化也不是没有。</p>
<p>因此从当前目标来看其实我们只需要先完成一个解释器，然后再通过编写compiler去对内容再做优化（JIT）。</p>
<h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p>这里我们选择的是<a href="https://www.w3.org/TR/wasm-core-1/" target="_blank" rel="noopener">w3c的wasm标准</a>，也就是version1。</p>
<p>其中的Values，Modules等内容在别的wasm内容中也提过了所以不多说。</p>
<p>最为关键的在于如何将一个Module给实例化为Instance且通过Call一个mainFunc的方式跑起来。</p>
<h2 id="Compile-Interpret"><a href="#Compile-Interpret" class="headerlink" title="Compile/Interpret"></a>Compile/Interpret</h2><p>本质上就是需要将wasm解释为机械码然后跑起来。</p>
<p>在将module实力化之前，我们需要对module中内容进行解析，构建出一个索引空间，用来快速访问我们需要的内容（其实也就function，global，table，memory）。这个内容也可能是外部module提供的，因此也需要提供externModules。</p>
]]></content>
      <tags>
        <tag>wasm</tag>
        <tag>wasi</tag>
        <tag>WebAssembly</tag>
        <tag>runtime</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>企业视角下的区块链: Chain on Enterprise View</title>
    <url>/post/chain-on-enterprise-view/</url>
    <content><![CDATA[<h2 id="区块链归类"><a href="#区块链归类" class="headerlink" title="区块链归类"></a>区块链归类</h2><p>出于方便理解和技术分类，我们倾向于在面向企业的介绍中将区块链描述为一种一种高度专业化的数据库。当然从最底层来看也确实是如此。</p>
<p>我们可以简单分类一下</p>
<pre class="mermaid">graph LR
    数据库 --> 中心化数据库
    数据库 --> 分布式数据库
    分布式数据库 --> 分布式账簿
    分布式账簿 --> 区块链</pre>
<p>对于集中式数据库，您必须信任单个数据库——并不需要达成共识。</p>
<p>对于分布式数据库，信任概念开始成为关注的重点。在分布式数据库中，您可以拥有一个受信任的容错数据库网络。</p>
<p>在分布式数据库中，存在分布式账簿，通常意味着宽松的信任保证。它们可以使彼此之间不完全信任的各方达成共识。</p>
<p>最后，我们的主人公，区块链，是分布式账簿的子类。</p>
<span id="more"></span>

<h3 id="中心化数据库"><a href="#中心化数据库" class="headerlink" title="中心化数据库"></a>中心化数据库</h3><p>需要注意的是，尽管“分布式”的定义，即分布式和中心化之间的差异，在数据库分类特别是在区块链领域下可能存在争议。在此，我们通常是指其策略和空间分布。</p>
<p>例如，我们可能将组织的数据库系统称为集中式数据库系统，因为它们都由一个实体运营——因此在策略上是集中的。就空间分布而言，我们可以有一个“中央”数据库或在地理上集中或分散的多个数据库。</p>
<p>为了更好地理解这一点，让我们回到大多数人都熟悉的数据库形式，即中心化数据库。<br>中心化数据库的地理位置，存储和维护集中式数据库（例如单个密码服务器）集中在一处，一个中央实体处理所有请求和数据处理。<br>这样的优点包括：设计简单，即时数据更新，成本效益，和最小的冗余。</p>
<p>但是，集中式数据库也有许多固有的缺点：它们容易触及瓶颈，缺少多个用户对同一组数据的同时写访问权限，并作为单点故障。</p>
<h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>分布式数据库由相互信任的节点组组成，并合作维护整个系统的一致视图。因为不再存在单点故障，所以系统更具容错能力，并且可以通过在所有节点之间平均分配负载来处理更多需求。</p>
<p>但是，分布式数据库还会带来更高的复杂性、冗余性，更多成本和以及暴露更多的故障点。那只是维护分布式的开销。</p>
<p>分布式数据库的一种特定类型是分布式分类帐，其中包含节点由可能互不信任的不同实体运营。</p>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>尽管存在许多针对分布式账本的共识机制，在其记录保存中实现区块链，共识协议被称为区块链。<br>回想一下我们的比特币和加密货币课程，区块链不支持分布式信息共享。<br>正如我们已经看到的，存在许多形式的分布式数据库，它们允许分布式没有区块链的信息共享。<br>相反，区块链的唯一性在于其分布式记录保存和去中心化价值交换。</p>
<p>与传统数据库相比，区块链系统独特地能够消除需求集中管理者，并允许网络中的非信任方彼此互动。</p>
<p>区块链还可以根据其架构以及信任和访问进行分类典型用户拥有的权限。</p>
<p>通常，所有区块链可以分为公共链或许可链。</p>
<p>公共区块链是最广泛和最知名的区块链类型。例如两种最受欢迎​​的加密货币，比特币和以太坊。</p>
<p>世界上每个人都可以读取公共区块链，可以提出对他们的协议，并可以参与他们的共识机制。<br>这使得公共区块链在提供去中心化和审查制度方面具有优势抵抗性。<br>与使用这些公共区块链平台相关的网络效应导致增加应用程序开发。<br>例如，在以太坊之上构建了数千个DApp，并且通常少于每个专用平台100个。<br>但是，由于公共区块链是开放的，并且每个人都可以访问，它们限制了可以直接存储在区块链上的信息类型。<br>不应将敏感和私人数据（即病历，SSN，私钥）放在纯文本中的区块链。<br>此外，公共区块链固有地在不受信任的环境中运行。<br>信任不再放在人员和组织中，而是放在整个系统背后的数学和代码中。</p>
<h3 id="许可链"><a href="#许可链" class="headerlink" title="许可链"></a>许可链</h3><p>不同于完全不受信任的公共区块链，我们拥有所谓的许可分类账或许可区块链。</p>
<p>在许可的区块链类别中，既有完全私有的区块链，其中权限集中到一个实体，也有联盟或联合区块链，其中权限由中央实体组控制。</p>
<p>在许可的区块链中，写入权限仅限于一个中央实体或实体联盟，并且读取权限可能也可能不受限制。<br>许可的区块链使组织可以自行决定更改区块链的规则，允许进行更便宜的交易，提供更大的隐私并减轻传统的基于共识的攻击的风险。</p>
<p>与传统的公共区块链不同，获得许可的区块链不具有（公开）开放和不信任的特性。<br>但是，在企业环境中，可以使用许可的区块链来解决松散链接的组件之间的协调问题。<br>尽管区块链仍处于起步阶段，但许多科技巨头已经开始表现出兴趣。</p>
<p>例如，Microsoft最近发布了Blockchain Workbench，它是Azure平台上的一组工具，供使用分布式分类帐技术的开发人员使用。<br>Workbench旨在通过建立基础结构来简化公司在基于Azure的区块链之上构建应用程序的过程，以便开发人员可以专注于应用程序的逻辑。</p>
<p>Hyperledger是一个由IBM和Linux Foundation牵头的区块链财团，它召集各行各业的公司共同努力进行开发。<br>该项目的目标是开发一个高度模块化和可配置的企业区块链平台，以供企业客户定制其自己的区块链解决方案。<br>Hyperledger当前专注于解决供应链，医疗保健和财务方面的问题。<br>沃尔玛（Walmart）和雀巢（Nestle）等公司已使用Hyperledger跟踪其供应链中的食物交付。</p>
<p>以太坊企业联盟是一个在以太坊社区内的组织，希望扩大以太坊对企业的影响。<br>它是由150多家财富500强公司和初创公司以及机构和政府组成的财团，为试图建立企业区块链的公司提供标准框架<br>使用以太坊作为其基础层。</p>
<p>尽管企业正在朝着区块链的方向发展，但是对于整个区块链技术仍然存在不同的观点和看法–当然，这完全取决于您要与之交谈的受众。</p>
<p>有些人可能是比特币最大化主义者，他们相信比特币和区块链的最初愿景，并且鄙视企业区块链，以将政治集中化与区块链的去中心化初始愿景</p>
<p>还有人说企业区块链很烂。<br>不同背景的不同人倾向于有这种共同意见。</p>
<p>比特币最大化主义者可能不喜欢最初为避开区块链而创建的公司对区块链的使用。<br>这些人可能会真正提倡使用加密货币。</p>
<p>同时，也许那些在传统行业有更多经验的人可能也会说<br>企业区块链很烂，但是由于他们理解并喜欢更传统的政治集中式云解决方案。<br>工业界也可能有那些知道分离加密货币和区块链的人。</p>
<p>有些人甚至对区块链在每个企业用例中都有用的看法过于乐观。</p>
<p>最后，还有一些受过高等教育的人，他们认识到区块链技术适用性的优缺点。</p>
<p>区块链可以很酷，但是只能以非常特殊的方式。</p>
<p>人们误以为企业区块链总是有用的。<br>一些用例具有根本性缺陷–通常与区块链和分布式分类帐技术的核心优势和优势不符。<br>这些用例并不能保证使用区块链，也许可以通过集中式或分布式数据库来解决，但不能使用区块链。<br>这也是一个误解，认为区块链比某些集中式解决方案更有效。</p>
<p>这种误解可以从许多不同的角度来解决。<br>问题是：我们如何定义效率？<br>如果我们在谈论计算效率，那么我们已经知道区块链是高度冗余的，因此计算效率不高。<br>毕竟，当您可能只写一对（如果不是一对）时，为什么还要写可能遍布世界的成千上万个节点。</p>
<p>另一方面，可以进一步分析效率，这是在考虑分散和可扩展性之间的权衡问题。<br>同样，也可能有人说区块链很便宜。<br>通常，区块链的维护和开发成本很高，因为这主要是社区的努力。</p>
<p>最后，另一个误解可能是，如果企业用例已经决定使用区块链，他们可能会认为他们应该只是构建自己的区块链，而不是使用现有基础架构。<br>建立自己的区块链并不像人们期望的那么简单。<br>过去，许多项目的确只是分叉了比特币区块链的代码库。<br>但是如今，现有的区块链开发框架已被证明是成功且安全的。</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链缩放研究</title>
    <url>/post/chain-scaling/</url>
    <content><![CDATA[<p>原文自edX上伯克利大学课程Blockchain Technology。本文是对课程内部分内容的总结与修改。</p>
<p>虽然现在的公链生态已经获得成功，但是其反受繁荣现状的掣肘。尤其是比特币和以太坊，存在严重的可扩展性问题。从其成为能够支持全球规模交易量的全球网络的目标来看，目前两者都在交易吞吐量(tps)方面表现不佳。</p>
<p>从根本上讲，扩展解决方案可以增加交易量或减少交易时间。这也是理所当然的，因为可缩放性是按区块链可实现的tps（每秒交易量）衡量的。</p>
<p>展望未来，我们可以通过两种方式对区块链扩展解决方案进行分类。首先是与传统的云架构缩放级别（水平，垂直和对角线）进行粗略的比较。其次，存在特定于区块链的缩放分类：第1层（在链上）和第2层（在链外）。</p>
<span id="more"></span>

<h2 id="纵向缩放"><a href="#纵向缩放" class="headerlink" title="纵向缩放"></a>纵向缩放</h2><p>正常情况下，tps算法如下</p>
<p>$$tps = BlockSize\times AvgTxSize\div BlockTime$$</p>
<p>因此我们可以给出如下几种优化方案</p>
<h3 id="减少区块时间"><a href="#减少区块时间" class="headerlink" title="减少区块时间"></a>减少区块时间</h3><p>我们不能简单地减少区块时间，因为那样会导致自然产生的分叉率更高，从而降低了系统安全性。因为在减少块时间的同时，网络中广播新区块的时间是依旧不变的。</p>
<p>以太坊一直通过采用GHOST（Greedy Heaviest Observed SubTree，贪婪的最高权重的被观测子树）协议来解决这个问题。使用GHOST协议，矿工并不会简单地同意最长的链条（比特币方案），而是“重量”最大的链条。这个“重量”是由一条链的长度和其叔块数计算得出的一个值。</p>
<h3 id="增加区块大小（容量）"><a href="#增加区块大小（容量）" class="headerlink" title="增加区块大小（容量）"></a>增加区块大小（容量）</h3><p>增加区块大小能够改善区块链的TPS。因为一个区块可以包含更多交易，也将降低交易费用。</p>
<p>但是，与减少块时间一样，增加大小存在一些副作用。一方面，增加块大小将意味着很难分叉，并且根据社区的不同，这可能不是令人愉快的体验（BCH）。这也将使区块链总体积以更快的速度增长，这也是减少区块时间的难题。最后，增加块大小很可能不是一次性解决方案，因为可伸缩性提升只是线性的。将来可能需要再次增加块大小，从而引发“滑坡”式的争论。</p>
<h3 id="减少交易体积"><a href="#减少交易体积" class="headerlink" title="减少交易体积"></a>减少交易体积</h3><p>隔离见证（SegWit）是对比特币的升级，可将交易签名从交易内部移至交易结束时的单独结构，称为隔离见证。对于非隔离见证节点，这将减少有效交易规模，因为它们不知道读入隔离见证。</p>
<p>非隔离见证节点将看到没有签名的交易，但会将交易标记为有效。另一方面，SegWit节点将知道读入隔离的见证人，并使用签名对其进行验证。</p>
<p>SegWit最初旨在解决比特币中的交易延展性。它还使用软分叉来实现，并导致较小的区块链大小。但是，SegWit只是线性可伸缩性的一次提升。</p>
<p>递归SNARKs也可以减小事务大小。与其将交易本身存储在区块链中，我们可以存储证明这些交易确实发生的证据，以及谁拥有多少加密货币的最终资产负债表。这通过减小事务大小来提高效率，并且还因为机器可以在几毫秒内验证证明。但是，当前，为了生成这些样式的证明，需要可信的环境设置。在实践中，生成证明非常昂贵。</p>
<h2 id="链下纵向缩放"><a href="#链下纵向缩放" class="headerlink" title="链下纵向缩放"></a>链下纵向缩放</h2><p>考虑到区块链的速度限制了它的可扩展性，我们可以考虑完全消除链上成本更高的操作，仅在需要全局真相时才发布。</p>
<h3 id="闪电网络-amp-雷电网络"><a href="#闪电网络-amp-雷电网络" class="headerlink" title="闪电网络&amp;雷电网络"></a>闪电网络&amp;雷电网络</h3><p>可以使用HTLC（哈希时间锁定合同）来实现比特币中的支付渠道，并且可以将交易从主要的比特币区块链转移到侧链。</p>
<p>如果Alice和Bob经常进行交易，那么对于Alice和Bob来说，建立一个私人支付渠道是很有意义的，他们在这里进行链下交易。 仅当他们想结清最终余额时，他们才会回发到主区块链。 这样一来，Alice和Bob仍然可以像往常一样进行交易，但是主区块链只需要存储Alice和Bob的初始余额和期末余额。</p>
<p>比特币闪电网络的根本思想是建立一个“支付渠道”网络，如图所示</p>
<pre class="mermaid">graphLR
    Alice --- Bob
    Alice --- David
    Bob --- Eva
    Bob ---  Fiona
    
    David --- Eva

    Eva --- Fiona
    Fiona --- Charlie
    Eva --- Charlie</pre>

<p>在上图中，只要存在通过支付渠道网络从Alice到Charlie的路径，Alice就可以立即向Charlie付款，而无需直接面向Charlie付款。</p>
<p>以太坊在工作中有一个类似的可扩展性解决方案，适当命名为雷电网络(Raiden)。</p>
<p>付款渠道和付款渠道网络将使我们无需进行很多交易，将付款委托给简单的簿记。由于主区块链仅在支付渠道中看到各方的开始和结束余额，因此我们可以使大部分交易保持脱链状态：将比特币从不到10的tps扩展到潜在的数十万tps。</p>
<p>但是这种方式依然存在一些问题：必须锁定资金才能启动支付渠道；集中到中心辐射型(hub-and-spoke)拓扑的支付渠道网络的集中化问题。</p>
<h2 id="横向缩放"><a href="#横向缩放" class="headerlink" title="横向缩放"></a>横向缩放</h2><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>分片是一种数据库扩展策略，可将一个完整的数据库分为多个“分片”，每个分片数据库都包含来自原始数据库的子集的数据，该原始数据库的子集是原始数据库。相同的想法可以应用于区块链，并且目前是以太坊研究的活跃领域之一。</p>
<p>将分片应用至区块链意味着并非每个节点都跟踪每个区块。这是第一层横向缩放解决方案。我们可以有多个并行运行的区块链，每个区块包含所有交易的子集。当前正在研究的问题包括分片式区块链系统中各个节点的分类（例如，看到单个分片的节点与看到所有分片的节点），跨分片通信以及针对单分片接管的防御措施。</p>
<h3 id="侧链"><a href="#侧链" class="headerlink" title="侧链"></a>侧链</h3><p>侧链的想法是，可以出于不同目的创建多个侧链，以插入主链，从而有效减少主链上的流量。</p>
<p>其本质是将hash分散在多个链上，因此存在安全隐患。</p>
<h2 id="高级缩放及其通用化"><a href="#高级缩放及其通用化" class="headerlink" title="高级缩放及其通用化"></a>高级缩放及其通用化</h2><h3 id="Plasma"><a href="#Plasma" class="headerlink" title="Plasma"></a>Plasma</h3><p>以太坊的Plasma可视为一种对角线缩放解决方案，因为它可以通过实施侧链实现横向缩放，并通过Tendermint和替代共识机制提高速度来实现纵向缩放。链下交易的安全性源自根链，根链是系统内真实性的主要来源。</p>
<p>FourState是一个由伯克利成员组成的区块链组成的团队，它使用Cosmos SDK编写了Plasma的实现，从而实现了更大的灵活性和可扩展性。</p>
<p>区块链从上到下有3个主要的抽象层：</p>
<ul>
<li>应用层：处理事务并更新系统状态</li>
<li>共识层：确保整个网络都同意交易和数据库更新</li>
<li>网络层：确保所有节点在合理的时间内获得更新</li>
</ul>
<p>Tendermint项目的目的是提供网络和共识层，以便可以在其之上构建任意应用程序。Tendermint是Cosmos网络的共识“引擎”，旨在使区块链具有互操作性和可扩展性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下表总结了我们已了解的缩放解决方案，并按2种不同的方法进行了分类。第1层和第2层指定解决方案是在链上还是链外构建。解决方案也可以横向或纵向缩放。</p>
<table>
<thead>
<tr>
<th>\</th>
<th>纵向</th>
<th>横向</th>
</tr>
</thead>
<tbody><tr>
<td>第二层</td>
<td>1. 支付通道<br>2. 闪电网络<br>3. 雷电网络<br>4. Plasma</td>
<td>1. 侧链<br>2. Plasma<br>3. Cosmos</td>
</tr>
<tr>
<td>第一层</td>
<td>1. 区块时间，大小<br>2. GHOST<br>3. SegWit(2x)<br>4. 递归SNARKS<br>5. 其他架构、共识</td>
<td>1. 分片</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>blockchain</tag>
        <tag>edx</tag>
        <tag>scaling</tag>
        <tag>tps</tag>
      </tags>
  </entry>
  <entry>
    <title>Crunchbeats: Spear and Shield</title>
    <url>/post/churchbeats-spear&amp;shield/</url>
    <content><![CDATA[<p>Crunchbeats项目是针对<a href="https://www.crunchbase.com/" target="_blank" rel="noopener">crunchbase</a>的公开数据采集项目</p>
<span id="more"></span>

<h2 id="Spear-0x01"><a href="#Spear-0x01" class="headerlink" title="Spear 0x01"></a>Spear 0x01</h2><p>由于crunchbase并没有提供任何company/organisation index，而且categories也是仅面向Pro(氪金)用户的search。因此，作为数据采集，我们首先需要一份可用的索引来引导具体的采集任务。</p>
<p>清单是利用了一个非常trick的方式来获取的。首先我们已经知道，org_name有意义的（即会被fuzz search注意的）也就0-9a-z这31个字符。然后在instant search的api里，结果虽然只给至多15个，但是实际总数也会暴露在response里。因此可以通过穷举来获取一份总org_name清单。</p>
<h2 id="Shield-0x01"><a href="#Shield-0x01" class="headerlink" title="Shield 0x01"></a>Shield 0x01</h2><p>当然按照其他情况来说，全站下载也是个不错的方法。但是在crunchbase里，有如下几个因素导致此方案不可行。首先就是无法判断是否已经全网下载。下载任务结束并不意味着全部下载完成，很可能只是陷入站内url闭环回路。没有一份清单而爬取数据只会徒增成本，招ban。</p>
<h2 id="Shield-0x02"><a href="#Shield-0x02" class="headerlink" title="Shield 0x02"></a>Shield 0x02</h2><p>效率低下。crunchbase包含了public界面，pro可见界面，try pro可见界面，而除了org以外还有industry，group等其他模块，因此全站下载下载到的资源可用率极低。</p>
<h2 id="Shield-0x03"><a href="#Shield-0x03" class="headerlink" title="Shield 0x03"></a>Shield 0x03</h2><p>crunchbase使用了cloudflare，在cookie里可以看到这个__cfdid</p>
<pre><code>Cookies Search Results: __cfduid
About this cookie:
Cookie associated with sites using CloudFlare, used to speed up page load times. According to CloudFlare it is used to override any security restrictions based on the IP address the visitor is coming from. It does not contain any user identification information.
</code></pre>
<p>虽然quora上说是distil提供的 <a href="https://www.quora.com/How-do-you-crawl-Crunchbase-and-bypass-the-bot-protection" target="_blank" rel="noopener">https://www.quora.com/How-do-you-crawl-Crunchbase-and-bypass-the-bot-protection</a></p>
<p>反正就是会有看脸的bot检测，具体是让你press and hold一个button，然后再看脸让你通过。</p>
<h2 id="Spear-0x02"><a href="#Spear-0x02" class="headerlink" title="Spear 0x02"></a>Spear 0x02</h2><p>我最开始想的其实是走bypass bot detection。毕竟以前绕cf找源站的文章看的有点多，<a href="https://www.anquanke.com/post/id/183238" target="_blank" rel="noopener">https://www.anquanke.com/post/id/183238</a></p>
<p>但是当时对无CDN加持下的origin IP能否直接國内访问十分怀疑，因此没有实现。</p>
<h2 id="Spear-0x03"><a href="#Spear-0x03" class="headerlink" title="Spear 0x03"></a>Spear 0x03</h2><p>后来选择的还是和对方硬碰硬。可以发现人家不管你登陆没登陆，过量的请求就会ban。至于sleep，少量sleep等于没睡，长时间sleep等于没干活。</p>
<p>因此就决定展开proxy池，咬牙花了点重金（几十块）买了proxy的服务。</p>
<h2 id="Shield-0x04"><a href="#Shield-0x04" class="headerlink" title="Shield 0x04"></a>Shield 0x04</h2><p>但是proxy在cf和gfw面前真的很脆弱。几千几万个proxy中只有数个能访问网站（经过墙），然后在网站面前被cf揍死。</p>
<h2 id="Spear-0x04"><a href="#Spear-0x04" class="headerlink" title="Spear 0x04"></a>Spear 0x04</h2><p>因为一开始是requests进行的网络请求，全都是python也就不处理任何js，遇到challenge就停下来让人手摇解禁。效率就很低。为了效率，尝试了利用selenium(webdriver)来处理请求。首先的确利用chrome+firefox的自动challenge可以降低被ban的几率，但是和requests比起来真的是太慢了……尤其是在笔记本上，换句话说就是出师未捷身先死了。</p>
<h2 id="Spear-0x05"><a href="#Spear-0x05" class="headerlink" title="Spear 0x05"></a>Spear 0x05</h2><p>后来通过手里闲置的几台tx云学生机</p>
<h2 id="WIP"><a href="#WIP" class="headerlink" title="[WIP]"></a>[WIP]</h2><h2 id="New-solution"><a href="#New-solution" class="headerlink" title="New solution"></a>New solution</h2><p>New solution to overcome the ip blacklist: Vultr/GCP/AWS =&gt; unlimited new machine/ip with low fee</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>crunchbase</tag>
        <tag>spider</tag>
        <tag>data collection</tag>
      </tags>
  </entry>
  <entry>
    <title>Design of Contracts</title>
    <url>/post/design-of-contracts/</url>
    <content><![CDATA[<p>说实话其实一开始压根没想做合约，就只是想做个chain。</p>
<p>但是后来发现你不做DAPP你的chain都没人看，那些做coin的也都在往DAPP靠。就有种被逼上梁山的感觉。不过还好现在有个去华山的路（WASM），可以考虑上了华山再往梁山飞。</p>
<p>其实我也不算是第一个选择华山飞梁山的，cosmos和eth2.0也选，不过人家有现成地图，我只能凭感觉乱飘。而且我们不是一个山头起飞的，他们选了更早被人发现的山头（wasmer），我选了个看起来粗大(?)一点的新山头（wasmtime）。</p>
<span id="more"></span>

<p>不瞎扯了，下面就开始分析对于合约的设计。</p>
<p>做ethereum开发的都知道Solidity，因此需求也是从这个上面靠拢。不过由于现在主要支持wasm的语言C和RUST都是比较成熟的所以直接就选择他们对具体功能开干。</p>
<p>+-x÷是都没有问题，问题在于和链的互动，和rpc的互动，以及事件的侦听。</p>
<h1 id="ngVM"><a href="#ngVM" class="headerlink" title="ngVM"></a>ngVM</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>上传至链上的wasm需要为<a href="https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md" target="_blank" rel="noopener">binary格式</a></p>
<h3 id="数据类型-data-type"><a href="#数据类型-data-type" class="headerlink" title="数据类型 data type"></a>数据类型 data type</h3><ul>
<li>i32: 返回code，&gt;0为正常，&lt;=异常 </li>
<li>i64: 指针</li>
<li>u64: 账户</li>
<li>bytes: 底层mem</li>
</ul>
<h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h3><p>wasm只能import在ngVMI中指定的接口。</p>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>在Debug环境里提供一系列print的接口</p>
<h3 id="Exports"><a href="#Exports" class="headerlink" title="Exports"></a>Exports</h3><p>合同必须完全具有两个export：</p>
<ul>
<li><code>memory</code>: 可供EEI写入的共享内存空间。</li>
<li><code>main</code>: 没有参数和结果值的函数。</li>
</ul>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>导出为<code>main</code>的方法将由NGIN内部VM Manager执行。</p>
<p>如果成功执行，则正常返回。</p>
<p>如果由于故障而需要中止，则返回error，避免panic。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>如果执行wasm代码触发了wasm异常，则执行将失败并终止。</p>
<h2 id="接口-ngVMI-NGIN-VM-Interface"><a href="#接口-ngVMI-NGIN-VM-Interface" class="headerlink" title="接口(ngVMI: NGIN VM Interface)"></a>接口(ngVMI: NGIN VM Interface)</h2><p>WIP</p>
<h3 id="log-debug-msg-ptr-i64-msg-len-i64"><a href="#log-debug-msg-ptr-i64-msg-len-i64" class="headerlink" title="log::debug(msg_ptr i64, msg_len i64)"></a>log::debug(msg_ptr i64, msg_len i64)</h3><h3 id="log-info-msg-ptr-i64-msg-len-i64"><a href="#log-info-msg-ptr-i64-msg-len-i64" class="headerlink" title="log::info(msg_ptr i64, msg_len i64)"></a>log::info(msg_ptr i64, msg_len i64)</h3><h3 id="log-error-msg-ptr-i64-msg-len-i64"><a href="#log-error-msg-ptr-i64-msg-len-i64" class="headerlink" title="log::error(msg_ptr i64, msg_len i64)"></a>log::error(msg_ptr i64, msg_len i64)</h3><h3 id="log-warn-msg-ptr-i64-msg-len-i64"><a href="#log-warn-msg-ptr-i64-msg-len-i64" class="headerlink" title="log::warn(msg_ptr i64, msg_len i64)"></a>log::warn(msg_ptr i64, msg_len i64)</h3><p>打印输出，默认关闭。</p>
<h3 id="self-get-num-gt-num-i64"><a href="#self-get-num-gt-num-i64" class="headerlink" title="self::get_num() -&gt; num i64"></a>self::get_num() -&gt; num i64</h3><p>获取vm自身account num(uint64)</p>
<h3 id="self-get-owner-gt-owner-ptr-i64"><a href="#self-get-owner-gt-owner-ptr-i64" class="headerlink" title="self::get_owner() -&gt; owner_ptr i64"></a>self::get_owner() -&gt; owner_ptr i64</h3><p>获取vm自身owner’s address (length = 33 bytes)</p>
<h3 id="self-get-contract-len-ptr-i64-gt-contract-ptr-i64"><a href="#self-get-contract-len-ptr-i64-gt-contract-ptr-i64" class="headerlink" title="self::get_contract(len_ptr i64) -&gt; contract_ptr i64"></a>self::get_contract(len_ptr i64) -&gt; contract_ptr i64</h3><p>获取vm自身合约代码</p>
<h3 id="context-read-src-ptr-i64-dst-ptr-i64-len-u64"><a href="#context-read-src-ptr-i64-dst-ptr-i64-len-u64" class="headerlink" title="context::read(src_ptr: i64, dst_ptr: i64, len: u64)"></a>context::read(src_ptr: i64, dst_ptr: i64, len: u64)</h3><p>可持续存储读取</p>
<h3 id="context-alloc-len-u64"><a href="#context-alloc-len-u64" class="headerlink" title="context::alloc(len: u64)"></a>context::alloc(len: u64)</h3><p>为可持续存储分配空间<br>//TODO: 收费</p>
<h3 id="context-write-src-ptr-i64-dst-ptr-i64-len-u64"><a href="#context-write-src-ptr-i64-dst-ptr-i64-len-u64" class="headerlink" title="context::write(src_ptr: i64, dst_ptr: i64, len: u64)"></a>context::write(src_ptr: i64, dst_ptr: i64, len: u64)</h3><p>可持续存储写入</p>
<h3 id="coin-transfer-to-u64-value-ptr-i64-gt-i32"><a href="#coin-transfer-to-u64-value-ptr-i64-gt-i32" class="headerlink" title="coin::transfer(to: u64, value_ptr: i64) -&gt; i32"></a>coin::transfer(to: u64, value_ptr: i64) -&gt; i32</h3><p>原来叫create_transaction，表示由wasm_vm主动创建一个事务tx让chain通过处理tx方式修改state</p>
<p>通过此函数，vm能够提供例如bank/token的基础资金转移功能。</p>
<p>但是遇到一个之前忽略掉的问题——从vm里发出的交易该怎么sign？</p>
<p>根据ETH的方法，调用都会被算为是由tx的call触发，因此这些变化都是由原tx负责。</p>
<p>换句话说，变动的只有state，并不会出现由contract主动触发的tx。</p>
<p>因此这个tx摆在这里就不合适了，因为vm里的操作都是直接作用于state</p>
<p>所以这里就不应该使用transaction or tx来称呼这个操作，而用transfer来简化这个函数。</p>
<h3 id="tx-get-convener-gt-num-u64"><a href="#tx-get-convener-gt-num-u64" class="headerlink" title="tx::get_convener() -&gt; num u64"></a>tx::get_convener() -&gt; num u64</h3><p>获取transaction的convener</p>
<h3 id="tx-get-participants-len-gt-len-u64"><a href="#tx-get-participants-len-gt-len-u64" class="headerlink" title="tx::get_participants_len() -&gt; len u64"></a>tx::get_participants_len() -&gt; len u64</h3><p>获取transaction的参与人数量</p>
<h3 id="tx-get-participant-index-u64-gt-account-ptr-i64"><a href="#tx-get-participant-index-u64-gt-account-ptr-i64" class="headerlink" title="tx::get_participant(index: u64) -&gt; account_ptr i64"></a>tx::get_participant(index: u64) -&gt; account_ptr i64</h3><p>获取transaction的参与人，需要用account namespace的api处理</p>
<h3 id="tx-get-values-len-gt-len-u64"><a href="#tx-get-values-len-gt-len-u64" class="headerlink" title="tx::get_values_len() -&gt; len u64"></a>tx::get_values_len() -&gt; len u64</h3><p>获取transaction的参与人数量</p>
<h3 id="tx-get-value-index-u64-gt-value-ptr-i64"><a href="#tx-get-value-index-u64-gt-value-ptr-i64" class="headerlink" title="tx::get_value(index: u64) -&gt; value_ptr i64"></a>tx::get_value(index: u64) -&gt; value_ptr i64</h3><p>获取transacation的对应value(uint256)</p>
<h3 id="state-get-balance-addr-i64-gt-balance-ptr-i64"><a href="#state-get-balance-addr-i64-gt-balance-ptr-i64" class="headerlink" title="state::get_balance(addr: i64) -&gt; balance_ptr i64"></a>state::get_balance(addr: i64) -&gt; balance_ptr i64</h3><p>balance 长度 8*4 = 24 </p>
<h3 id="state-get-owner-num-u64-gt-addr-ptr-i64"><a href="#state-get-owner-num-u64-gt-addr-ptr-i64" class="headerlink" title="state::get_owner(num: u64) -&gt; addr_ptr i64"></a>state::get_owner(num: u64) -&gt; addr_ptr i64</h3><p>addr 长度 33</p>
<h2 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h2><p>Assign &amp; Append tx</p>
<h2 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h2><p>WASM的发布分为两种: Web or Wasm.</p>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>任何ngcore节点能够作为http server提供http服务(单页面)，端口为52528。默认关闭，通过Flag打开</p>
<p>例如 <a href="http://app.ngin.sh:52528/#10086/path1/path2" target="_blank" rel="noopener">http://app.ngin.sh:52528/#10086/path1/path2</a></p>
<p>服务运营者可以通过nginx反代限制app为</p>
<p><a href="https://app.mydomain.com/path1/path2?param1=1&amp;params2=2" target="_blank" rel="noopener">https://app.mydomain.com/path1/path2?param1=1&amp;params2=2</a></p>
<p>发布Web应用需要将wasm binary写入Contract字段。在访问时会自动将字段作为文件拉取，并且通过导出的main函数进行执行</p>
<h3 id="Wasm"><a href="#Wasm" class="headerlink" title="Wasm"></a>Wasm</h3><p>Wasm可以作为网站后端运行，也可以纯提供链上事务或者作为其他Wasi运行库</p>
<p>Wasm要求Contract为wasm binary.</p>
<h2 id="当前遇到的问题"><a href="#当前遇到的问题" class="headerlink" title="当前遇到的问题"></a>当前遇到的问题</h2><h3 id="Infinite-loop"><a href="#Infinite-loop" class="headerlink" title="Infinite loop"></a>Infinite loop</h3><p>当前使用wasmtime，无法在运行前拦截vm中infinite loop</p>
<p>当loop执行，就会导致全网主机阻塞在处理该vm对应的tx上</p>
<p>感觉该看一下wasm的opcode</p>
<h3 id="Fee-charging"><a href="#Fee-charging" class="headerlink" title="Fee charging"></a>Fee charging</h3><p>由于wasmtime只提供封闭的ffi，因此无法将opcode与fee进行挂钩</p>
<p>这里可以理解为我们需要自己写一个ngin专用的wasm runtime</p>
<p>找材料的时候发现了perlin-network的一个wasm方案，<a href="https://github.com/perlin-network/life" target="_blank" rel="noopener">life</a>.</p>
<p>钱多好办事哈，人家自己也折腾了个chain daemon叫<a href="https://github.com/perlin-network/wavelet" target="_blank" rel="noopener">wavelet</a>，意思是小波浪</p>
<p>life里加gas是在compile时候，对每个Block做totalCost的计算（递增1，即每个instruction费用为1），然后给每个block的code前面都加上一个add_gas的instruction。</p>
<p>当然这个add_gas的ins当前还没用，也不知道他们准备加点啥。</p>
<p>compile是将wasm binary转换为host上的一个module，他们的api应该是参考的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile" target="_blank" rel="noopener">js interface</a></p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>NGIN</tag>
        <tag>contract</tag>
      </tags>
  </entry>
  <entry>
    <title>ECDSA签名及验证</title>
    <url>/post/ecdsa-sign/</url>
    <content><![CDATA[<p>ECDSA私钥是取q为模后得到的整数x。相关标准规定x不得为0。 因此，x是在[1，q-1]范围内的整数。qlen为q的二进制长度。</p>
<p>签名的生成使用了密码学哈希函数H和输入的消息m。消息首先由H处理，产生值H(m)即消息m的hash，它是长度为hlen的二进制序列。通常，选择H使其输出长度hlen大致等于qlen，因为签名方案的总体安全性取决于hlen和qlen之间的最小值；但是，相关标准支持hlen和qlen的所有组合。</p>
<span id="more"></span>

<ol>
<li>使用bits2int变换和额外的模块化约简将H(m)转换为整数模q：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h &#x3D; bits2int(H(m)) mod q</span><br></pre></td></tr></table></figure>
<p>正如在bit2octets的描述中所指出的那样，额外的模块化缩减只不过是有条件的减法。</p>
<ol start="2">
<li><p>生成称为k的取模q的随机值。 该值不为0。因此，它位于[1，q-1]范围内。在ECDSA中，应通过随机选择来选择k，该选择应以均匀的概率从q-1个可能的值中选择一个值。</p>
</li>
<li><p>根据k和关键参数计算出值r (modulo q)。计算出点kG；其X坐标（定义了E的字段的成员）被转换为整数，该整数以q为模减小，从而得出r。如果r变为零，则应选择一个新的k并再次计算r（这是完全不可能的情况）。</p>
</li>
<li><p>值s (modulo q)的计算如下：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D;（h + x * r）&#x2F; k mod q     </span><br></pre></td></tr></table></figure>

<p>(r, s)就是签名。ECDSA标准本身并未涵盖如何对签名进行编码； 常见的方法是使用DER编码的ASN.1结构（两个INTEGER的SEQUENCE，分别用于r和s），或者作为两个32bytes拼接为一个64bytes。</p>
<p>签名验证过程如下：</p>
<ol>
<li><p>验证 <em>r , s</em> 都处于 [1, n-1] 范围内的整型数，否则验证失败</p>
</li>
<li><p><em>e</em>为消息的hash值</p>
</li>
<li><p>计算<em>z</em></p>
</li>
<li><p>计算参数 <em>w</em> :</p>
<p>$w=s^{−1}\ mod\ n$</p>
</li>
<li><p>计算两个参数 <em>u1, u2</em> :</p>
<p>$u_1=zw\ mod\ n,\ u_2=rw\ mod\ n$</p>
</li>
<li><p>(x1, y1)，如果该点不是同一个曲线上的点，验证失败</p>
<p>$(x_{1}, y_{1}) = u_{1} \times G + u_{2} \times Q_{A}$</p>
</li>
<li><p>如果存在下面的恒等式，则验证通过，否则验证失败</p>
<p>$r≡x_1\ mod\ n$</p>
</li>
</ol>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>生成不变的sign</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>ECDSA</tag>
        <tag>cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT5195: Business intelligence and data warehousing</title>
    <url>/post/fit5195-bi-notes/</url>
    <content><![CDATA[<p>好家伙这个一上来我就听不懂……当初没分到信息管理现在遭罪……</p>
<span id="more"></span>

<h2 id="S1-Intro"><a href="#S1-Intro" class="headerlink" title="S1 Intro"></a>S1 Intro</h2><p>这门课是基于intro to db的，默认大家都是SQL老手了。同样的，BI和数据仓库也是在DB之上的概念。</p>
<h3 id="Operational-DB"><a href="#Operational-DB" class="headerlink" title="Operational DB"></a>Operational DB</h3><p>企业拿来操作日常行为的数据库（买卖，预约 etc， 用来支持商业行为）</p>
<ul>
<li>使用集中于事务</li>
<li>便于决策制定</li>
<li>但是决策分析能力不够</li>
</ul>
<h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>相比Operational DB加强了决策能力。</p>
<p>数据仓库是数据库的多维视图，具有聚合和预计算的摘要</p>
<h4 id="建立数据仓库"><a href="#建立数据仓库" class="headerlink" title="建立数据仓库"></a>建立数据仓库</h4><p>通过将Operational DB转换为数据仓库来创建数据仓库</p>
<p>转换包括一系列数据操作步骤</p>
<p>所有的数据转换称为Extract-Transform-Load ETL</p>
<img src="/post/fit5195-bi-notes/image-20210110235639103.png" class="" title="image-20210110235639103">



<h4 id="使用数据仓库"><a href="#使用数据仓库" class="headerlink" title="使用数据仓库"></a>使用数据仓库</h4><p>使用数据仓库的手段是从数据仓库提取数据以进行进一步的数据分析</p>
<p>从数据仓库中提取数据的查询是在线分析工具或OLAP</p>
<p>OLAP会捕获原始数据，该原始数据可以使用任何Business Intelligence（BI）工具格式化。<br>在OLAP中，对数据进行集中处理的数据最为重要。BI工具可用于进一步的表示和可视化<br>接收原始数据的BI工具可以任何形式表示数据：报告，图形，仪表板等</p>
<h4 id="数据分析的需要"><a href="#数据分析的需要" class="headerlink" title="数据分析的需要"></a>数据分析的需要</h4><h3 id="BI"><a href="#BI" class="headerlink" title="BI"></a>BI</h3><p>“商务智能”（BI）是指描述用于捕获，收集，集成，存储和分析数据的综合，内聚和集成的工具集和过程，其目的在于生成和呈现信息以支持业务决策。<br>BI是一个框架，可以使企业将数据转换为信息，信息知识和知识能力不足。</p>
<p>一般而言，BI提供以下框架：</p>
<ul>
<li>收集和存储运营数据 </li>
<li>将运营数据汇总为决策支持数据</li>
<li>分析决策支持数据以生成信息</li>
<li>向最终用户显示此类信息以支持业务决策</li>
<li>制定业务决策，从而生成更多收集，存储和不久的数据（重新启动流程）</li>
<li>监视结果以评估业务决策的结果，从而可以收集，存储和存储更多数据</li>
<li>高度准确地预测未来的行为和结果</li>
</ul>
<p>在实践中，第一点是收集和存储操作数据，这不会影响到操作系统的持久性；而恰恰相反，它会损害操作系统的功能。<br>但是，BI系统将使用操作数据作为信息的输入材料。<br>其余的过程和结果将前面的点解释为面向生成知识，并且它们是BI系统的重点</p>
<img src="/post/fit5195-bi-notes/image-20210110235535385.png" class="" title="image-20210110235535385">



<h2 id="S2-星形架构-Star-Schema"><a href="#S2-星形架构-Star-Schema" class="headerlink" title="S2 星形架构 Star Schema"></a>S2 星形架构 Star Schema</h2><h3 id="星形架构"><a href="#星形架构" class="headerlink" title="星形架构"></a>星形架构</h3><p><a href="https://docs.microsoft.com/zh-cn/power-bi/guidance/star-schema" target="_blank" rel="noopener">了解星型架构及其对 Power BI 的重要性 - Power BI | Microsoft Docs</a></p>
<p>Star Schema 是多维视图的一种设计表示形式。是数据建模技术用于将多维决策支持数据映射到关系数据库中。</p>
<p>对于Star Schema的开发主义者来说，关系建模技术是一种错误的解决方案：ER和归一化，无需多余的数据库结构即可处理复杂的数据分析。</p>
<p>Star Schema由三个部件组成：</p>
<ol>
<li>Facts事实（可度量数值，表达特定商业领域或活动）</li>
<li>Dimensions维度（其他属性，提供对Facts额外的视角）</li>
<li>Attributes属性（包含在维度表中）</li>
</ol>
<img src="/post/fit5195-bi-notes/image-20210111002948496.png" class="" title="image-20210111002948496">



<h3 id="转化（ETL）流程"><a href="#转化（ETL）流程" class="headerlink" title="转化（ETL）流程"></a>转化（ETL）流程</h3><p>从ER图转为数据仓库（星形架构）</p>
<p>首先得有个分析点</p>
<h4 id="双列表格法"><a href="#双列表格法" class="headerlink" title="双列表格法"></a>双列表格法</h4><p>创建星型模式时，您需要想象要分析的数据由两列组成。</p>
<p><strong>第一列</strong>是类别（例如A，B，C，D），<strong>第二列</strong>是统计数字（例如 B）。</p>
<p>第二列（例如F）必须在所有两列表中保持一致。</p>
<img src="/post/fit5195-bi-notes/image-20210111003647783.png" class="" title="image-20210111003647783">



<p>多个Facts下措施：</p>
<p>双列表中的第二列是数字事实度量值（例如F列），实际上可以是多列（称它们为：F1，F2， F3）</p>
<p>只要所有这些列（例如F1，F2， F3）涉及所有类别（例如A，B，C，D）。</p>
<img src="/post/fit5195-bi-notes/image-20210111003924868.png" class="" title="image-20210111003924868">

<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ol>
<li>先建立各个维度表</li>
<li>将各个维度的行写入维度表</li>
<li>建立tempfact表：select where A.id=B.id将各个事实表<strong>源</strong>的列 as到tempfact表（即完成表建立又同时数据转移）</li>
<li>增加与源数据类型不同的列到tempfact表（例如源中DATE，事实表中NUMBER）</li>
<li>为4中的新列写入数据</li>
<li>最后建立fact表：使用group by从tempfact里把需要的列取出</li>
</ol>
<h2 id="S3-桥接表-Bridge-Tables"><a href="#S3-桥接表-Bridge-Tables" class="headerlink" title="S3 桥接表 Bridge Tables"></a>S3 桥接表 Bridge Tables</h2><p>好鸡儿难日常听不懂……</p>
<h3 id="Bridge-Tables"><a href="#Bridge-Tables" class="headerlink" title="Bridge Tables"></a>Bridge Tables</h3><p>用来连接俩维度表（其中只有一个连接事实）</p>
<p>到Fact source路径上存在N:N关系（可能N:N被分为1:N和N:1）</p>
<p>you first need to identify the attributes required to calculate the fact measures, then circle the tables contain those attributes as a fact source. After that, you identify where the attributes needed to create the dimensions, and assess the relationship between those tables with the fact source table. If there is a many-to-many relationship and the dimension does not contribute directly to the calculation of the fact measure, a bridge table is needed</p>
<h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p>好像这个直接默认是已掌握内容……orz</p>
<p>开始的时候，先问问自己</p>
<ol>
<li>How many records in the operational database?</li>
<li>How many records in the data warehouse?</li>
<li>What kind of data is in the operational database?</li>
<li>How do the tables look like in the data warehouse?</li>
</ol>
<p>先做<strong>data exploration</strong>s</p>
<p><del>先对所有的operational database的table都select count(*)一遍</del></p>
<p><del>对比数据仓库和operational database</del></p>
<ol>
<li>一致性检查：根据每个变量的合理取值范围和相互关系，检查数据是否合乎要求，发现超出正常范围、逻辑上不合理或者相互矛盾的数据</li>
<li>无效值和缺失值的处理</li>
</ol>
<h2 id="S4-Multifact"><a href="#S4-Multifact" class="headerlink" title="S4 Multifact"></a>S4 Multifact</h2><p>就讲讲怎么在一个DW里放多个Fact来更好地表达measure</p>
<p><img src="fit5195-bi-notes/image-20210119153311615.png" alt="image-20210119153311615" loading="lazy"><img src="fit5195-bi-notes/image-20210119153321174.png" alt="image-20210119153321174" loading="lazy"></p>
<p>我们需要在Fact表中存放一个avg参数么？NO： Average of an Average</p>
<p>在FACT中存放平均值不是个好主意，那我们应该如何处理这些问题？</p>
<p>我们可以存放<strong>总数</strong>（total xxx）以及<strong>数量</strong>（number of xxx）</p>
<h2 id="S5-DW-Architecture"><a href="#S5-DW-Architecture" class="headerlink" title="S5 DW Architecture"></a>S5 DW Architecture</h2><p>Data Warehouse Architecture</p>
<p>根据Tut来看讲的主要是multifact</p>
<h3 id="Level-of-Aggregations"><a href="#Level-of-Aggregations" class="headerlink" title="Level of Aggregations"></a>Level of Aggregations</h3><p>聚合程度，最次是Level0就基本上是从Operational DB里拿的字段，然后1然后2这样往上越大越浓缩就是精华</p>
<p>lower down level方法：</p>
<ol>
<li>加个新DIM （）</li>
<li>Replace an existing DIM with a higher granularity DIM（Fact的measure值也被分割）</li>
</ol>
<h2 id="S6-Temporal-DW"><a href="#S6-Temporal-DW" class="headerlink" title="S6 Temporal DW"></a>S6 Temporal DW</h2><p>Temporal (or historical) aspect of records is incorporated into the data warehouse</p>
<p>记录的时间（或历史）被合并到数据仓库中，比如 书籍价格随时间的变化</p>
<p>也叫做SCD（Slowly Changing Dimensions，缓慢改变的维度）</p>
<h3 id="with-Bridge-Table"><a href="#with-Bridge-Table" class="headerlink" title="with Bridge Table"></a>with Bridge Table</h3><p>使用Bridge的话可以像加个弱实体那样加个DIM</p>
<p>像这样，其中BookID 和俩Date形成composite key</p>
<img src="/post/fit5195-bi-notes/image-20210223222154124.png" class="" title="image-20210223222154124">

<p>如果Book和BookPrice是1：1关系那就可以并到一起</p>
<p>例如<img src="fit5195-bi-notes/image-20210223223650881.png" alt="image-20210223223650881" loading="lazy">变<img src="fit5195-bi-notes/image-20210223223700052.png" alt="image-20210223223700052" loading="lazy"></p>
<h3 id="Temporal-Attributes"><a href="#Temporal-Attributes" class="headerlink" title="Temporal Attributes"></a>Temporal Attributes</h3><p>Temporal attribute是一个属性，其值具有生命周期</p>
<p>例如，每个书价都有生命期（即时间限制），即BookPriceDIM表中的StartDate和EndDate</p>
<h3 id="Temporal-Dimensions"><a href="#Temporal-Dimensions" class="headerlink" title="Temporal Dimensions"></a>Temporal Dimensions</h3><p>Temporal Dimensions是其中具有特定生命周期的维度表</p>
<p>例如图中BranchHistoryDIM（MerchandisePriceDIM算Temporal attribute）</p>
<img src="/post/fit5195-bi-notes/image-20210223223251503.png" class="" title="image-20210223223251503">

<h3 id="Slowly-Changing-Dimensions"><a href="#Slowly-Changing-Dimensions" class="headerlink" title="Slowly Changing Dimensions"></a>Slowly Changing Dimensions</h3><p>主要讲SCD的几个种类，定义前面说了。值得一提的是这个Slowly也是很重要的，对于快速改变的值，比如股票价格，车辆位置，需要的是实时(realtime) DW，或者说流式(stream)DW</p>
<h4 id="Type-0"><a href="#Type-0" class="headerlink" title="Type 0"></a>Type 0</h4><p>实际上并不在DIM上存历史数据</p>
<p>建立数据仓库时，DIM存储记录的“原始或初始”的值</p>
<p>例如：book的全价记录在BookDIM中</p>
<img src="/post/fit5195-bi-notes/image-20210223225111085.png" class="" title="image-20210223225111085">

<h4 id="Type-1"><a href="#Type-1" class="headerlink" title="Type 1"></a>Type 1</h4><p>和T0一样实际上并不在DIM上存历史数据</p>
<p>只记录最新值</p>
<p>例如：Book最新价格将记录在BookDIM中</p>
<img src="/post/fit5195-bi-notes/image-20210223225107357.png" class="" title="image-20210223225107357">

<h4 id="Type-2"><a href="#Type-2" class="headerlink" title="Type 2"></a>Type 2</h4><p>从主DIM跟踪历史</p>
<p>例如：更改Book价格后，会创建具有相同详细信息的“另一本书”，有新的BookID和新价格</p>
<img src="/post/fit5195-bi-notes/image-20210223225048177.png" class="" title="image-20210223225048177">

<h4 id="Type-3"><a href="#Type-3" class="headerlink" title="Type 3"></a>Type 3</h4><p>简化版T2</p>
<p>仅保留当前（Cur）和前一个（Prev）的值，而不保留整个历史记录</p>
<p>例如：仅记录书的最后两个价格</p>
<p>基本原理：</p>
<ul>
<li>假设不需要分析完整的历史记录</li>
<li>大多数分析将以当前价格和最多一个过去价格（例如， 与趋势比较</li>
</ul>
<img src="/post/fit5195-bi-notes/image-20210223225531130.png" class="" title="image-20210223225531130">

<h4 id="Type-4"><a href="#Type-4" class="headerlink" title="Type 4"></a>Type 4</h4><p>创建一个新DIM来维护attribute 变更的历史记录</p>
<p>如前面（with Bridge Table那里）的BookPriceDIM</p>
<img src="/post/fit5195-bi-notes/image-20210223222154124.png" class="" title="image-20210223222154124">

<p>主要优势：同一本书无需具有其他BookID。 此外，保留更改的全部历史记录。</p>
<h4 id="Type-6"><a href="#Type-6" class="headerlink" title="Type 6"></a>Type 6</h4><p>T2和T3的结合。同一本书不需要单独的ID（同T3），但是会保留整个历史记录（同T2）</p>
<p>Composite key {BookID, StartDate, EndDate}</p>
<img src="/post/fit5195-bi-notes/image-20210223230148094.png" class="" title="image-20210223230148094">

<p>如果由于Date，BookDIM和BookSalesFACT之间存在M:M关系</p>
<p>Sol1：给BookDIM加个新的surrogate key</p>
<p>Sol2：把StartDate和EndDate加到FACT-&gt;与TimeID混乱</p>
<p>Sol3：加个辅助性的表（或Bridge Table）在BookSalesFACT和BookDIM之间-&gt;也乱</p>
<p>结论：Sol1最佳</p>
<h2 id="S7-Snowflake-Schema"><a href="#S7-Snowflake-Schema" class="headerlink" title="S7 Snowflake Schema"></a>S7 Snowflake Schema</h2><p>给Star的DIM分个层级（Hierarchy）就变Snowflake了</p>
<img src="/post/fit5195-bi-notes/image-20210224001704514.png" class="" title="image-20210224001704514">

<p>注意1:M关系，不能整倒了</p>
<h3 id="Determinant-Dimensions"><a href="#Determinant-Dimensions" class="headerlink" title="Determinant Dimensions"></a>Determinant Dimensions</h3><p>显性维度</p>
<p>在Star schema下检索的所有数据都必须使用此DIM，否则检索的数据将变得毫无意义。例如PetrolType</p>
<p>差不多就是做Schema之前问题里都提到的一个要素吧</p>
<img src="/post/fit5195-bi-notes/image-20210224002158112.png" class="" title="image-20210224002158112">







<h2 id="S8-OLAP"><a href="#S8-OLAP" class="headerlink" title="S8 OLAP"></a>S8 OLAP</h2><p>熟悉的SQL</p>
<p><strong>基础</strong></p>
<p>COUNT([distinct] A)</p>
<p>SUM([distinct] A)</p>
<p>AVG([distinct] A)</p>
<p>MAX(A)</p>
<p>MIN(A)</p>
<p>GROUP BY</p>
<p><strong>进阶</strong></p>
<p>CUBE：扩展GROUP BY子句以在单个查询中生成<strong>交叉表</strong>格式的信息。</p>
<p>ROLLUP：扩展GROUP BY子句以生成从最详细到总计的越来越细粒度的聚合。</p>
<p>GROUPING：与SELECT语句一起使用，以显示有关聚合级别的信息以及每个聚合级别的相关小计。</p>
<p>Partial CUBE：GROUP BY expr1, CUBE (expr2, expr3)</p>
<p>Partial ROLLUP：GROUP BY expr1, ROLLUP (expr2, expr3)</p>
<p><strong>高阶</strong></p>
<p>RANK( ) OVER ([query_partition_clause] order_by_clause)</p>
<p>DENSE_RANK( ) OVER ([query_partition_clause] order_by_clause)</p>
<p>DENSE对于同rank重复情况下只加一</p>
<p>RANK() OVER (PARTITION BY order_by_clause)</p>
<p>例如select RANK() OVER (PARTITION BY channel_desc ORDER BY SUM(amount_sold) DESC) AS RANK_BY_CHANNEL from XXX</p>
<p>如果需要显示多个属性的排名，则需要对聚合进行分区（PARTITION BY），以便可以为每个指定的属性显示适当的排名</p>
<p>select rank() from XXX 外面再套个select * from () where rank&lt;5来实现TopN </p>
<p>ROW_NUMBER函数为分区中的每一行分配一个唯一的编号（依次从1开始，由ORDER BY定义）。有点像sequence。用来手动排rank</p>
<p>ROW_NUMBER() OVER ([query_partition_clause] order_by_clause)</p>
<p>PERCENT RANK</p>
<p>percent_rank() over (order by sum(f.revenue) desc) as “Percent Rank”</p>
<p>Cumulative Aggregates</p>
<p>SUM(SUM(XXX)) OVER (ORDER BY aaa,bbb ROWS UNBOUNDED PRECEDING)</p>
<p>UNBOUNDED表示无界，PRECEDING前</p>
<p>解析函数SUM为每一行定义一个窗口，该窗口从分区的开头（UNBOUNDED PRECEDING）开始，默认情况下在当前行结束。<br>在此示例中，需要嵌套SUM，因为我们正在对本身就是SUM的值执行SUM。<br>嵌套聚合在分析聚合函数中经常使用</p>
<p>SUM(SUM(XXX)) OVER (PARTITION BY aaa ORDER BY aaa,bbb ROWS UNBOUNDED PRECEDING)</p>
<p>Moving Aggregate</p>
<p>(AVG(SUM(XXX)) OVER (ORDER BY aaa,bbb ROWS 2 PRECEDING)</p>
<p>(AVG(SUM(XXX)) OVER (ORDER BY aaa,bbb ROWS 2 PRECEDING)</p>
<p>用两个的平均表现moving</p>
<h2 id="S9-BI"><a href="#S9-BI" class="headerlink" title="S9 BI"></a>S9 BI</h2><h3 id="Navigation-Methods"><a href="#Navigation-Methods" class="headerlink" title="Navigation Methods"></a>Navigation Methods</h3><p>Drill Down</p>
<p>Drill Up (a.k.a. Roll Up)</p>
<p>Drill Through</p>
<p>Drill Across</p>
<h2 id="EXAM"><a href="#EXAM" class="headerlink" title="EXAM"></a>EXAM</h2><p>考试就是1-9的内容。较难，不熟练会时间来不及（就是我）。</p>
<p>考试内容和模拟考形式完全一致</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>business intelligence</tag>
        <tag>data warehouse</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT9131: Java</title>
    <url>/post/fit9131-java-bluej-notes/</url>
    <content><![CDATA[<p>学校要求的是使用bluej这个ide/editor。这个工具和intellij idea不同，完全是面向教学，写Java有种写script的感觉。可以拿来写各种class但是不能保存各种实例化的object。</p>
<p>到目前（W4）为止，内容都是很简单的。</p>
<p>到W7也還是很簡單……</p>
<p>到W12依然还是很简单……</p>
<p>最后考试大概是没考好，明明ASS全HD但最终只有79没拿到HD太可惜了</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT9136: algo &amp; python</title>
    <url>/post/fit9136-algo-and-python-notes/</url>
    <content><![CDATA[<p>相对简单</p>
<span id="more"></span>

<h2 id="W5"><a href="#W5" class="headerlink" title="W5"></a>W5</h2><p>OOP</p>
<p>py3直接用<code>class XXX:</code>而不是2的<code>class XXX(object):</code> (3里俩写法等价) </p>
<h2 id="W6"><a href="#W6" class="headerlink" title="W6"></a>W6</h2><p>Stack: LIFO</p>
<p>Queue: FIFO</p>
<p>Heap: 就是一种特殊的树Tree。顶部（root）为一个极值（子树也是）。其中Node之间的连接叫Edge</p>
<h2 id="W7"><a href="#W7" class="headerlink" title="W7"></a>W7</h2><h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h3><p>复杂度这个概念和后面的各个算法都有关，所以挺重要的。</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210216001214995.png" class="" title="image-20210216001214995">

<p>计算方法是：</p>
<p>把算法函数内每个步骤的复杂度取出来，然后<code>+</code>起来</p>
<p>比如</p>
<blockquote>
<p> 2N + 2 -&gt; O(n)</p>
<p>n^2 + n + 1 -&gt; O(n^2)</p>
<p>log(n) + n + a -&gt; O(n)</p>
</blockquote>
<p>本质就是留下复杂度最大的那个（瓶颈）</p>
<p>这里1，N，N^2，N^N这些复杂度都很好理解。</p>
<p>但是log(N)是什么情况？</p>
<p><a href="https://stackoverflow.com/questions/2307283/what-does-olog-n-mean-exactly" target="_blank" rel="noopener">stackoverflow</a>这里给的例子就比较全面。</p>
<p><strong>O(log n):</strong> 选择要在其上执行某些动作的下一个元素是几种可能性之一，并且仅需要选择一个。</p>
<p>例如：给定一个人的名字，找到他的电话号码。所用方法是在尚未搜索的那本书（有序！）的一半左右随机选择一个点，然后检查该人的名字是否在该点上。 然后在此人名字所在的部分的一半左右重复该过程。（即对人名的binary search，二分法）</p>
<p><strong>O(n log n):</strong> 打印机办公室里有些混乱，我们的电话簿中的所有页面都是<strong>随机插入</strong>的。 通过查看每个页面上的名字，然后将该页面放在新的空电话簿中的适当位置，可以更正顺序，使其正确无误。</p>
<h3 id="Searching-Algorithm"><a href="#Searching-Algorithm" class="headerlink" title="Searching Algorithm"></a>Searching Algorithm</h3><p>Linear Search太简单，就一个个代，略</p>
<p>Binary Search参考上面O(log n)解析</p>
<h3 id="Sorting-Algorithm"><a href="#Sorting-Algorithm" class="headerlink" title="Sorting Algorithm"></a>Sorting Algorithm</h3><p>Bubble Sort: 就左右互换直到所有 左&lt;右。一般就先把最大/最小挪到位然后再排。平均和最坏都是O(n^2)，最好是O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">the_list</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(the_list)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>): </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i): <span class="comment">#上个for从maxIndex到0,就是为了在这里省的写[0,index]直接range表示了</span></span><br><span class="line">            <span class="keyword">if</span> the_list[j] &gt; the_list[j+<span class="number">1</span>]:</span><br><span class="line">                temp = the_list[j]</span><br><span class="line">                the_list[j] = the_list[j+<span class="number">1</span>]</span><br><span class="line">                the_list[j+<span class="number">1</span>] = temp</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> the_list</span><br></pre></td></tr></table></figure>



<p>Selection Sort: 找index后面最小的然后互换。O(𝑛^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">the_list</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(the_list)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        smallest = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> the_list[j] &lt; the_list[smallest]:</span><br><span class="line">                smallest = j</span><br><span class="line"></span><br><span class="line">        the_list[smallest], the_list[i] = the_list[i], the_list[smallest] <span class="comment">#交换</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> the_list</span><br></pre></td></tr></table></figure>



<p>Insertion Sort: 把每个源数组的元素有序地丢到新数组里。（比如先丢5，然后看见8了再丢5后面，看见7了确定丢5和8中间）。O(𝑛^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">the_list</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(the_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        current = the_list[i]</span><br><span class="line">        pos = i</span><br><span class="line">        <span class="keyword">while</span> pos &gt; <span class="number">0</span> <span class="keyword">and</span> the_list[pos-<span class="number">1</span>] &gt; current:</span><br><span class="line">            the_list[pos] = the_list[pos-<span class="number">1</span>]</span><br><span class="line">            pos -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        the_list[pos] = current <span class="comment">#丢</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> the_list</span><br></pre></td></tr></table></figure>



<h2 id="W8"><a href="#W8" class="headerlink" title="W8"></a>W8</h2><p>二叉树和二叉搜索树</p>
<p>二叉树本身不带规则，只规定这形状，要用起来就得自己给它加点规则</p>
<p>二叉搜索树就是带了“<em>左边小于右边</em>”这个规则</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210216010832615.png" class="" title="image-20210216010832615">



<p>Breadth（宽度） First Search (BFS)，即优先找横的（跨node！）</p>
<p>Depth First Search (DFS)，即优先找竖的（顺藤摸瓜）</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210216010612186.png" class="" title="image-20210216010612186">

<p>这些1234是查找时候的序列，不是值</p>
<p>另外还有个平衡Balance的概念，就把深度对对齐（±1）。</p>
<p>Balance有助于减少搜索步数N -&gt; logN </p>
<h2 id="W9"><a href="#W9" class="headerlink" title="W9"></a>W9</h2><p>测试，错误处理和外部库（讲的标准库，numpy，pandas和matplotlib）</p>
<p>assert onFalse, “err”</p>
<p>对于代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mark = <span class="number">0</span> <span class="comment"># variable to change</span></span><br><span class="line"><span class="keyword">if</span> mark &gt;= <span class="number">50</span> <span class="keyword">and</span> mark &lt;= <span class="number">100</span>:</span><br><span class="line">    grade = <span class="string">&quot;Passed&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    grade = <span class="string">&quot;Failed&quot;</span></span><br><span class="line">    </span><br><span class="line">print(grade)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="blue">Valid (positive) cases</font>:</p>
<ul>
<li>Based upon “correct” input data</li>
<li>Examples: 55, 60, 65, …, 85, 90, 95, …</li>
</ul>
</li>
<li><p><font color="blue">Invalid (negative) cases</font>:</p>
<ul>
<li>Based upon “incorrect” input data</li>
<li>Examples: -1, 0, 5, …, 45, 49, 101, 200, …</li>
</ul>
</li>
<li><p><font color="blue">Boundary cases</font>:</p>
<ul>
<li>Boundary values of the “equivalence class” for valid cases</li>
<li>Examples: (49, 50) and (100, 101)</li>
<li>即一个pair，其中元素一个能success一个就fail</li>
</ul>
</li>
</ul>
<h2 id="W10"><a href="#W10" class="headerlink" title="W10"></a>W10</h2><p>文件，库和包（RegExp）</p>
<h2 id="W11"><a href="#W11" class="headerlink" title="W11"></a>W11</h2><p>11和12有点难，Quiz11-12直接大意失荆州。</p>
<h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide-and-Conquer"></a>Divide-and-Conquer</h3><p>大意就是将func中任务细分（divide）然后逐个解决（conquer）最后合并（combine）</p>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>Binary Search是作为Divide-and-Conquer的例子出现的，并不是之前的BST（Binary Search Tree，w8内容）</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">the_list, target_item</span>):</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(the_list)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> the_list[mid] == target_item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target_item &lt; the_list[mid]:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec_binary_search</span>(<span class="params">the_list, target_item</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(the_list) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(the_list) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> the_list[mid] == target_item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target_item &lt; the_list[mid]:</span><br><span class="line">            smaller_list = the_list[:mid]</span><br><span class="line">            <span class="keyword">return</span> rec_binary_search(smaller_list, target_item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            larger_list = the_list[mid+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">return</span> rec_binary_search(larger_list, target_item)</span><br></pre></td></tr></table></figure>

<h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h3><p>递归，简单，略</p>
<h3 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h3><p>Merge Sort是作为Recursive的例子出现。</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210215085536597.png" class="" title="image-20210215085536597">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">the_list</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(the_list)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        mid = n //<span class="number">2</span> </span><br><span class="line"></span><br><span class="line">        left_sublist = the_list[:mid]</span><br><span class="line">        right_sublist = the_list[mid:]</span><br><span class="line"></span><br><span class="line">        merge_sort(left_sublist)</span><br><span class="line">        merge_sort(right_sublist)</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span> <span class="comment"># index for left sublist</span></span><br><span class="line">        j = <span class="number">0</span> <span class="comment"># index for right sublist</span></span><br><span class="line">        k = <span class="number">0</span> <span class="comment"># index for main list</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_sublist) <span class="keyword">and</span> j &lt;<span class="built_in">len</span>(right_sublist):</span><br><span class="line">            <span class="keyword">if</span> left_sublist[i] &lt;= right_sublist[j]:</span><br><span class="line">                the_list[k] = left_sublist[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                the_list[k] = right_sublist[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_sublist):</span><br><span class="line">            the_list[k] = left_sublist[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_sublist):</span><br><span class="line">            the_list[k] = right_sublist[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h3><p>Quick Sort也是作为Recursive的例子出现。</p>
<ul>
<li><font color="blue">Divide</font>: Select a “<strong>pivot</strong>” to serve as the partition point<ul>
<li>Elements smaller than the pivot are relocated to the left of the pivot</li>
<li>Elements greater than the pivot are relocated to the right</li>
</ul>
</li>
<li><font color="blue">Conquer</font>: Recursively partition the sublists based on the pivot chosen for each sublist</li>
<li><font color="blue">Combine</font>: No computation needed</li>
<li><font color="blue">Base case</font>: A sublist with length of one (considered sorted) or with zero length</li>
<li>Best case: O(n*log(n)) Worst case: O(n^2)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">the_list</span>):</span></span><br><span class="line">    first = <span class="number">0</span></span><br><span class="line">    last = <span class="built_in">len</span>(the_list)-<span class="number">1</span></span><br><span class="line">    quick_sort_aux(the_list, first, last)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort_aux</span>(<span class="params">the_list, first, last</span>):</span></span><br><span class="line">    <span class="keyword">if</span> first &lt; last:</span><br><span class="line">        part_point = partitioning(the_list, first, last)</span><br><span class="line"></span><br><span class="line">        quick_sort_aux(the_list, first, part_point-<span class="number">1</span>)</span><br><span class="line">        quick_sort_aux(the_list, part_point+<span class="number">1</span>, last)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partitioning</span>(<span class="params">the_list, first, last</span>):</span></span><br><span class="line">    pivot_value = the_list[first]</span><br><span class="line"></span><br><span class="line">    left_index = first + <span class="number">1</span></span><br><span class="line">    right_index = last</span><br><span class="line">    </span><br><span class="line">    complete = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> complete:</span><br><span class="line">        <span class="keyword">while</span> left_index &lt;= right_index <span class="keyword">and</span> \</span><br><span class="line">            the_list[left_index] &lt;= pivot_value:</span><br><span class="line">                left_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right_index &gt;=  left_index <span class="keyword">and</span> \</span><br><span class="line">            the_list[right_index] &gt;= pivot_value:</span><br><span class="line">                right_index -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right_index &lt; left_index:</span><br><span class="line">            complete = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            the_list[left_index], the_list[right_index] \</span><br><span class="line">            = the_list[right_index], the_list[left_index]</span><br><span class="line">                </span><br><span class="line">    the_list[first], the_list[right_index] \</span><br><span class="line">                = the_list[right_index], the_list[first]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> right_index</span><br></pre></td></tr></table></figure>

<h2 id="W12"><a href="#W12" class="headerlink" title="W12"></a>W12</h2><h3 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h3><ul>
<li>适合通常不会产生最佳解决方案的情况（就是没法直接一个solution直接撸</li>
<li>解决背包问题（Knapsack，即怎么把东西放到容量有限的背包里能收益最大化）</li>
<li>greedy不会先想着去满足最优，而是先想着把要求（塞满背包）给优先满足</li>
<li>有时，任何一种立马得出的解决方案都比几天之内才想出来的的最佳解决方案要好。</li>
<li>通常，某些算法会在运行时找到最佳解决方案，但需要一种假设的解决方案才能开始工作。 Greedy可以很容易地做到这一点。</li>
</ul>
<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute-Force"></a>Brute-Force</h3><ul>
<li>保证算出最优解Brute force guarantees the <font color="blue">optimal</font> result will be discovered because it explores every possibility.</li>
<li></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brute_force</span>(<span class="params">solution, N</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(solution) == N:</span><br><span class="line">        print(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        options = getOptions()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> option <span class="keyword">in</span> options:</span><br><span class="line">            brute_force(solution + option, N)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOptions</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [ <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>) ]</span><br></pre></td></tr></table></figure>



<h3 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h3><ul>
<li>Backtracking is an improvement on Brute-force. It ensures that only solutions that are possible are generated.</li>
<li>Backtracking is a more elegant brute force. Behold(看作) what happens when brute force attempts to find a solution.</li>
</ul>
<p>用来解决类似N皇后（N*N的棋盘上放N个皇后）问题。本质也是暴力穷举</p>
<h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><blockquote>
<p>What is the name of the following sort algorithm?</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210215081745028.png" class="" title="image-20210215081745028">

<p>Select one:</p>
<p>A. Merge Sort</p>
<p>B. Selection sort</p>
<p>C. Quick sort</p>
<p>D. Bubble sort</p>
<p>A:  Quick sort</p>
</blockquote>
<blockquote>
<p>What is the name of the algorithm for the following method ?</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210215144139053.png" class="" title="image-20210215144139053">


<p>Select one:</p>
<p>A. Backtracking</p>
<p>B. Boyer - Moore</p>
<p>C. Greedy</p>
<p>D. Bruce Force</p>
<p>A: Bruce Force</p>
</blockquote>
<blockquote>
<p>Which of the problems or puzzles cannot be solved by backtracking method?</p>
<p>Select one or more:</p>
<p>A. travelling salesman problem</p>
<p>B. Knapsback</p>
<p>C. crossword</p>
<p>D. n-queen problem</p>
<p>A: A&amp;B</p>
</blockquote>
<p>只选了A，因为当时quiz时候找不到A。现在找发现好像C也找不到。</p>
<p>Crossword是通过边上给的提示来猜出一个N*N矩阵上的每个英文字母（含黑块，不用填）。因为和N-Queen一样只要得到一个解就能结束所以就能用backtrack。</p>
<p>Knapsback是背包问题，Greedy的案例。</p>
<p>travelling salesman problem根据Wikipedia解释就是解决*Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?*差不多就多点路线规划，个人理解应该需要Greedy</p>
<blockquote>
<p>In Brute Force, the best-case running time is O ( nm )</p>
<p>A: F</p>
</blockquote>
<p>The time complexity of brute force is <strong>O(mn)</strong>, which is sometimes written as <strong>O(n*m)</strong> . So, if we were to search for a string of “n” characters in a string of “m” characters using brute force, it would take us n * m tries. 另外没有best-case的说法</p>
<blockquote>
<p>Which of the following problems can be solved using a backtrack problem ?</p>
<p>Select one or more:</p>
<p>A. M colour map</p>
<p>B. N-Queen Problem</p>
<p>C. Knapsack</p>
<p>D. Tower of hanoi</p>
<p>A: A&amp;B&amp;D</p>
</blockquote>
<p>相比上面的又多了俩游戏。</p>
<p>M colour map，没找到，但是个人理解应该指的是<a href="https://en.wikipedia.org/wiki/Four_color_theorem" target="_blank" rel="noopener">Four color theorem</a>。用M种颜色不接触地涂满全部。</p>
<p><a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi" target="_blank" rel="noopener">Tower of hanoi</a>，汉诺塔。找出方法从左搬到右<img src="/post/fit9136-algo-and-python-notes/300px-Tower_of_Hanoi.jpeg" class="" title="img"></p>
<blockquote>
<p>Which of the following is true about Quick and Merge sort</p>
<p>Select one or more:</p>
<p>A. The quick sort is an internal sorting method where the data is sorted in main memory.</p>
<p>B. None of the above</p>
<p>C. Quick sort is more efficient and works faster than merge sort in case of smaller array size or datasets.</p>
<p>D. Merge sort is more efficient and works faster than quick sort in case of larger array size or datasets.</p>
<p>A: A&amp;C&amp;D</p>
</blockquote>
<p>Quick Sort是一种内部排序方法（大概是说它不引入别的所以是内部？），其中数据在主内存中排序。√</p>
<p>在较小的数组或数据集的情况下，Quick Sort比Merge sort更有效且工作更快。√</p>
<p>在较大数组大小或数据集的情况下，Merge sort比Quick Sort更有效且工作更快。√</p>
<blockquote>
<p>Which of the following is the most stable sort and has less time complexity ?</p>
<p>Select one:</p>
<p>A. Merge Sort</p>
<p>B. Quick Sort</p>
<p>C. None.</p>
<p>D. Bubble Sort</p>
<p>A: Merge Sort</p>
</blockquote>
<p>Merge Sort的复杂度见下面</p>
<blockquote>
<p>The average case and worst case complexities for Merge sort algorithm are</p>
<p>Select one:</p>
<p>A. O ( n^2 ), O ( n^2 )</p>
<p>B. O ( n^2 ), O ( nlog2(n) )</p>
<p>C. O ( nlog2(n) ), O ( nlog2(n) )</p>
<p>D. O ( nlog2(n) ), O ( n^2 )</p>
<p>A: C. O ( nlog2(n) ), O ( nlog2(n) )</p>
</blockquote>
<p>Merge sort总是要迭代到<img src="/post/fit9136-algo-and-python-notes/image-20210216000638777.png" class="" title="image-20210216000638777"></p>
<p>这样全部打散</p>
<blockquote>
<p> For two objects x and y:</p>
<ul>
<li>x is y is True<br>if and only if</li>
<li>id(x) == id(y)</li>
</ul>
<p>A: T</p>
</blockquote>
<p>if and only if表示当且仅当所以正确</p>
<blockquote>
<p>What things is an object associated with ?</p>
<p>Select one or more:</p>
<p>A. Value</p>
<p>B. Element</p>
<p>C. Object type</p>
<p>D. Data type</p>
<p>A: Data type , Object type</p>
</blockquote>
<p>Val &amp; Elem都与Obj无关</p>
<blockquote>
<p>What are the main applications of tree data structure?</p>
<ol>
<li>Manipulate hierarchical data</li>
<li>Make information easy to search (see tree traversal).</li>
<li>Manipulate sorted lists of data</li>
<li>Router algorithms</li>
<li>Form of a multi-stage decision-making, like Chess Game.</li>
<li>As a workflow for compositing digital images for visual effects</li>
</ol>
<p>Select one:</p>
<p>A. 1, 2, 3, 4 and 6</p>
<p>B. 1, 3, 4, 5 and 6</p>
<p>C. 1, 2, 3, 4, 5 and 6</p>
<p>D. 1, 2, 3, 4 and 5</p>
<p>A: C. 1, 2, 3, 4, 5 and 6</p>
</blockquote>
<p>答案是全对。当时没选6，没注意主语是workflow。用Tree来表示workflow是可以的</p>
<blockquote>
<p>What does “+” mode mean, while working with files?</p>
<p>a. Append</p>
<p>b. Write</p>
<p>c. Read</p>
<p>d. Read and Write</p>
<p>A: d. Read and Write</p>
</blockquote>
<p>选错选了a. Append。Append应该是”a” mode</p>
<h2 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h2><p>总体简单，大量送分，全程基本都是写写写没选择</p>
<p>考了Depth First Inorder/Preorder/Postorder Tree 和Breadth First的List View（始料未及</p>
<p>还有手撸的selection sort</p>
<p>另外之前关注的valid/invalid/boundary test果然成考点</p>
<p>最后只有75，感觉考试扣分还是很严重</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>python</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>How to create a temporary NGIN network</title>
    <url>/post/how-to-create-a-temp-ngin-network/</url>
    <content><![CDATA[<p>This is the tutorial material for dev building a temporary NGIN network through ngcore’s regression testnet flag.</p>
<span id="more"></span>

<h2 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h2><p>Before we start, we should create two different folder to keep the chain data. </p>
<p>I will suggest using <code>--in-mem</code> flag which can reach the same goal.</p>
<p>If you dislike that, for example, you can create <code>./dataFolder1</code> and <code>dataFolder2</code>.<br>On the following ngcore command, you should add <code>--db-folder dataFolder1</code> for the first node<br>and <code>--db-folder dataFolder2</code> for the second one</p>
<h2 id="Node-0"><a href="#Node-0" class="headerlink" title="Node #0"></a>Node #0</h2><p>let we start a regression testnet ngcore node with <code>--reg-testnet</code> only first. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ngcore --reg-testnet --db-folder ./env/1 --p2p-key ./env/1.p2pkey </span><br></pre></td></tr></table></figure>

<p>The node will serve its p2p service on 52520 and rpc service on 52521.</p>
<p>Write down this node’s p2p address like <code>16Uiu2HAmL6ojX5jgxJsoo55suHxM8HocaLuMx4uLSfHpER9rTYtJ</code> , which will be used in the connecting step.</p>
<h2 id="Node-1"><a href="#Node-1" class="headerlink" title="Node #1"></a>Node #1</h2><p>Now we need to start another one on different port</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ngcore --reg-testnet --db-folder ./env/2 --p2p-key ./env/2.p2pkey --p2p-port 62620 --rpc-port 62621</span><br></pre></td></tr></table></figure>

<p>The node will serve its p2p service on 62620 and rpc service on 62621.</p>
<h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p>To build a small network, we should use rpc command to manually connect them.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;method&quot;: &quot;addPeer&quot;, &quot;params&quot;: &#123;&quot;peerMultiAddr&quot;: &quot;/ip4/127.0.0.1/tcp/52520/p2p/16Uiu2HAmL6ojX5jgxJsoo55suHxM8HocaLuMx4uLSfHpER9rTYtJ&quot;&#125; &#125;&#x27;</span> http://127.0.0.1:62621</span><br></pre></td></tr></table></figure>

<p><code>16Uiu2HAmL6ojX5jgxJsoo55suHxM8HocaLuMx4uLSfHpER9rTYtJ</code> is the p2p address of node #0 in my machine. You should replace it with yours.</p>
<h2 id="Startup"><a href="#Startup" class="headerlink" title="Startup"></a>Startup</h2><p>Finally, you should let one of your node start mining, to import blocks into your chain.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;method&quot;: &quot;switchMining&quot;, &quot;params&quot;: &#123;&quot;mode&quot;: &quot;on&quot;&#125; &#125;&#x27;</span> http://127.0.0.1:62621</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>todo</tag>
        <tag>blockchain</tag>
        <tag>NGIN</tag>
        <tag>p2p</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea on edX&#39;s Blockchain Technology</title>
    <url>/post/idea-on-edx-blockchain-tech/</url>
    <content><![CDATA[<p>Some writes for edx blockchain course</p>
<span id="more"></span>

<h2 id="What-is-PoW"><a href="#What-is-PoW" class="headerlink" title="What is PoW"></a>What is PoW</h2><p>The idea for Proof of Work(PoW) was first published in 1993 by Cynthia Dwork and Moni Naor and was later applied by Satoshi Nakamoto in the Bitcoin paper in 2008. Proof of Work consensus is the mechanism of choice for the majority of cryptocurrencies currently in circulation. The term “proof of work” was first used by Markus Jakobsson and Ari Juels in a publication in 1999. Nowadays, it is widely used in public chain projects especially bitcoin and ethereum codebased ones</p>
<p>The goal of PoW is to maintain the p2p network, defending from DoS attacks, and gurantee the value’s safety on chain. PoW imposes some restrictions on operations in the network. They need to put a lot of effort into execution. Effective attacks require a lot of computing power and a lot of time to calculate. Therefore, an attack is possible, but it is useless because the cost is too high. And it is important to have strong computing power to solve difficult problems and form new obstacles no matter how much money in the wallet. Therefore, the holders of huge amounts of funds are not responsible for the decision of the entire network. It is more like a “two factor authorization”, because it uses non-service-ralated factors, like CPU computation, to gurantee datastore in the chain is safe. For example, in bitcoin, coins are “mined” using the Hashcash proof-of-work function by individual miners and verified by the decentralized nodes in the P2P bitcoin network. And the difficulty is periodically adjusted to keep the block time around a target time.</p>
<h2 id="The-Understanding-on-Proof-of-Work"><a href="#The-Understanding-on-Proof-of-Work" class="headerlink" title="The Understanding on Proof of Work"></a>The Understanding on Proof of Work</h2><p>The defination of PoW is well-known, so I wont repeat these basic infomation. On the other hand, as an experienced PoW(mining) project host and user, I would argue more personal opinion about the “shortages” of PoW ecosystem.</p>
<p>0x01 Energy really is wasted on PoW?</p>
<p>Almost all opponents of PoW are focus on the usage of electricity, and then comparing to their home electricity price to conclude a huge lost result. But the fact is, the waste is less than they imagine, even no actual loss. </p>
<p>I have to answer, no, PoW is not a waste of electricity.</p>
<p>As a Chinese, I know how a miner or a mining farm manager controls his cost on electric - find the cheapest electricity source. In China, you can find excess hydropower in wide Southern area, and wind power in West. If there is no mining pool, the cheap electricity will have to be moved to the national power grid and add the high transportation cost to its price. Thus in large cities, like Shanghai, electricity price is much higher. But with mining, the value of electricity can be converted into the coin value on the first time, and we just need to move the necessary part to maintain the power grid. So we can avoid the power loss on transportation, we can avoid the value loss on transportation, even we can avoid the extra cost on electricity management.</p>
<p>And also, the cost of PoW is not more than the triditional economy. We always call cryptocurrency “the new money”, and it represents that the cryptocurrency itself can be a standalone economic system. You can google how many resources are wasted by the “old moneys”, the cost of every banks, clearing houses, finance brokers etc. The answer is that it must be larger than PoW. I am used to worked in Citibank, I saw the stuffs never turn off their computers after work, I saw the sub-branch was open but did not serve anyone, I saw stuffs competing with each other by food-wasting Chinese style dinners. So why their work is not resource-consuming, but PoW is?</p>
<p>0x01 PoW is worse than other consensus?</p>
<p>Nowadays it is a trend that desperating PoW in blockchain developing, and the projects which still uses PoW are all treated as a “Bitcoin style”, “Old style”, “Out of date style”, regardless of whether it is really a bitcoin fork.</p>
<p>But I have to answer again, no, PoW is never worse than anyone, especially for public chain.</p>
<p>I had maintained one cryptocurrency project. Maybe beacase of the situation which was fulfilled with eth tokens or the token-style project name, my project was always treated as a token. After publishing on bitcointalk forum, tons of vendors sent me message - provide ICO(initial coin offering) service, provide advertisement service, provide exchange service, provide google rank service, provide youtube interview service, etc. But all of them were charging 0.5-2BTC which I cannot afford as a small technical project. The fact was that we were a PoW mining project having a great scene application. I felt failure at first becasue I cannot afford services. However, after mainnet igniting, the hashrate of the network was pumping and the coin price was pumping. Then I started reviewing bitcoin, ethereum, and projects born from ethereum like EOS.</p>
<p>It is clear that, PoW leads to the bitcoin’s successful. Without it, there will be nobody who are willing to pay their fiat currency to a useless unreliable coin whose founder disappering. </p>
<p>As for ethereum, though Vitalik Buterin says PoS is a better, without Ethash, ethereum wont ignite its mainnet and pump its coin price. </p>
<p>Some will argue that ethereum’s success is from its decentralized applications, which is not depending on mainnet coin price nor PoW consensus. Maybe it’s right, it is true that PoW is not fit for private chain or union chain, becasue it needs other factors to keep the network safety instead of electricity. But the opponents still have to approve that the PoW guarantee the robust of ethereum’s, as a public chain, “value network”. And also, with this, ethereum is able to serve the well-known token publish services. Provided with no PoW gurantee, ethereum will be hard to serve at beginning. After all, bitcoin network, or bitcoin forks can also privide token services, and projects like EOS would be ICOed in bitcoin network not ethereum.</p>
<h2 id="What-is-consensus"><a href="#What-is-consensus" class="headerlink" title="What is consensus?"></a>What is consensus?</h2><p>There is <a href="https://godoc.org/github.com/libp2p/go-libp2p-consensus" target="_blank" rel="noopener">an abstract go lib</a> which is great for understanding what consensus is</p>
<p>And its theorical raft implement is <a href="https://godoc.org/github.com/libp2p/go-libp2p-raft" target="_blank" rel="noopener">here</a>, practical raft implement is <a href="https://godoc.org/github.com/ipfs/ipfs-cluster/consensus/raft" target="_blank" rel="noopener">here</a></p>
<p>So, in short, consensus is a manager of state, which ensures the state’s unify among p2p network, accepting and execuating continuous opeartions on state. </p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>edx</tag>
      </tags>
  </entry>
  <entry>
    <title>Linguaskill</title>
    <url>/post/linguaskill-notes/</url>
    <content><![CDATA[<p>記錯考試日期了，所以有了多的時間來總結</p>
<span id="more"></span>

<h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p>(L-&gt;R), (S), (W)</p>
<p>括號表示一個科目。</p>
<p>科目之間自由選擇哪個先考。</p>
<p>LR不卡時間(好像,反正沒倒計時)</p>
<p>S每題卡對應時間。</p>
<p>W總計45min倒計時。</p>
<h2 id="Writing-1"><a href="#Writing-1" class="headerlink" title="Writing #1"></a>Writing #1</h2><h3 id="Keypoints"><a href="#Keypoints" class="headerlink" title="Keypoints"></a>Keypoints</h3><p>B2 Keypoints:</p>
<ul>
<li><strong>suggestions</strong>(我們做啥啥怎麽樣) and <strong>offers</strong>(我可以做啥啥，你怎麽看)</li>
<li>not required accuracies</li>
<li>vocabulary is used appropriately</li>
<li>no significant issue</li>
<li>informal lang, fixed phrases idioms and questions are used effectively</li>
<li>positive effect on the reader</li>
<li>well-organized, straightforward ideas ppt</li>
<li>cohesion</li>
</ul>
<p>C1 Keypoints:</p>
<ul>
<li>full control of the grammar</li>
<li>wide variety of structures, flexibility and accuracy</li>
<li>accurate and appropriate volcabulary</li>
<li>some good examples of collections</li>
<li>no spelling or punctuation problem</li>
<li>其他基本上同B2，要求informal和positive</li>
<li>use cohesive devices like substitution(=backup solution,plan B), and phrases that signpost the current stage of diz and shared knowledge(=通報情況之後再下建議). </li>
</ul>
<h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>You have recieved this email from a friend who you want to college with.</p>
<blockquote>
<p>Do you know it will soon be 5 years since we finished college? I think we should contact our old friends and arrange to meet again. Have you got any ideas about what we could do to celebrate and when?</p>
<p>Write and tell me</p>
<p>Jan</p>
</blockquote>
<p>Write at least 50 words.</p>
<h3 id="C1-範文"><a href="#C1-範文" class="headerlink" title="C1 範文:"></a>C1 範文:</h3><blockquote>
<p>Hi Jan,</p>
<p>So nice to hear from you! How are you doing?</p>
<p>It would be great to meet and celebrate with our friends from college. How about meeting in London sometimes next month? We could meet in a pub, have dinner, and then go to a club, like in the old days?</p>
<p>I think that Saturday 20th would work best for everyone: I know that the Ruth is on holiday next weekend , and I will be away the following one  (on a business trip to Japan, I will tell you more about it when we meet!), If I remember well, you are busythe weekendof the 27th, as you are attending your sister-in-law’s wedding, aren’t you? Taking all that into account, Saturday 20th Looks like the best option. We would have to ask Sean, Mary and Alex if they are available though.</p>
<p>If you want, I could send an email to everyone, to check that we are all free on Saturday 20th, and suggest that we meet in London. I’ll tell them about my idea of going to a pub and then to a club, but maybe someone (May always has grerat ideas!). Then we can talk about hotel bookings, as most of us have to stay the night, I guess.</p>
<p>I’m really looking forward to it, thanks a lot for suggesting it!</p>
<p>See you soon,</p>
<p>MY_NAME</p>
</blockquote>
<h2 id="Writing-2"><a href="#Writing-2" class="headerlink" title="Writing #2"></a>Writing #2</h2><h3 id="Keypoints-1"><a href="#Keypoints-1" class="headerlink" title="Keypoints"></a>Keypoints</h3><p>和其他考試寫作差不多，也是通過説明事情發表觀點。不過就比較貼近生活，而且思路也給出了。瞎jb腦補吧。</p>
<h3 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a>題目</h3><p>The town where you live has a website where local people can discuss local issues. You are concerned about the increase in car and truck traffic in the twon and have decided to post your comments on the website.</p>
<p>Write your <strong>comments</strong> for the town website</p>
<p>Write about:</p>
<ul>
<li>Why you think the amount of traffic is increasing in your town</li>
<li>What problems the increased traffic is causing in your town</li>
<li>how the amount of traffic in your town could be reduced</li>
</ul>
<p>and any other points you think are important.</p>
<p>Write at least 180 words.</p>
<h3 id="C1-範文-1"><a href="#C1-範文-1" class="headerlink" title="C1 範文"></a>C1 範文</h3><blockquote>
<p>[Grammerly Optimized]</p>
<p>I am writing this comment to complain about the worrying increase in car and lorry traffic in our town lately.</p>
<p>As far as I am concerned, the main reason for this issue is that a 40-block building is being constructed in our neighborhood. Lorries need to function at full speed to carry necessary material for the construction. Moreover, the main road that leads to the center of the city is banned for decoration of the coming festival. People whose workplaces are located in the town not only endure the syren that is made by the vehicles, but also suffer from illnesses caused by air-polluted, especially the elderly. They cannot sleep well at night since the lorries work 24 hours per day. Everything is dusty because of carelessly covered containers of lorries, We cannot let our children play at the playground of the town for the fear that they can put themselves in danger. Furthermore, we are usually late for work and school because of traffic jams in rush hours.</p>
<p>As a citizen of the town, I think the authority should take action to reduce the amount of traffic that travels to our town every day. Lorries must be banned in crush hours. Moreover, the container of lorries should be covered carefully in order not to drop any material that they are carrying. Last but not least, people should be shown other ways that lead to the center so that they do not put pressure on our infrastructure.</p>
<p>I hope that my complaint can be taken into consideration so that our town can become an enjoyable place to live again.</p>
</blockquote>
<h2 id="Speaking"><a href="#Speaking" class="headerlink" title="Speaking"></a>Speaking</h2><h3 id="Part1-8Q"><a href="#Part1-8Q" class="headerlink" title="Part1 - 8Q"></a>Part1 - 8Q</h3><p>8個簡單問題，同雅思p1。1-4說10s，5-8說20s。</p>
<p>據(萬象教育B站視頻)説1&amp;2不計分，反正10s就兩句話報姓名再spell很快的。</p>
<p>後面預計就是3,4個人情況補充，5-8問喜好經歷</p>
<h3 id="Part2-Read-8-sentences"><a href="#Part2-Read-8-sentences" class="headerlink" title="Part2 - Read 8 sentences"></a>Part2 - Read 8 sentences</h3><p><strong>簡單句務必慢點讀</strong></p>
<p>技術角度看很可能是機改。從speakingandimprove.com測試來看，斷句和發音很重要。</p>
<p>個人經歷：測試的時候讀太快(無語氣無斷句)直接讀到了B1……</p>
<h3 id="Part3-Topic"><a href="#Part3-Topic" class="headerlink" title="Part3 - Topic"></a>Part3 - Topic</h3><p>類似雅思P2，具體需要回答的點會給出。40s read 1min speak。</p>
<h3 id="Part4-看圖説話"><a href="#Part4-看圖説話" class="headerlink" title="Part4 - 看圖説話"></a>Part4 - 看圖説話</h3><p>看見過的有，流程圖，事物對比給建議。1min read 1min speak</p>
<h3 id="Part5-記者瞎jb5問"><a href="#Part5-記者瞎jb5問" class="headerlink" title="Part5 - 記者瞎jb5問"></a>Part5 - 記者瞎jb5問</h3><p>給出各個問題的觀點。40s準備每個問題答20s也就是說100s。</p>
<h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>因爲口語一直被壓分所以反思一下</p>
<p>P1 - 流利度</p>
<p>P3 - 选择说，扩写</p>
<h2 id="Reading-amp-Listening"><a href="#Reading-amp-Listening" class="headerlink" title="Reading &amp; Listening"></a>Reading &amp; Listening</h2><p><del>EZ Game</del></p>
<p>好吧，就跪在這個EZ裏了。</p>
<p>L拿了C1還挺給面子，R直接B1……</p>
<p>R考察的點就比較神奇，不像其他等級測試，更像高考英語。</p>
<p>閲讀比較正常，但是體量占比沒特別大。</p>
<p>選詞題(就那個4選1)考察的是詞匯搭配，建議查cambridge dictionary。</p>
<p>填空題比較搞，這裏得注意基本上不寫實詞，也就是說沒指望你看全文，只要你讓他通順就行，就看看前後巨型和特殊單詞，想想填which, more, than, since, after這樣的。</p>
<p>還有理解題，比較繞，建議排除法，不然一個選項看久了就容易繞進去。記得要的是本意不是表面縮寫。</p>
<p>最後强調一下前面別連錯，不然像我一樣直接掉進低分檔。</p>
<h2 id="特殊服務"><a href="#特殊服務" class="headerlink" title="特殊服務"></a>特殊服務</h2><p>可提供題目*2 :-)</p>
<p>非售賣，僅作考後討論</p>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>done</tag>
        <tag>Linguaskill</tag>
        <tag>exam</tag>
      </tags>
  </entry>
  <entry>
    <title>LucidiTEE: 基于策略的规模化公平计算（摘要）</title>
    <url>/post/luciditee/</url>
    <content><![CDATA[<p>这个是LucidiTEE的paper的intro部分，因为知乎上有人问起所以就边看边了解边回答。这个和区块链不是一个东西，是对于硬件层面的计算可信度的保障，像我的AMD1600也有这样的可信计算功能。</p>
<p>受大肆滥用个人信息的现状启发，我们通过将信息绑定在策略上，允许用户去控制他们个人信息的分享与使用，即便是在离线的时候。一个策略制定了一个被允许的函数，策略包含了防止对输入提供者与输出接收人的执行（基于有关该数据的所有先前计算的历史记录）和识别。为了达到这个级别的控制，我们的目标是建立一个能够确保策略与输入提供者保持一致，对输出接收方的公平和公正（即，所有一方或没有一方获取输出），而无需这些方彼此信任或与计算主机信任的计算系统。</p>
<span id="more"></span>

<p>最近，受信任的执行环境（TEE），例如英特尔SGX和Sanctum enclaves，正在敏感数据的外包计算中找到应用程序。 但是，由于TEE受到不受信任的主机托管用于存储和网络通信，因此它们无法执行依赖历史的策略或公平性。 例如，与用户只希望揭示其整个数据上的汇总函数的愿望相反，对抗主机可以在其数据集的不同子集上反复评估该汇总函数，并学习单个记录。 对手还可能串通并将输出仅传递给输出接收者的子集，从而违反了公平性。</p>
<p>本文介绍了LucidiTEE，这是第一个使多方可以联合计算大规模私有数据的系统，同时确保即使输入提供者处于脱机状态也可以强制执行上述策略，并保证对所有输出接收者的公平性。 为此，LucidiTEE在TEE网络和共享的仅限追加的分类帐之间开发了一套新颖的协议。LucidiTEE仅使用分类帐执行策略； 它不会在账本上存储输入，输出或状态，也不会在参与者之间重复执行，这使其可以扩展到大数据和大量参与者。</p>
<p>我们演示了几种基于策略的应用程序，包括个人理财，联合机器学习，公平N方信息交换和医疗记录中私有集之间的交集。</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>TEE</tag>
        <tag>paper</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊中的Merkle树 (Merkling in Ethereum)</title>
    <url>/post/merkling-in-ethereum/</url>
    <content><![CDATA[<p>Merkle树是使区块链运作的基础部分。尽管从理论上讲绝对可以制造没有Merkle树的区块链，但仅通过创建直接包含每个交易的巨型区块头就可以了，这样做带来了巨大的可扩展性挑战，可以说使得除了最大多数以外的所有人都无法信任地使用区块链的能力。从长远来看功能强大的计算机。多亏了Merkle树，才有可能构建以太坊节点，该节点可以在所有大小型笔记本电脑，智能手机甚至物联网设备（如Slock.it生产的设备）上运行。那么，无论现在还是将来，这些Merkle树如何精确发挥作用，并提供什么价值？</p>
<span id="more"></span>

<p>首先是基础知识。从最一般的意义上来说，Merkle树是一种将大量“块状”数据hash在一起的方法，该方法依赖于将块拆分为多个存储桶，其中每个存储桶仅包含几个存储块，然后获取每个存储桶的hash并重复相同的过程，继续这样做，直到剩余的hash总数变为一个：根hash。</p>
<p>Merkle树最常见，最简单的形式是二叉Merkle树，其中一个存储桶始终由两个相邻的块或hash组成。它可以描述如下：</p>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/merkle.png" loading="lazy"></p>
<p>那么，这种奇怪的hash算法有什么好处呢？为什么不将所有块连接在一起成为一个大块，并在其上使用常规的hash算法呢？答案是，它允许使用称为Merkle证明的简洁机制：</p>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/merkle2.png" loading="lazy"></p>
<p>Merkle证明由块，树的根hash和“分支”组成，其中“分支”由沿从块到根的路径上的所有hash组成。读取证明的人可以验证，至少对于该分支而言，hash在整个树上一直是一致的，因此，给定的块实际上位于树中的该位置。该应用程序很简单：假设有一个大型数据库，并且数据库的全部内容存储在Merkle树中，该树的根是公开已知且受信任的（例如，它已由足够的受信方进行数字签名） ，或者有很多工作证明）。然后，想要在数据库上进行键值查找的用户（例如“告诉我位置85273中的对象”）可以请求Merkle证明，并在收到证明后验证它是正确的，因此实际接收到的值在数据库中具有该特定根的位置85273处。它允许对少量数据（例如hash）进行身份验证的机制得以扩展，以对可能无限制大小的大型数据库进行身份验证。</p>
<h2 id="比特币中的Merkle证明"><a href="#比特币中的Merkle证明" class="headerlink" title="比特币中的Merkle证明"></a>比特币中的Merkle证明</h2><p>Merkle证明的原始应用是在比特币中，正如中本聪（Satoshi Nakamoto）在2009年描述和创建的那样。比特币区块链使用Merkle证明来将交易存储在每个区块中：</p>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/mining.jpg" loading="lazy"></p>
<p>这提供的好处是Satoshi将其描述为“简化的付款验证”的概念：“轻量级客户端”只下载块头链，每个块80字节的数据块，而不是下载每个交易和每个块，只包含五件事：</p>
<ul>
<li>前一个区块头的hash</li>
<li>时间戳</li>
<li>挖掘难度值</li>
<li>工作证明随机数</li>
<li>Merkle树的根hash，包含该块的交易事务</li>
</ul>
<p>如果轻量级客户想要确定交易的状态，则可以简单地索要Merkle证明，以证明特定交易在Merkle树之一中，其根在主链的块头中。</p>
<p>这使我们走得很远，但是比特币风格的轻客户端确实有其局限性。一个特别的限制是，尽管它们可以证明包括交易，但它们不能证明有关当前状态的任何信息（例如，数字资产持有，名称注册，金融合同的状态等）。您现在有多少个比特币？比特币轻量级客户端可以使用一种协议，该协议涉及查询多个节点并相信至少其中一个会从您的地址通知您任何特定的交易支出，这将使您在该用例中走得更远，但对于其他更复杂的应用程序这还远远不够；交易影响的确切性质可能取决于几个先前交易的影响，而这些交易本身也取决于先前交易，因此最终您将必须对整个链中的每个交易进行身份验证。为了解决这个问题，以太坊将Merkle树概念更进一步。</p>
<h2 id="以太坊的Merkle证明"><a href="#以太坊的Merkle证明" class="headerlink" title="以太坊的Merkle证明"></a>以太坊的Merkle证明</h2><p>以太坊中的每个块头不仅包含一棵Merkle树，还包含用于三种对象的三棵树​​：</p>
<ul>
<li>交易次数</li>
<li>收据（基本上是显示每笔交易效果的数据）</li>
<li>状态</li>
</ul>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/ethblockchain_full.png" loading="lazy"></p>
<p>这允许高度高级的轻客户端协议，该协议允许轻客户端轻松地对多种查询做出并获得可验证的答案：</p>
<ul>
<li>该交易是否包含在特定的区块中？</li>
<li>告诉我该地址在过去30天内引发的所有X类型事件（例如达成目标的众筹合同）的所有实例</li>
<li>我帐户的当前余额是多少？</li>
<li>这个帐户存在吗？</li>
<li>假设在此合同上运行此事务。输出是什么？</li>
</ul>
<p>第一个由事务树处理；第二个由事务树处理。第三个和第四个由状态树处理，第二个由接收树处理。前四个很容易计算。服务器简单地找到对象，获取Merkle分支（从对象到树根的hash列表），然后使用该分支答复轻客户端。</p>
<p>第五个也由状态树处理，但是计算它的方式更加复杂。在这里，我们需要构造所谓的Merkle状态转换证明。本质上，这是一个证明：“如果在具有根S的状态上运行事务T，结果将是具有根S’的状态，且具有日志L和输出O”（“输出”作为概念存在于以太坊，因为每个事务都是一个函数调用；从理论上讲不是必需的）。</p>
<p>为了计算证明，服务器在本地创建一个假块，将状态设置为S，并在应用事务时假装为轻客户端。即，如果进行交易的过程要求客户确定账户余额，则轻客进行余额查询。如果轻客户端需要检查特定合同存储中的特定项目，则轻客户端对此进行查询，依此类推。服务器正确地“响应”其自己的所有查询，但跟踪其发送回的所有数据。然后，服务器将所有这些请求的组合数据发送给客户端，以作为证明。然后，客户端将执行完全相同的过程，但使用提供的证据作为其数据库；如果其结果与服务器要求的结果相同，则客户端接受该证明。</p>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/lightproof.png" loading="lazy"></p>
<h2 id="Patricia树"><a href="#Patricia树" class="headerlink" title="Patricia树"></a>Patricia树</h2><p>上面提到过，最简单的Merkle树是二元Merkle树。但是，以太坊中使用的树更加复杂-这就是您在我们的文档中听到的”Merkle Patricia树”。本文将不涉及详细规范；尽管我将讨论基本推理，但这是本文和本文中最好的方法。</p>
<p>二进制Merkle树是用于验证“列表”格式信息的非常好的数据结构。本质上是一系列的块，一个接一个。对于事务树，它们也很好，因为创建树后编辑多少时间都没有关系，因为先创建树然后再将其永久冻结。</p>
<p>但是，对于状态树，情况更为复杂。以太坊中的状态基本上由一个键值映射组成，其中的键是地址，值是帐户声明，列出每个帐户的余额，现时，代码和存储空间（存储空间本身是一棵树）。例如，Morden测试网的生成状态如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;0000000000000000000000000000000000000001&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;0000000000000000000000000000000000000002&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;0000000000000000000000000000000000000003&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;0000000000000000000000000000000000000004&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;1606938044258990275541962092341162602522202993782792835301376&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，与交易历史记录不同，状态需要经常更新：帐户的余额和现时经常更改，此外，经常插入新帐户，并且经常插入和删除存储密钥。因此，需要一种数据结构，在该数据结构中，我们可以在执行插入，更新编辑或删除操作后快速计算新的树根，而无需重新计算整个树。还有两个非常理想的辅助属性：</p>
<ul>
<li>即使攻击者故意设计事务以使树尽可能深，它的深度也是有界的。否则，攻击者可以通过将树处理得如此之深以至于每个单独的更新变得极其缓慢，从而执行拒绝服务攻击。</li>
<li>树的根仅取决于数据，而不取决于更新的顺序。以不同的顺序进行更新，甚至从头开始重新计算树都不应更改根。</li>
</ul>
<p>简单来说，Patricia树可能是我们可以同时实现所有这些特性的最接近的树。关于其工作原理的最简单解释是，将存储值的键编码为您必须取下该树的“路径”。每个节点有16个子节点，因此路径是通过十六进制编码确定的：例如，十六进制编码的密钥狗是6 4 6 15 6 7，因此您将从根开始，沿着第6个子节点向下，然后是第4个，依此类推，直到到达终点为止。 在实践中，当树稀疏时，我们可以进行一些额外的优化以使过程效率更高，但这是基本原理。 上面提到的两篇文章更详细地描述了所有功能。</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>blockchain</tag>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Multi-Address Wallet Design: 多地址钱包设计</title>
    <url>/post/multi-addr-wallet-design/</url>
    <content><![CDATA[<p>因为导出的hex比较ugly，因此是想要为ngwallet钱包定制一个助记词方案。本来构思的是直接通过密钥生成助记词，但是在寻找wordlist的时候仔细看了一下bitcoin的助记词方案，发现hd钱包（Hierachical Deterministic Wallets）这套密钥管理非常有趣且实用。既然在专心做钱包了那就顺带学习借鉴。</p>
<span id="more"></span>

<h2 id="BIP32"><a href="#BIP32" class="headerlink" title="BIP32"></a>BIP32</h2><h3 id="Key-derivation-派生密钥"><a href="#Key-derivation-派生密钥" class="headerlink" title="Key derivation: 派生密钥"></a>Key derivation: 派生密钥</h3><p>我们将使用比特币中公钥加密曲线，即<a href="http://www.secg.org/sec2-v2.pdf" target="_blank" rel="noopener">secp256k1</a>定义的字段和曲线参数的椭圆曲线密码术。有关secp256k1的细节这里不做展开。</p>
<h4 id="Extended-keys-拓展密钥"><a href="#Extended-keys-拓展密钥" class="headerlink" title="Extended keys: 拓展密钥"></a>Extended keys: 拓展密钥</h4><p>在下面的内容中，我们将定义一个由父密钥派生许多子密钥的函数。 为了防止它们仅依赖于密钥本身，我们首先使用额外的256位”熵”(entropy)来扩展私有密钥和公共密钥。此扩展称为链码chain code，对于相应的私钥和公钥是相同的，并且由32个字节组成。</p>
<p>我们将扩展私钥表示为(k, c)，其中k为普通私钥，而c为链码。 扩展的公钥表示为(K, c)，其中<code>K = point(k)</code>，c为链码。</p>
<p>每个扩展密钥都有$2^{31}$个普通子密钥和$2^{31}$个强化子密钥。 这些子密钥中的每一个都有一个索引index。普通子键使用从0到$2^{31}-1$的index。加固的子密钥使用索引$2^{31}$到$2^{32} -1 $。 为了简化强化子密钥index的表示，用$i_H$表示$i + 2^{31}$。</p>
<h4 id="Child-key-derivation-CKD-functions-子密钥派生函数"><a href="#Child-key-derivation-CKD-functions-子密钥派生函数" class="headerlink" title="Child key derivation (CKD) functions: 子密钥派生函数"></a>Child key derivation (CKD) functions: 子密钥派生函数</h4><p>给定父扩展密钥和index i，可以计算相应的子扩展密钥。 这样做的算法取决于子密钥是否是强化密钥（或，等效地，i是否大于等于$2^{31}$），以及我们是在谈论私钥还是公钥。</p>
<h5 id="父私钥-rarr-子私钥"><a href="#父私钥-rarr-子私钥" class="headerlink" title="父私钥 &rarr; 子私钥"></a>父私钥 &rarr; 子私钥</h5><p>函数CKDpriv((k<sub>par</sub>, c<sub>par</sub>), i) &rarr; (k<sub>i</sub>, c<sub>i</sub>)从父扩展私钥计算子扩展私钥</p>
<ul>
<li><p>Check whether i ≥ 2<sup>31</sup> (whether the child is a hardened key).</p>
<ul>
<li>If so (hardened child): let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = 0x00 || ser<sub>256</sub>(k<sub>par</sub>) || ser<sub>32</sub>(i)). (Note: The 0x00 pads the private key to make it 33 bytes long.)</li>
<li>If not (normal child): let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>P</sub>(point(k<sub>par</sub>)) || ser<sub>32</sub>(i)).</li>
</ul>
</li>
<li><p>Split I into two 32-byte sequences, I<sub>L</sub> and I<sub>R</sub>.</p>
</li>
<li><p>The returned child key k<sub>i</sub> is parse<sub>256</sub>(I<sub>L</sub>) + k<sub>par</sub> (mod n).</p>
</li>
<li><p>The returned chain code c<sub>i</sub> is I<sub>R</sub>.</p>
</li>
<li><p>In case parse<sub>256</sub>(I<sub>L</sub>) ≥ n or k<sub>i</sub> = 0, the resulting key is invalid, and one should proceed with the next value for i. (Note: this has probability lower than 1 in 2<sup>127</sup>.)</p>
</li>
</ul>
<h5 id="父私钥-rarr-子公钥"><a href="#父私钥-rarr-子公钥" class="headerlink" title="父私钥 &rarr; 子公钥"></a>父私钥 &rarr; 子公钥</h5><p>函数N((k, c)) &rarr; (K, c) 从父扩展公钥计算子扩展公钥。 仅针对未加固的子键定义</p>
<ul>
<li>返回的密钥K为point(k)。</li>
<li>返回的链码c只是传递的链码。</li>
</ul>
<p>要计算父私钥的子公钥:</p>
<ul>
<li>N(CKDpriv((k<sub>par</sub>, c <sub>par</sub>), i))（始终有效）。</li>
<li>CKDpub(N(k<sub>par</sub>, c <sub>par</sub>), i)（仅适用于非强化的子密钥）。</li>
</ul>
<p>两者等效，使得非强化的密钥变得有用（一个人可以在不知道任何私钥的情况下派生出给定父密钥的子公钥），也使它们与强化密钥有所区别。 不一直使用非强化密钥（尽管更有用）的原因是安全性考量。</p>
<h5 id="父公钥-rarr-子公钥"><a href="#父公钥-rarr-子公钥" class="headerlink" title="父公钥 &rarr; 子公钥"></a>父公钥 &rarr; 子公钥</h5><p>函数 CKDpub((K<sub>par</sub>, c<sub>par</sub>), i) &rarr; (K<sub>i</sub>, c<sub>i</sub>) 从父扩展公钥计算子扩展公钥。它仅针对未强化的子密钥。</p>
<ul>
<li>检查是否 i ≥ 2<sup>31</sup> (即，是否子密钥为强化密钥).</li>
<li>如果是强化密钥，返回失败</li>
<li> 如果是普通密钥: 设置 I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>P</sub>(K<sub>par</sub>) || ser<sub>32</sub>(i)).</li>
<li>把I 分割成两个32-byte 序列, I<sub>L</sub> 和 I<sub>R</sub>.</li>
<li>返回的子密钥 K<sub>i</sub> 即为point(parse<sub>256</sub>(I<sub>L</sub>)) + K<sub>par</sub>.</li>
<li>返回的链码 c<sub>i</sub> 为 I<sub>R</sub>.</li>
<li>如果 parse<sub>256</sub>(I<sub>L</sub>) ≥ n 或 K<sub>i</sub> 是在无限上的点, 那么得到的密钥无效, 且需要继续处理i的下一个值.</li>
</ul>
<h5 id="父公钥-rarr-子私钥"><a href="#父公钥-rarr-子私钥" class="headerlink" title="父公钥 &rarr; 子私钥"></a>父公钥 &rarr; 子私钥</h5><p>不可能</p>
<h3 id="The-key-tree-密钥树"><a href="#The-key-tree-密钥树" class="headerlink" title="The key tree: 密钥树"></a>The key tree: 密钥树</h3><p>下一步则是串联数个CKD 结构来构造一个树形结构。我们从一个根节点，即主拓展密钥m开始。通过执行多个i值对应的CKDpriv(m,i) , 我们得到一系列level-1的派生节点。由于它们每个都是扩展密钥，因此CKDpriv也可以应用于这些扩展密钥。</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>blockchain</tag>
        <tag>wallet</tag>
      </tags>
  </entry>
  <entry>
    <title>NGIN的新架構</title>
    <url>/post/new-structure-of-ngin/</url>
    <content><![CDATA[<p>重構一時爽……</p>
<span id="more"></span>

<h2 id="權限更大的Consensus"><a href="#權限更大的Consensus" class="headerlink" title="權限更大的Consensus"></a>權限更大的Consensus</h2><p>之前的Consensus是管不到p2p的，因此初始化，同步，廣播這些都是由p2p模塊根據網絡場景來觸發，然後調用内置的Consensus來對區塊和狀態進行修改。</p>
<p>根據新的架構，Consensus將接管P2P的所有功能的主動觸發。</p>
<p>針對Wired協議中response的處理，原本是通過handler處理，現在改爲直接caller func中直接對stream進行後續讀取再關閉</p>
<h2 id="更强大的Tx"><a href="#更强大的Tx" class="headerlink" title="更强大的Tx"></a>更强大的Tx</h2><p>Tx，作为事务，除了处理交易以外最重要的功能就是处理智能合约，也就是第二层架构(layer-2)。</p>
<p>和虽然同样使用账户模型，NGIN的Tx和Ethereum的Transaction有很大不同：Tx的目标不唯一。</p>
<p>这就意味着，一个账户想在同一时间（同一区块）内发送多个ethereum交易，只需要将这些的内容进行合并。</p>
<p>这有什么好处？首先这可以保证在“一账户一区块一事务”的原则下尽可能地拓展有效交易吞吐量。其次，减少Multi-Tx时不必要的参数，达到减小Block体积，提高TPS。再者，这对于WASM的模块化至关重要。</p>
<p>前面两个应该很好理解，要是没这个那么“一账户一区块一事务”只能发一个交易也太难受了，要是一个账户发一堆Transaction的话累赘的sign和address也太多了。</p>
<p>WASM这个就值得介绍了。</p>
<p>首先WASM的设计是模块化的，所有功能或者值都可以被Module包裹形成一个模块，然后AsExtern就能被其他模块import。</p>
<p>那么如果热心群众A开发了个算法库，我B想拿来用在我的应用上，按照ethereum的操作就是拿来sol再import。这样会有俩问题，首先是网络上这个库相当于就装了两回，而且B的应用（binary）内部相当于包裹了这个算法的binary，只装一个还好，装多了就大的一批。</p>
<p>在WASM里，部署的是Module形式的WASM，只需要import就可以直接使用。这时候就是Tx出场的时候了，想要在Transaction里导入其他账户contract里的module，只需要把他们的owner写到participants里就可以。当然你要是觉得他们的库很赞，你可以写点value在vaules里给他们点赞助:-)</p>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>todo</tag>
        <tag>NGIN</tag>
      </tags>
  </entry>
  <entry>
    <title>市场上新一代公链研究</title>
    <url>/post/public-blockchain-research-report/</url>
    <content><![CDATA[<p>原本应该是edX上BerkeleyX CS198.2x: Blockchain Technology的Homework3，这里干脆就对所有知名的链做点分析。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>为了准备最终作业，本周的任务是对您选择的特定区块链进行研究，并将其发到在论坛。<br>您可以将此作业作为最终作业的头脑风暴会议。<br>重点是综合在材料的最后几周中学到的概念，主要是关于可伸缩性，安全性和去中心化的主题，并将这种理解应用于我们可能在课堂上未曾详细介绍过的各种区块链（或完全没介绍过的）。</p>
<p>请在下面的论坛中进行协作。<br>如果其他人写了关于您选择的区块链平台的文章，请添加到他们的帖子中，而不是您自己再建立个。<br>我们正在为每位经过深思熟虑的讨论贡献的人寻找大约1-2个段落。<br>请在您的帖子中引用您的消息来源。<br>也请在下面的文本框中粘贴您贡献的内容。<br>我们将对您提交的文本以及您参与讨论的内容进行评分。</p>
<p>以下是一些您可以编写的详细子话题，然后是一些更详细的提交规范。</p>
<h3 id="动机和用例-市场"><a href="#动机和用例-市场" class="headerlink" title="动机和用例/市场"></a>动机和用例/市场</h3><p>如果您的平台是面向用例的：它解决什么现实问题？您是否正在建立供应链平台？您的货币适合物联网等特定细分市场吗？</p>
<p>如果您的平台是基础架构：（例如，以太坊允许开发人员在公共系统中轻松编写和部署智能合约）这可以解决加密/区块链行业中的哪些常见问题？其他人如何利用您的平台做更大的事情？</p>
<h3 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h3><p>为什么采用这种共识算法？它的优点和缺点是什么？</p>
<p>例如，在许可的分类帐中使用PBFT效率更高，因为它不需要挖掘，并且在半信任的环境中效果很好。</p>
<h3 id="独特的功能"><a href="#独特的功能" class="headerlink" title="独特的功能"></a>独特的功能</h3><p>谈论您的加密货币或平台的一些很酷的方面。它具有增强的隐私性吗？它是否支持阈值签名？它是模块化的，因此特别适合企业集成吗？它使用zk-SNARK还是zk-STARK？是侧链吗？</p>
<h3 id="潜在漏洞和博弈论攻击"><a href="#潜在漏洞和博弈论攻击" class="headerlink" title="潜在漏洞和博弈论攻击"></a>潜在漏洞和博弈论攻击</h3><p>例如，如果您的区块链使用权益证明，您可能会遇到什么问题？您的系统是否完全不信任？如果不是，请详细说明一些担忧和权衡。您的平台有游戏理论问题吗？<br>可伸缩性注意事项</p>
<p>例如，如果它是由几家银行共享的私有链，那么在区块链上存储大量数据就不是那么重要了。您的区块链是否允许状态通道？它实现分片吗？它允许侧链吗？可以被群众合理使用吗？<br>规</p>
<p>是否存在KYC / AML问题？对像您这样的区块链当前的监管观点是什么？</p>
<h3 id="规格："><a href="#规格：" class="headerlink" title="规格："></a>规格：</h3><ul>
<li>它不能使用工作量证明。在课程中，我们对PoW进行了很多分析，您应该尝试将类似的分析应用于其他平台和加密货币。</li>
<li>同上，它不能是比特币或以太坊。</li>
<li>确保引用您的消息来源。</li>
<li>在讨论区中应该大致为1-2个段落。您可以自由编写更多内容，但主要内容应为1-2个段落。</li>
</ul>
<p>卡住？这里有一些建议：</p>
<ul>
<li>Hyperledger</li>
<li>Rootstock（ps: 中文意思是砧木）（这是工作量证明里的例外，因为它使用合并挖掘）</li>
<li>Interledger</li>
<li>Stellar</li>
<li>Cosmos</li>
<li>Polkadot（ps: 中文意思是波尔卡圆点）</li>
<li>Monax</li>
<li>Tezos</li>
</ul>
<h2 id="Hyperledger"><a href="#Hyperledger" class="headerlink" title="Hyperledger"></a>Hyperledger</h2><h3 id="什么是Hyperledger？"><a href="#什么是Hyperledger？" class="headerlink" title="什么是Hyperledger？"></a>什么是Hyperledger？</h3><p>Hyperledger是一个开源<strong>社区</strong>，致力于为企业级区块链部署开发一套稳定的框架，工具和库。</p>
<p>它是各种分布式分类帐框架（包括Hyperledger Fabric，Sawtooth，Indy）以及Hyperledger Caliper之类的工具以及Hyperledger Ursa之类的库的中立场所。[1]</p>
<p>换句话说，Hyperledger（或Hyperledger项目）是开放源代码区块链及相关工具的总体项目，由Linux基金会于2015年12月启动，已获得IBM，Intel和SAP Ariba的捐款，以支持协作开发基于区块链的分布式账簿。[2]</p>
<p>去掉孵化中和停止维护的项目，由Hyperledger直接负责的项目有如下几个[3]：</p>
<ul>
<li>Hyperledger Besu：以太坊客户端，在以太坊公共网络、专用网络和测试网络（如Rinkeby，Ropsten和Görli）上运行。</li>
<li>Hyperledger Fabric：Go写的分布式账簿。（基本上说Hyperledger就是在指它）</li>
<li>Hyperledger Indy：专为去中心化身份而构建的分布式账簿</li>
<li>Hyperledger Iroha：C++写的分布式账簿</li>
<li>Hyperledger Sawtooth：具有多语言支持的分布式账簿</li>
</ul>
<p>[1]来源：<a href="https://www.hyperledger.org/" target="_blank" rel="noopener">https://www.hyperledger.org/</a><br>[2]来源：<a href="https://en.wikipedia.org/wiki/Hyperledger" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hyperledger</a><br>[3]来源：<a href="https://wiki.hyperledger.org/" target="_blank" rel="noopener">https://wiki.hyperledger.org/</a></p>
<h3 id="动机和用例-市场-1"><a href="#动机和用例-市场-1" class="headerlink" title="动机和用例/市场"></a>动机和用例/市场</h3><p>Hyperledger项目的目的是通过开发区块链和分布式账本来促进跨行业的协作，特别着重于提高这些系统的性能和可靠性（与可比的加密货币设计相比），以便它们能够支持全球业务交易 由主要的技术，金融和供应链公司提供。</p>
<p>项目将通过针对特定用途模块的框架集成独立的开放协议和标准，包括具有自己的共识和存储例程的区块链，以及用于身份，访问控制和智能合约的服务。<br>早期有人对Hyperledger会开发自己的比特币类型的加密货币感到困惑，但Behlendorf毫无保留地表示Hyperledger Project本身将永远不会构建自己的加密货币。[1]</p>
<p>[1]来源：<a href="https://en.wikipedia.org/wiki/Hyperledger" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hyperledger</a></p>
<h3 id="共识机制-1"><a href="#共识机制-1" class="headerlink" title="共识机制"></a>共识机制</h3><p>因为项目涉及多个区块链子项目，所以用表格讨论</p>
<table>
<thead>
<tr>
<th>子项目</th>
<th>共识</th>
</tr>
</thead>
<tbody><tr>
<td>Besu</td>
<td>PoW or PoAuthority [1]</td>
</tr>
<tr>
<td>Fabric</td>
<td>CFT（基于raft）[2]</td>
</tr>
<tr>
<td>Indy</td>
<td>RBFT[3]</td>
</tr>
<tr>
<td>Iroha</td>
<td>YAC（另一种CFT）[4]</td>
</tr>
<tr>
<td>Sawtooth</td>
<td>Dynamic Consensus（包括PBFT，Proof of Elapsed Time，Raft，Devmode） [5]</td>
</tr>
</tbody></table>
<p>[1]<a href="https://besu.hyperledger.org/en/stable/Concepts/Consensus-Protocols/Overview-Consensus/" target="_blank" rel="noopener">https://besu.hyperledger.org/en/stable/Concepts/Consensus-Protocols/Overview-Consensus/</a><br>[2]<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/whatis.html#pluggable-consensus" target="_blank" rel="noopener">https://hyperledger-fabric.readthedocs.io/en/release-2.2/whatis.html#pluggable-consensus</a><br>[3]<a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiYgs_vzYTsAhX4yIsBHbPyBz4QFjACegQIAhAB&amp;url=https://wiki.hyperledger.org/download/attachments/20024919/Understanding%2520Hyperledger%2520Indy%2520Ledger.pdf?version=1&modificationDate=1571126012000&api=v2&amp;usg=AOvVaw3qDagJGg5Xapx9Dh5ANQxD" target="_blank" rel="noopener">https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiYgs_vzYTsAhX4yIsBHbPyBz4QFjACegQIAhAB&amp;url=https%3A%2F%2Fwiki.hyperledger.org%2Fdownload%2Fattachments%2F20024919%2FUnderstanding%2520Hyperledger%2520Indy%2520Ledger.pdf%3Fversion%3D1%26modificationDate%3D1571126012000%26api%3Dv2&amp;usg=AOvVaw3qDagJGg5Xapx9Dh5ANQxD</a><br>[4]<a href="https://iroha.readthedocs.io/en/master/overview.html" target="_blank" rel="noopener">https://iroha.readthedocs.io/en/master/overview.html</a><br>[5]<a href="https://sawtooth.hyperledger.org/docs/core/releases/latest/introduction.html" target="_blank" rel="noopener">https://sawtooth.hyperledger.org/docs/core/releases/latest/introduction.html</a></p>
<p>优点与缺点</p>
<h3 id="规格（技术细节）"><a href="#规格（技术细节）" class="headerlink" title="规格（技术细节）"></a>规格（技术细节）</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <tags>
        <tag>todo</tag>
        <tag>blockchain</tag>
        <tag>edx</tag>
      </tags>
  </entry>
  <entry>
    <title>regenerate cgo definitions: vscode里gopls对cgo的新支持</title>
    <url>/post/regenerate-cgo-definitions/</url>
    <content><![CDATA[<p>因为之前都是让IDE/VScode(goreturns)自动处理的import，所以今天在用vscode重新format的时候才看到，在<code>import &quot;C&quot;</code>的上面有个可以点的<code>regenerate cgo definitions</code>按钮。</p>
<p>这里就根据这个<a href="https://github.com/golang/go/issues/35721" target="_blank" rel="noopener">github issue</a>来阐述一下这个按钮是干啥的，该怎么用。答案是根据<a href="https://www.reddit.com/r/vscode/comments/hjphbz/what_is_the_purpose_of_regenerate_cgo_definitions/" target="_blank" rel="noopener">reddit上这个帖子的回复</a>找到的</p>
<span id="more"></span>

<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>使用了<code>import &quot;C&quot;</code>的源代码文件不是真正有效的Go。它们在严重依赖于go tool在构建软件包时所产生的额外信息。尽管可以通过设置<a href="https://golang.org/pkg/go/types/#Config" target="_blank" rel="noopener">types.Config.FakeImportC flag</a>来解决这些问题，可以对它们进行解析，但不能进行类型检查。</p>
<p>许多人建议gopls使用包中的GoFiles而不是其CompiledGoFiles。<br>GoFiles是原始的（即无效的）文件。使用它们可能会给编辑包的人带来更好的体验，但是由于包将不再进行类型检查，因此它将完全破坏依赖于类型信息的所有内容。在当前架构中进行更改之前，我们必须非常仔细地评估效果。</p>
<p>我们可以考虑两次检查cgo软件包的类型，一次使用实际代码，一次使用用户的代码。那将会是一个重大的架构变化。</p>
<p>或者，我们可以在<code>.go</code>文件更改时运行cgo工具，以生成实际代码。这是一种更加可靠的方法，但是运行cgo处理的成本可能太高，尤其是在大型的包上。</p>
<p>无论如何，这是一个大项目，需要大量的测试和思考。我们不太可能很快在这里做出巨大的改进。</p>
<h2 id="Beta测试指令"><a href="#Beta测试指令" class="headerlink" title="Beta测试指令"></a>Beta测试指令</h2><p>这是当前的状态：如果您使用tip Go（即gotip安装的golang, gotip是从开发分支上编译并运行go的命令）在master分支上构建gopls，那么您应该具有很好的cgo创作经验。<br>据我所知有一个bug在自动代码补全上，它会提供_cgo_foo之类的符号，而不是正确的C.foo。</p>
<p>不过，有一个障碍是，除非您告知，否则它不会重新生成cgo绑定。<br>为此，在使用cgo的文件中，在<code>import &quot;C&quot;</code>行的顶部应该有一个<code>regenerate cgo</code>的按钮。<br>当您引用C中的新标识符时，或使用影响Go可以看到的符号的方式更改魔术注释时，将需要使用它。</p>
<p>要进行设置，请按照以下说明进行操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go get golang.org&#x2F;dl&#x2F;gotip</span><br><span class="line">$ gotip download # 安装开发版golang</span><br><span class="line">[...]</span><br><span class="line">Success. You may now run &#39;gotip&#39;!</span><br><span class="line">$ cd &#x2F;</span><br><span class="line">$ GO111MODULE&#x3D;on gotip get golang.org&#x2F;x&#x2F;tools&#x2F;gopls@master</span><br><span class="line">$ gotip version</span><br><span class="line">... devel +f7f9c8f ...</span><br><span class="line">$ gotip version $(which gopls)</span><br><span class="line">... devel +f7f9c8f ...</span><br></pre></td></tr></table></figure>

<p>您无需使用tip Go即可在自己的项目上工作，仅需用其构建gopls。（这是2020.05.01的更新，现在2020.10.24估计是不用了）</p>
<h2 id="说人话"><a href="#说人话" class="headerlink" title="说人话"></a>说人话</h2><p>就是，go自己读不懂cgo，要靠别的工具。但是别的工具一直调用会很浪费资源，那就让大家通过按钮手动让go通过工具读cgo。</p>
<p>但是看起来bug还是挺多的，所以issue也没close</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>vscode</tag>
        <tag>cgo</tag>
        <tag>gopls</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>消息的签名与验证 —— 证明BTC地址的所有权</title>
    <url>/post/sign-and-verify-messages/</url>
    <content><![CDATA[<p>译：众所周知，本人现在正在开发一个新型的区块链架构NGIN。最近看到Schnorr签名算法很热门就在NG上部署了。但是部署完之后就陷入了更深层的思考——如何更好的利用Schnorr的MultiSig（多重签名）机制？现在我构思将Account也转为利用Schnorr来判定所有权。但是发现如此设计的话Account结构中不包含PublicKey，将很难通过anonymous表来搜索账户余额。故希望从本文中获得启发。</p>
<p><a href="https://bitcointalk.org/index.php?topic=4382780.0" target="_blank" rel="noopener">原文地址</a></p>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>许多人在问，如何证明或声明属于某个公共地址的比特币的所有权？</p>
<p>假设，您叫A，并且想与B做生意。B告诉你，他的公开地址是19Ho6eA4hBtb7hkN1S6GdmHD611Egd7gtC，而他在2015年10月15日余额恰好是2.04531538BTC。通过怎样，B可以毫无疑问地证明他确实拥有这个地址，让A能绝对信任？</p>
<p>在这个简短的教程中，我们将向您展示如何使用我们最喜欢的钱包Electrum完成所有这些工作。您根本不需要任何编程技能，但是您应该熟悉私钥和公钥的概念，并且至少应牢记不要与任何人共享私钥或以任何形式在线发送私钥的重要性。</p>
<p>其中的所有私钥和公钥都是出于教育目的，切勿使用——否则余额将立马被抢走。</p>
<h2 id="区块链还不够-——-屏幕截图还不够"><a href="#区块链还不够-——-屏幕截图还不够" class="headerlink" title="区块链还不够 —— 屏幕截图还不够"></a>区块链还不够 —— 屏幕截图还不够</h2><p>B向A发送了<a href="https://blockchain.info/address/19Ho6eA4hBtb7hkN1S6GdmHD611Egd7gtC" target="_blank" rel="noopener">这个交易</a>到区块链。</p>
<p>当然，那里有公共地址，金额和日期。但是不久，A意识到A可以选择区块链上的任何随机地址，并将其作为“证明”发送给她。</p>
<p>A请B提供更好的证据，然后B用他的钱包的两个屏幕截图回复：</p>
<p>（图略，建议都用ascii图，不然图床真不靠谱）</p>
<p>好吧，所以看起来B好像在说实话。但是！图像很容易被操纵。B可以使用Photoshop来创建这些图像。</p>
<p>因此，A仍然没有被说服，A也不可能被这样说服。A需要确切的证据。最好的部分是A可以拥有的！</p>
<h2 id="消息的签名与验证-——-完美的证明"><a href="#消息的签名与验证-——-完美的证明" class="headerlink" title="消息的签名与验证 —— 完美的证明"></a>消息的签名与验证 —— 完美的证明</h2><p>比特币地址由一个私钥（您应该始终保持私有）和一个公钥组成，该公钥与您的公网地址相同。这是最重要的部分：密钥对可用于对消息进行签名。甚至不涉及区块链。</p>
<p>如果B真正拥有他声称的公共地址，那么他也拥有其私钥。它可以用来签名消息。</p>
<p>在这个例子中，B确实拥有他声称的比特币地址。具体来说，他的证据是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Private key: 5KSFWJRuCuTFFsPQgokmLuKbY84f8e9pcWaJX2C7r8jsLi2RuJF</span><br><span class="line">Public key: 19Ho6eA4hBtb7hkN1S6GdmHD611Egd7gtC</span><br></pre></td></tr></table></figure>

<p>A现在意识到，如果B是诚实的，他可以访问他的密钥对，从而能够为珍妮签名消息。</p>
<p>现在，A要求B使用他的密钥对签署特定的消息。简希望约翰用他的公钥（即他的比特币地址）来签署“我拥有这个地址，A！”这个消息。</p>
<p>这可以在Electrum中快速完成。 John只是将他的私钥导入一个新的钱包，选择“工具/签名/验证”消息，然后…钱包吐出以下代码…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I own this address, Jane!</span><br><span class="line"></span><br><span class="line">19Ho6eA4hBtb7hkN1S6GdmHD611Egd7gtC</span><br><span class="line"></span><br><span class="line">GxHVqiSW+WxEA+IlNB5oqDpzLba7MJxYJl5Gr3ijm1SQYb9xEukrvnoXPbfi1k+wa54k0F&#x2F;0tQ0hdsEjw1paa5w&#x3D;</span><br></pre></td></tr></table></figure>

<p>…他寄给A。特别要注意的是，如果没有他的私钥，他将无法签署此消息。更重要的是，A从未将自己的私钥发送给简。</p>
<p>A现在可以在自己的计算机上使用Electrum。A完全不需要导入任何特定的钱包详细信息，现在可以使用相同的功能并粘贴自己的EXACT消息，B的比特币地址，签名的代码，然后按“验证”。 她得到…（图略，反正就是ok了）</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>任务完成！A现在可以100％确信B拥有他声称拥有的地址。B毫无疑问地证明了他控制着他所说的比特币地址。</p>
<p><strong>如果您正在考虑与不确定的人打交道，只需要求他们为您签名。这真的很容易，它使整个加密生态系统变得更加安全和可信。双赢！</strong></p>
<h2 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h2><p>妈的感觉白翻译了等于啥也没讲。都是超基础的……</p>
<p>也不知道哪里能找到，干脆就自己写吧。</p>
<p>就是说，BTC的地址是个公钥——这句话是不那么正确的，BTC地址是个hash后的公钥。换句话说，第三方没法通过你的地址得到你的公钥。</p>
<p>之前看到一个ETH的攻击，就是通过signature之后的R和S得到ETH的account地址，然后再结合别的R，S来降低爆破privateKey的难度（原文找不到了）。</p>
<p>恢复PublicKey的如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ECDSA public key recovery from signature</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Buffer&#125;</span> <span class="variable">msgHash</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">v</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Buffer&#125;</span> <span class="variable">r</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Buffer&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Buffer&#125;</span> <span class="variable">publicKey</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">exports</span>.ecrecover = <span class="function"><span class="keyword">function</span> (<span class="params">msgHash, v, r, s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> signature = Buffer.concat([<span class="built_in">exports</span>.setLength(r, <span class="number">32</span>), <span class="built_in">exports</span>.setLength(s, <span class="number">32</span>)], <span class="number">64</span>)</span><br><span class="line">  <span class="keyword">var</span> recovery = v - <span class="number">27</span></span><br><span class="line">  <span class="keyword">if</span> (recovery !== <span class="number">0</span> &amp;&amp; recovery !== <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid signature v value&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> senderPubKey = secp256k1.recover(msgHash, signature, recovery)</span><br><span class="line">  <span class="keyword">return</span> secp256k1.publicKeyConvert(senderPubKey, <span class="literal">false</span>).slice(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而BTC的<a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address" target="_blank" rel="noopener">PK-&gt;Addr转换方式</a>又是sha256又是ripemd160能recover个鬼……</p>
<p>这我就很好奇了，没PublicKey咋鉴权？</p>
<p>本来是打算btcd里看的，不过没立即找到。后来还是搜到<a href="https://github.com/nanotube/supybot-bitcoin-marketmonitor/blob/master/GPG/local/bitcoinsig.py" target="_blank" rel="noopener">别的实现</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_message</span>(<span class="params">address, signature, message</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; See http://www.secg.org/download/aid-780/sec1-v2.pdf for the math &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> ecdsa <span class="keyword">import</span> numbertheory, ellipticcurve, util</span><br><span class="line">    curve = curve_secp256k1</span><br><span class="line">    G = generator_secp256k1</span><br><span class="line">    order = G.order()</span><br><span class="line">    <span class="comment"># extract r,s from signature</span></span><br><span class="line">    sig = base64.b64decode(signature)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sig) != <span class="number">65</span>: <span class="keyword">raise</span> BaseException(<span class="string">&quot;Wrong encoding&quot;</span>)</span><br><span class="line">    r,s = util.sigdecode_string(sig[<span class="number">1</span>:], order)</span><br><span class="line">    nV = <span class="built_in">ord</span>(sig[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> nV &lt; <span class="number">27</span> <span class="keyword">or</span> nV &gt;= <span class="number">35</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> nV &gt;= <span class="number">31</span>:</span><br><span class="line">        compressed = <span class="literal">True</span></span><br><span class="line">        nV -= <span class="number">4</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        compressed = <span class="literal">False</span></span><br><span class="line">    recid = nV - <span class="number">27</span></span><br><span class="line">    <span class="comment"># 1.1</span></span><br><span class="line">    x = r + (recid/<span class="number">2</span>) * order</span><br><span class="line">    <span class="comment"># 1.3</span></span><br><span class="line">    alpha = ( x * x * x  + curve.a() * x + curve.b() ) % curve.p()</span><br><span class="line">    beta = modular_sqrt(alpha, curve.p())</span><br><span class="line">    y = beta <span class="keyword">if</span> (beta - recid) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> curve.p() - beta</span><br><span class="line">    <span class="comment"># 1.4 the constructor checks that nR is at infinity</span></span><br><span class="line">    R = ellipticcurve.Point(curve, x, y, order)</span><br><span class="line">    <span class="comment"># 1.5 compute e from message:</span></span><br><span class="line">    h = Hash( msg_magic( message ) )</span><br><span class="line">    e = string_to_number(h)</span><br><span class="line">    minus_e = -e % order</span><br><span class="line">    <span class="comment"># 1.6 compute Q = r^-1 (sR - eG)</span></span><br><span class="line">    inv_r = numbertheory.inverse_mod(r,order)</span><br><span class="line">    Q = inv_r * ( s * R + minus_e * G )</span><br><span class="line">    public_key = ecdsa.VerifyingKey.from_public_point( Q, curve = SECP256k1 )</span><br><span class="line">    <span class="comment"># check that Q is the public key</span></span><br><span class="line">    public_key.verify_digest( sig[<span class="number">1</span>:], h, sigdecode = ecdsa.util.sigdecode_string)</span><br><span class="line">    <span class="comment"># check that we get the original signing address</span></span><br><span class="line">    addr = public_key_to_bc_address(encode_point(public_key, compressed))</span><br><span class="line">    <span class="keyword">if</span> address == addr:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#print addr</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这tm就很nb了，居然还真又是反推PublicKey的。</p>
<p>对应的是dcrd（一个btcd的fork）的<a href="https://github.com/decred/dcrd/blob/master/dcrec/secp256k1/ecdsa/signature.go#L746" target="_blank" rel="noopener">这部分</a></p>
<p>那么NGIN里的multi-own的设计就有点难了【本来还以为有什么黑科技</p>
<p>现在难点在于，用Account里增加Sign来实现了multi-own之后，怎么实现去publickey情况下的address?</p>
<p>一种办法是把balance写进Account里，这样的话anonymous表里的balance该怎么办？无Account的矿工或者买家该怎么办？</p>
<p>另一种办法是看看Schnorr能不能生成一个可以MultiSig的PublicKey。</p>
<p>还有种办法就是放弃这个特性。</p>
<p>看了下go-schnorr对聚合签名鉴权的确是用的一个新的PublicKey，索性就把这个拿来当address。也用不着放弃了。</p>
]]></content>
      <tags>
        <tag>bitcointalk</tag>
        <tag>done</tag>
        <tag>翻译</tag>
        <tag>ecdsa</tag>
        <tag>address</tag>
      </tags>
  </entry>
  <entry>
    <title>近来半年工作的思考</title>
    <url>/post/start-job/</url>
    <content><![CDATA[<p>每个半年总得总结一下人生……</p>
<span id="more"></span>

<p>最近半年多着实忙碌，尤其是在踏出校门的过程中经历了不少坎坷的经历。</p>
<p>离开校园后的工作也并不令人满意，万幸也不幸的是家里对在银行工作万分肯定，处处都给予我帮助，让本打算当野草的我感觉有点不知所措。</p>
<p>大概人生就是这么戏谑，那些想留下的女生们开不出户，而想走的我却压着手里的户希望他们慢点来。</p>
<p>好吧那我把（工作时间的）闲暇时间拿来改良工作体验吧，于是做了个DamnCLPS系统，拿来优化一下内部数据提交流程，毕竟我最烦这种明明该电脑完成却让人手动录入的事，结果ok，刚好更新系统，IMB DB2搞ERROR，搞得我向Leader推广不出去，这样一来我也没了兴致，写到一半的批量工具也算腰斩了。</p>
<p>总之工作上不尽如人意。也对吧，银行本就该是一个传统守旧的行业，我却想革新它。感觉自己比朱雀还天真了。</p>
<p>索性的是，第一个月第一个领导跑了，上个月我的第二个领导被辞了。总的来说相比那些加班到10点的苦逼来说，我也算是下班早的了。下班健身是不可能的，约会也不存在的，B站等各大网站没买会员看番都看不舒服，玩黑客现在在社会了也不敢乱来了，只能继续完成在大四钻研的Proj Ridal。</p>
<p>啊哈没错Proj Ridal就是那个repo，啥都没，dev分支也就几个没卵用的go文件。当时这个Project的目标其实就是论文里的状态区块链的完整实现，Ridal即雷达，雷达那仪表盘玩意就是扫一圈周围出现几个点，再扫一圈出现几个点这样来表示信息的，和基于状态的区块链的思想上很接近。</p>
<p>想的的确还挺不错一个完整的区块链，但是实战要死了——要完成的东西真的有点多，我也没知道几个库能直接上手的，完成得不少时间吧，可我缺的不只是<strong>产品</strong>，还有<strong>时间</strong>。时间真的就是决定机缘的，17年那时候是个屎一样的白皮书ICO都能上千万。现在呢？ICO基本上凉凉，挖矿币倒是能吸引几个挖卖提或者初始投资者。毕业前我闲的蛋疼也做了几个新币的矿池，ok大部分都是跑路的，就剩一个webchain还坚挺。有人就建议我在矿池上熊市布局，牛市割肉。但是吧，我也知道，我有个缺点——在计算机上我什么都能做。你们说该现在布局，那为什么我就该把局布在矿池而不是直接在币上？<strong>我为什么就不能靠我自己赚钱？我不稀罕依附于别人，尤其是在这说散就散的币圈。</strong></p>
<p>然后我就自己做币了╮(╯_╰)╭</p>
<hr>
<p>然后就是新的更新了。2019-06-29</p>
<p>现在是2019年年中了。在年前因为项目代码实在无力维护暂时冻结了项目，年后主动提出了辞职，之后一边找工作一边重回Coding的状态。</p>
<p>当然了，混吃等死是不存在的，主要就靠挖矿、做挖矿软件、做矿池什么的稍微赚点伙食费，当然这些内容并不是无意义的，通过写这些子项目，对于golang和基于golang的PoW架构设计比以前得心应手多了。</p>
<p>因为之前的项目被frozen所以就没什么大顾虑了，干脆从0开始，现在全力以赴构造一个我所想要的区块链，一个我认为能够成功的项目。或者说，即便它不成功，我也要让它在学界在业界拥有技术的价值。</p>
<p>下面是这半年观察市场的收获。</p>
<ul>
<li><p>很明显，很多噱头公司bin没能撑下来，具体我说谁就不指明了。在去一个所谓“区块链公司”应聘的时候，了解到很多都已经跑路了，而这家把棋牌（赌博？）作为区块链游戏开发的小公司却活得像个业界明星。我：？？？</p>
</li>
<li><p>在大环境来看，发现具有传销性质的一些“半开源”币的社会影响比我想象中更大一点。币价和算力成正比，而算力和矿工收益成正比，矿工收益和币价升值成正比。</p>
</li>
<li><p>良心矿池不好混，基本上亏本。还不如提供挖矿软件0成本。</p>
</li>
</ul>
<hr>
<p>辛苦了，2019.</p>
<p>现在是2019的最后一天。昨晚为了给go-hwloc仓库debug只睡了三小时，今天又是加了爬crunchbase和计算300ETF实时理论价格的活，感觉脑子转的有点快。</p>
<p>除了索然无味的学英语以外，这半年又做了些什么？</p>
<p>首先肯定是秋季至今一直费心思的GxMiner，这家伙算是脱胎于之前的vns-stratum-miner，但是修改了很多也对它做了很多优化，甚至一段时间内比xmrig都快。但是哈毕竟xmrig群策群力，gxminer我独木难支233333。还想通过Ms.Jinx项目来实现多Miner管理，不过GUI和CLI的选择以及其他人对Miner的态度让我没那么多动力去做下去。我是个自私的人，这些项目都是为了我自己的技术成长而不是为了造福广大矿工这可真是抱歉。</p>
<p>然后就是各种算法在nodejs和go上的适配。小工作。换了个头像，这个风格我称之为illusion，是让观察者产生立体错觉的平面色块。</p>
<p>做的最最最多的还是NGIN，现在github上也划到我的maoxs2账号下了。这个项目除了初始的ethereum-fork-code以外我已经重构了四次了，每次都有新收获，上次的代码都已经可以直接PoW了，只不过我在回头来看的时候我还是觉得过于稚嫩。</p>
<p>另外，typescript重置nomp暂时难产，暂时改成了制作node-standalone-pool。</p>
<p>最近在小小的投资公司里实习（反正明年就得去澳洲懒得认真工作），也是做了很多东西，FR007和SHIBOR3M的IRS（带UI和傻瓜操作），基于interception的C#模拟键鼠操作实现无API自动交易，还有基于fsolve的回报值运算等等更琐碎的小运算。</p>
<p>2020年会继续做什么呢？</p>
<p>那肯定NGIN不会弃坑的，但是能不能产出来也不一定，毕竟是从底层重构区块链整个系统。然后预计node-standalone-pool会优先完成，因为pool的需求一直存在。</p>
<p>在技术上会找C艹或者rust再做晋升，另外在准备重写cpuminer。此外非编译型语言上，在nodejs+node-standalone-pool之后转置成ts+deno。</p>
<p>当然最后得强调不能丢下学习哈。去了Monash得去找Joseph Liu喝喝茶聊聊RingCT和他的hcash（哎没错就是那个坑害大妈的hsr）</p>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>Something on NGIN: 一些隨筆</title>
    <url>/post/sth-on-ngin/</url>
    <content><![CDATA[<p>隨意地記錄一些NGIN上的一些思考</p>
<span id="more"></span>

<h2 id="28-April-2020-爲什麽選擇不添加TD-Toatl-Difficulty"><a href="#28-April-2020-爲什麽選擇不添加TD-Toatl-Difficulty" class="headerlink" title="28 April 2020 爲什麽選擇不添加TD(Toatl Difficulty)?"></a>28 April 2020 爲什麽選擇不添加TD(Toatl Difficulty)?</h2><p>本來是打算加的，因爲有如下好處</p>
<ul>
<li>藉鑒ETH的sync</li>
<li>讓同一時間收到的Block之間有不同的rank， 方便node決定fork方向</li>
</ul>
<p>但是後來取消了，選擇了不添加TD，只使用Diff(target)</p>
<ul>
<li>無法排查Block的内部TD錯誤</li>
<li>需要修改難度算法。因爲當前Block難度是在一個checkround中不變的，TD決定rank的特性毫無意義。</li>
<li>Block的獨立性。這個是一直在爭取的東西，可以讓整個架構更可插拔，方便拓展。Diff的關聯已經和上一區塊過於緊密了。在不改變算法的情況下要使得rank不同就需要使用由nonce決定的ActualDiff，而每次ActualDiff實際上都是在re-hash，對PoW算法要求高。而NGIN本來就是CPU算法，不應當采取這樣的機制。</li>
<li>Sync還不完善。Sync機制還是殘廢狀態，不應該開始考慮調優</li>
<li>rank應該能有別的替代品: UnixNano, len(txs) …</li>
</ul>
<h2 id="28-April-2020-Sync機制"><a href="#28-April-2020-Sync機制" class="headerlink" title="28 April 2020 Sync機制?"></a>28 April 2020 Sync機制?</h2><p>P2P_protocol-v0.0.1下NGIN的Sync機制比較殘廢，是直接不停地pingpong來獲取Wired Node的狀態（最高高度）來確認自己是不是out of date.</p>
<p>這裏先簡單説一下其他區塊鏈網絡的Sync機制</p>
<ol>
<li>Bitcoin</li>
</ol>
<p>BTC的Sync機制是發一個hash_stop=0（即取盡可能多）的getheaders/getblocks，讓remoteNode傳回一份Inv也就是庫存清單，localNode就check了一眼這個清單，對自己沒的Block發getdata</p>
<ol start="2">
<li>Ethereum</li>
</ol>
<p>ETH有倆種Sync，一個是Block的，一個是State也就是合約狀態的</p>
<p>這裏就講下Block的。</p>
<p>ETH在連接建立之後就會優先交換一個Status message，裏面就包括了bestHash，前面說的TD，還有一些區別forknet的字段。</p>
<p>然後localNode一看我自家的TD不如別家啊，然後，就會發個GetBlockHeaders請求，認證了PoW信息之後再通過GetBlockBodies把内容也取來，之後就存（執行）起來。</p>
<hr>
<p>因爲Discovery是利用libp2p的kaddht實現，Broadcast機制也已經用libp2p的pubsub給實現了，所以NGIN天生就和上面的不一樣……</p>
<p>libp2p這裏有寫好的<a href="https://godoc.org/github.com/libp2p/go-libp2p-consensus" target="_blank" rel="noopener">共識</a>（<a href="https://godoc.org/github.com/libp2p/go-libp2p-raft" target="_blank" rel="noopener">raft</a>）</p>
<p>當然還有<a href="https://godoc.org/github.com/ipfs/ipfs-cluster/consensus/raft" target="_blank" rel="noopener">ipfs自己在用的raft</a></p>
<p>雖然這個raft庫不能用，也不能從ipfs的改，但是一些架構可以參考</p>
<p>比如，這個consensus是建立在p2p的上層</p>
<p>這就很顛覆了……</p>
<p>= =這樣咋收response</p>
<p>！！！<br>哦對哦</p>
<p>這個Wired又不是broadcast要register！我返回stream然後做個阻塞讀不就好了！</p>
<p>參考<a href="https://github.com/prysmaticlabs/prysm/blob/master/beacon-chain/p2p/sender.go" target="_blank" rel="noopener">prysm</a></p>
<p>媽的，被libp2p的example帶跑了……</p>
<p>看了下prysm的<a href="https://github.com/prysmaticlabs/prysm/tree/9d173dcad2146f34bf5583f359f6227951bf3efc/beacon-chain/sync" target="_blank" rel="noopener">sync</a>，看來他們對initial sync也花了不少心思……居然還有個old……</p>
<h2 id="orphan"><a href="#orphan" class="headerlink" title="orphan"></a>orphan</h2><p>因爲上綫了測試網，因此p2p上很多問題就暴露出來了，其中最嚴重的是由於BlockTime過短導致的分叉。</p>
<p>查了很多遍”prevent/avoid fork”都沒結果，現在在看DAG方案時候才發現人家管這個問題叫orphan block…</p>
<p>大概是手上沒有算力的情況分叉的確就孤兒了……</p>
<p>eth的思路是uncle block，形象一点就是把敌人化为己用，就把uncle的header和hash保存进Block的uncle字段里。</p>
<p>如果分叉节点收到这个带uncle的Block广播就知道了自己手里拿着的这个Block是没用的，它就会“从良”回到这个主线上。</p>
<p>NGIN没有这个设计，因为我觉得uncle信息是冗余的，而且真的作为10s的blockTime要叉出去也很难直接救回来</p>
<p>所以在NGIN裏只有强制fork的情況，儅遠程節點比本機高出數個blockCheckRound的時候就會觸發</p>
<p>爲了防止惡意擡高區塊高度來强制fork，我們需要給這個機制加一個cap。換句話説就是對於離綫過久切分叉太遠的直接孤立隔離，避免其污染網絡</p>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>todo</tag>
        <tag>NGIN</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么选择放弃在block中加入sheet</title>
    <url>/post/why-shouldnt-put-sheet-into-block/</url>
    <content><![CDATA[<p>先简单说下最开始的Vault，vault是一个从上个vault角度对一个范围内block的状态总结，包含一个叫sheet的map(s)来存放最终账户数据（公钥，数据，合约etc）。然后由于同步和验证等过程中因为将vault并入了block的chain中所以每次都要swich type相当别扭，所以删除了vault，将sheet放进了block里。然后就是出现如下弊端。</p>
<span id="more"></span>

<p>最开始独立的vault设计虽然在同步block时候会别扭，但是对于账户等的设计上完全可以做到“状态chain”。在Vault合并Block之后就出现了明显的问题：真的太大了。刚开始想的是放整个sheet，然后发现sheet太大了（相比其他），一个sheet就相当于N*Tx大小而且还每个块必出现。这<strong>恒定占据size对于VPS带宽压力非常大</strong>。VPS带宽的利用会极大地影响实际的TPS和使用体验。假设在未来正常情况下，我区块大小10M，区块时间10s，那么要求就是VPS的网速达到1M/s才能广播<strong>1</strong>个区块。在追求低区块时间的同时，追求减小区块体积的目标也应该落实。这样就和“存入状态”的设计相悖。</p>
<p>后来尝试了sheetHash。从功能上和结构上看是没有什么问题。但是从设计上来看，sheet在仅“账户-余额”的简单应用中大概率可行，但是在涉及了虚拟机和DAPP业务之后就力不从心：因为<strong>需要考虑执行时间</strong>。这也是为啥ethereum不让玩for遍历的原因。当一个新块已经成熟，上个块Block对应的任务还没做完，那这时候的sheet内容就是不正确的。另外，接收者的验证sheet阶段也会消耗时间，当多个Block广播时就会出现疲于验证。</p>
<p>虽然初衷是为chain的deleteable，但是这样就有点得不偿失。</p>
<p>未来做coin了会考虑重拾状态链，但是现阶段主攻还是wasm，schnorr这些技术融合的区块链引擎。</p>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>done</tag>
        <tag>NGIN</tag>
      </tags>
  </entry>
  <entry>
    <title>CoinJoin: Bitcoin privacy for the real world</title>
    <url>/post/coinjoin/</url>
    <content><![CDATA[<p>比特币通常被宣传为隐私工具，但比特币中的唯一隐私性来自匿名地址，该匿名地址易销毁，但是通过地址重复使用，“污点”分析，跟踪付款，监控节点IP地址，网络爬虫以及许多其他机制很容易使该隐私性受到破坏。一旦破坏了这种隐私，很难恢复，有些情况下恢复成本也很高。</p>
<p>传统银行业务默认提供大量隐私保护。您的亲人看不到您正在购买节育措施剥夺他们未来的孙子孙女；您的雇主无法从薪水中获悉您支持的公益；贼人们也无法看到您最近的购买或判断您是如何富有的人，他们无法锁定目标并欺骗您。对于个人和企业而言，比特币的隐私性不足会是一个首要的切实的不利因素。</p>
<p>即使用户通过切换到BIP32地址链上来避免地址重复使用，当他们进行较大的交易时，他们仍然会因旧币和过去的付款而失去隐私。</p>
<p>隐私错误也会造成外部成本：您可能有良好的保护隐私行为，但是当您与不这样做的人（例如使用<a href="https://en.bitcoin.it/wiki/Green_address" target="_blank" rel="noopener">“绿色地址”</a>的人）进行交易时，您和每个与他交易的人一样都会被迫失去一些隐私性。隐私性的缺失也给比特币带来了严重的系统风险：如果降级了的隐私性允许人们汇集中心化的列表甄别好坏币，则当您真诚接受的硬币后来未被其他人兑现时，您就会发现比特币上币与币之间的可替代性遭到破坏，并且其去中心性也伴随着人们被迫给他们自己的币实施流行的黑名单。</p>
<p>这条消息描述了比特币用户可以用来显着改善其隐私性的交易方式，我一直称其为CoinJoin。它不涉及比特币协议的任何更改，并且几年前至今也有数次使用，但是似乎尚未得到广泛的理解。</p>
<p>我首先在一个异想天开的帖子中公开地描述了这种交易方式——“全盘污染！”——通过这个着重讨论了这些交易的一个特定副作用，并期望人们会自己看到其余的含义。</p>
<p>往往清晰击败含蓄，甚至理解该想法的人也有一些本可以被解答的问题。因此，这个帖子就是为此而写。</p>
<span id="more"></span>

<h1 id="CoinJoin-现实世界的比特币隐私"><a href="#CoinJoin-现实世界的比特币隐私" class="headerlink" title="CoinJoin:现实世界的比特币隐私"></a>CoinJoin:现实世界的比特币隐私</h1><p>这个想法很简单，首先要有一些简单的背景知识：</p>
<img src="/post/coinjoin/tx.png" class="">

<p>比特币交易消耗一个或多个输入(Input)并创建具有指定值的一个或多个输出(Output)。</p>
<p>每个输入都是过去交易的输出。对于每个输入，都有一个不同的签名（scriptsig），该签名是根据过去使用的输出（scriptpubkey）中指定的规则创建的。</p>
<p>比特币系统负责确保签名正确，输入存在且可支配，并且输出值的总和小于或等于输入值的总和（任何超出部分都将作为支付给矿工的费用包括交易）。</p>
<p>通常，一笔交易会花费很多投入，以便获得足够的价值来支付其预期的付款，通常还会创建一个额外的“更改”输出，以接收未花费（和非费用）的超额费用。</p>
<p>不需要使用的输入的scriptpubkey相同。也就是说，不要求将其支付到同一地址。而且，实际上当正确使用比特币支付一次性付款时，没有一个会是相同的。</p>
<p>在考虑比特币所有权的历史时，可以将从多个不同的scriptpubkey花费的交易视为它们的所有权共同加入，并做出一个假设：除非有共同方控制这些地址，否则该交易又如何从多个地址花费？</p>
<p>在图中，“交易2”花费了分配给1A1和1C3的硬币。那么1A1和1C3就一定是同一方吗？</p>
<p>这个假设是不正确的。单个交易中的用法并不能证明是通用控制（尽管目前看来很有意义），这就是使CoinJoin成为可能的原因：</p>
<p>交易事务内部的每个输入的签名彼此完全独立。这意味着比特币用户可能会同意要花费的一组输入，要支付的一组输出，然后分别单独签署交易并随后合并其签名。在提供所有签名之前，该交易是无效的，并且不会被网络接受，并且没有人会签名不符合他们喜好的交易。</p>
<p>为了使用它来增加隐私，N个用户将同意一个统一的输出大小，并提供至少等于该大小的输入。如果某些用户提供的输入超出目标，则该交易将具有该大小的N个输出，并可能有N个更多的更改输出。所有人都会签署交易，然后可以传输交易。任何时候都没有被盗的风险。</p>
<p>在图示中，“交易2”的输入来自1A1和1C3。假设我们相信1A1是用于Alice的地址，而1C3是用于Charlie的地址。 Alice和Charlie中的哪一个拥有1D和1E的输出？</p>
<p>这个想法也可以更随意地使用。当您要付款时，找到也要付款并共同付款的其他人。这样做并不会增加太多隐私，但是实际上会使您的交易更小，从而在网络上更轻松（费用更低）；额外的隐私更是一种增益。</p>
<p>这样的交易在外部来看与通过常规使用创建的交易没有区别。因此，如果这些交易变得很普遍，它们甚至可以改善不使用它们的人的隐私，因为不再将输入共同参与作为通用控制的有力证据。</p>
<p>这个想法可能有很多变种，并且可以与变种共存，因为该想法不需要更改比特币系统。百花齐放：我们可以在实现这一目标的方式上有多种选择，并学到最好的方法。</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><em>是否不需要tor或其他东西来阻止所有人分析每个人的IP？</em></p>
<p>任何希望隐藏用户地址的交易隐私系统都应以某种匿名网络开始。 没什么两样。 幸运的是，像Tor，I2P，Bitmessage和Freenet这样的网络都已经存在，并且可以全部用于此目的。 （但是，Freenet会导致交易非常缓慢）</p>
<p>但是，加强“污点分析”并缩小交易规模甚至不需要用户彼此私密。 因此，即使没有类似tor之类的，也不会比常规交易更糟糕。</p>
<p><em>用户是否不了解哪些输入与哪些输出匹配？</em></p>
<p>在用户使用基于tor的IRC之类的最简单的可能实现方式中，是的。下一个最简单的实现是，用户将其输入和输出信息发送到某些集合点服务器上，然后服务器创建交易并要求人们对其进行签名。服务器学习了映射，但其他人都没有，服务器仍然无法窃取硬币。</p>
<p>在甚至服务器都不学习映射的情况下，也可能有更复杂的实现。</p>
<p>例如。使用chaum盲签名：用户连接并提供输入（和更改地址）以及他们希望私人硬币进入的地址的密码盲版本；服务器对令牌进行签名并返回它们。用户匿名重新连接，取消隐藏其输出地址，然后将其返回给服务器。服务器可以看到所有输出均已由其签名，因此所有输出都必须来自有效参与者。后来人们重新连接并签名。</p>
<p>类似的事情可以通过各种零知识证明系统来完成。</p>
<p><em>完全隐私的版本是否需要一台服务器？ 如果关机了怎么办？</em></p>
<p>不是。在所有用户都充当盲签名服务器的情况下，可以通过分散方式实现相同的隐私。 最终需要n^2个签名，并且通常很难创建分布式系统。 我不知道是否有理由去辛辛苦苦做出具有完全保密性的完全分布式版本，但是这肯定是可能的。</p>
<p><em>DoS（拒绝服务）攻击如何？ 即使交易有效，有人也不能拒绝签名吗？</em></p>
<p>是的，这可以通过两种不同的方式受到DoS的攻击：有人可以拒绝签署有效的联合交易，或者有人可以在联合交易完成之前从联合交易中花费其输入。</p>
<p>但是，如果所有签名都没有在一定期限内到来，或者创建了冲突的交易，则您可以轻松地离开恶意方，然后重试。使用自动过程，任何重试对于用户都是不可见的。因此，唯一真正的风险是持久的DoS攻击者。</p>
<p>在非分散（或分散但非参与者专有）的情况下，对DoS攻击者获得一定的免疫力是很容易的：如果某人未签名输入，则在以后的回合中将该输入列入黑名单。然后，他们自然会受到创建更多已确认比特币交易的能力的限制。</p>
<p>在分散式系统中获得DoS抵抗力要困难得多，因为很难确定哪个用户实际上违反了规则。一种解决方案是让用户在零知识证明系统下执行其活动，因此您可以确定哪个用户是骗子，然后同意忽略他们。</p>
<p>在所有情况下，您都可以通过工作证明，保真度绑定或其他稀缺资源使用来补充反DoS机制。但是我怀疑，随着实际攻击的发生，最好适应这种攻击，因为我们不必事先针对所有用户都采用单一的安全机制。我还认为，错误的输入排除可以为入门提供足够的保护。</p>
<p><em>匿名集大小是否不受一次交易中可以拥有多少方的限制？</em></p>
<p>不完全是。显然，单个交易的匿名集大小受其参与方数量的限制。交易规模的限制以及失败（重试）的风险意味着真正庞大的联合交易是不明智的。但是，由于这些交易价格便宜，因此可以联合的交易数量没有限制。</p>
<p>特别是，如果您可以建立每个事务有m个参与者的事务，则可以创建一个m*3事务序列，该序列构成一个三阶段交换网络，该网络允许m^2个最终输出中的任何一个来自m^2个原始输入（例如，使用32个交易的三个阶段，每个输入有32个输入，每个1024个用户可以加入96个交易）。这允许匿名集设置为任何大小，仅受参与限制。</p>
<p>实际上，我希望大多数用户只希望防止闲的蛋疼的朋友（和小偷）进入他们的财务生活，并恢复由于地址重用等不良做法而丢失的一些隐私。这些用户可能只通过一次通行证就会感到满意；其他人将只是机会性地进行操作，而其他人则可能会努力实现许多通行证和重要的匿名设置。所有人都可以共存。</p>
<p><em>与ZeroCoin相比如何？</em></p>
<p>作为一个密码学和计算机科学的极客，我对Zerocoin感到非常兴奋：其背后的技术令人着迷并且非常重要。但是，作为比特币用户和开发人员，推广它作为改善隐私的解决方案令我感到失望。</p>
<p>Zerocoin有很多严重的局限性：</p>
<ul>
<li>它使用最先进的加密技术，这可能是不安全的，并且相对较少的人可以理解（例如，与ECDSA相比）。</li>
<li>它会产生较大的签名（20 KB），这些签名会使区块链膨胀（如果将其填充到外部存储中会产生风险）。</li>
<li>它需要一个受信方来启动其累加器。如果该组织作弊，他们可以偷硬币。 （也许可以通过更先进的加密技术修复。）</li>
<li>验证非常慢（在快速CPU上每秒可以处理约2tx），这是在比特币中部署的主要障碍，因为每个完整节点都必须验证每笔交易。</li>
<li>大笔交易和缓慢的验证也意味着昂贵的交易，这将减少匿名集的大小，并可能使零散地关注随机性的公众无法使用ZC。</li>
<li>使用永久增长且无修剪的累加器。实际上，这意味着我们需要定期切换累加器以减小工作集大小，从而减小匿名集大小。如果未预先设置累加器的范围，则可能会造成大的UTXO膨胀问题。</li>
</ul>
<p>随着时间的流逝，随着数学和软件工程的改善，其中一些事情可能会显着改善。</p>
<p>但最重要的是：<strong>Zerocoin要求对比特币协议进行软分叉更改</strong>，所有完整节点都必须采用此更改，这会将比特币提交到Zerocoin协议的特定版本。这不可能很快发生——可能不会在几年内发生，特别是考虑到有很大的潜力可以进一步改进算法以降低成本。这将在政治上引起争议，因为一些开发人员和比特币业务非常担心过度与“匿名”相关联。网络范围内的规则更改有点像自杀协议：我们不应该也不要轻视它们。</p>
<p><strong>CoinJoin交易从今天开始就可以工作</strong>，从比特币的第一天开始就开始运作。 它们与正常交易没有区别，因此无法阻止或抑制，除非可以阻止其他任何比特币交易。</p>
<p>（顺便说一句：ZeroCoin可能在去中心化CoinJoin中以比特币的形式在外部使用，以一种抵御DoS攻击的方式使用户相互不可见。这将使ZeroCoin在实时交锋中成熟，而无需承担成本或承诺网络范围内的特点协议。）</p>
<p>我可以通过CoinJoin为ZeroCoin提出的主要论点是，它可能会提供更大的匿名集，这超出了我的加密极客的愿望。 但是由于ZC的性能和扩展限制，以及使用CoinJoin构造分类网络事务的可能性，或者仅具有使用数百个CoinJoin事务以及一项ZeroCoin事务所需的存储和处理能力的能力，我不知道实际上哪个会 在实践中产生更大的匿名集。 例如。 要加入1024个用户，仅ZeroCoin兑换将涉及20k * 1024字节的数据，而对于32个32位联合交易的完整三阶段联合来说，该数据不到3％。 尽管ZeroCoin匿名集可以更轻松地跨越更大的时间范围。</p>
<p>CoinJoin交易的匿名集很容易足够大，普通用户可以重新获得他们的一些临时隐私，这就是我认为最有趣的事情。</p>
<p><em>这与CoinWitness相比如何？</em></p>
<p>CoinWitness甚至比Zerocoin更超前复杂，它还具有许多改善隐私性的弱点：新颖的加密技术，计算成本以及需要软分叉的巨大缺点，并且现阶段不可用。 如果它不仅仅用作隐私工具，还可能具有一些扩展优势。 但这确实是解决该问题的过度手段，并且不会在任何真正的时间推出。</p>
<p><em>听起来不错！ 它在哪里？</em></p>
<p>麻烦之处：尚无现成的，易于使用的软件来执行此操作。您可以使用bitcoin-qt和原始交易API手动进行交易，就像我们在“富含污点”线程中所做的那样，但是要使之成为现实，我们需要易于使用的自动化工具。</p>
<p>卢克（Luke）编写了一些协议的草图，该协议将允许通过常规比特币网络建立联合交易。</p>
<p>Bitcoin-qt RPC系统为此类系统的参与者提供了编写辅助小程序所需的一切（包括锁定txout的功能，以防止它们被从其下方花费掉）。但是，如今有如此多的用户使用可监视他们的集中式网络钱包这一事实最终将限制这些工具的用户群。</p>
<p>就我个人而言，我大部分的编码大脑能力都花在了其他事情上，这些事情对我来说更重要。而且我可以在比特币上剩余的钱都花在了更多的核心和安全性上—如果我很快处理与钱包相关的任何事情，那可能会改善硬币选择的隐私行为……但此外：</p>
<p>建立此功能的任何人都将被指控进行犯罪活动，无论是否有任何实际的犯罪分子使用此行为，都无关紧要：犯罪活动会成为头条新闻。作为比特币核心开发人员，已经可以填补我这种指控的名额，尤其是我什至没有付钱的风险名额。笑脸</p>
<p>实际上，真正的犯罪分子即使有丝毫线索也不需要CoinJoin：他们有能力以普通用户无法获得的方式购买隐私，这只是他们（通常是利润丰厚的）业务的成本。</p>
<p>Joe-criminal可以外出购买120％PPS采矿来获得全新的硬币，或者通过一系列半伪造的高现金流量赌博企业来赚钱，以减少50％的费用，他们可以负担寻找并与之交互的成本这些卑鄙的服务…乔和简·多伊？他们的名字在blockchain.info的跑马灯上。对于他们来说，这似乎不太好，但是如果修复它的成本很高，他们根本不会，因为修复它的成本是非常具体的，而且损失的成本或投机性是遥不可及的。他们可能只需要放弃比特币，而转而使用几乎完全私人的东西：现金…普通用户需要有效且廉价的隐私才能完全帮助他们。</p>
<p>我知道制作这样的工具并不适合许多比特币企业的快速致富模式，但是重要性是显而易见的，并且最简单的版本不需要非常深入的技术指导。我认为，改善人们隐私的“政治”风险是您应该认真考虑的真实风险，但是在这些部分附近，我看到人们在一些风险非常高的东西上贴上自己的名字。我希望“全盘污染”的话题足以激发社区的某些行动，但是也许会。</p>
<p>因此，应该反过来，我问你：它在哪里？</p>
<p><a href="https://bitcointalk.org/index.php?topic=279249.0" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <tags>
        <tag>bitcointalk</tag>
        <tag>bitcoin</tag>
        <tag>done</tag>
        <tag>coinjoin</tag>
        <tag>privacy</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT5152: UI Design</title>
    <url>/post/fit5152-ui-design-notes/</url>
    <content><![CDATA[<p>首先在各种公开消息来源上都说这个是刷分水课来着。再加上本身自己在设计上想要有点提高（怎么说也算当过艺术生的），又经常有需要设计的场景（项目别太多）。现在也是前端更火热，所以掌握这个是很有价值的。</p>
<hr>
<p>总算总结完了，感觉这门课可以改名叫UI Guidelines了……太tm多了这内容</p>
<span id="more"></span>

<h2 id="S1-Introduction-to-HCI-and-User-Interface-Design"><a href="#S1-Introduction-to-HCI-and-User-Interface-Design" class="headerlink" title="S1 Introduction to HCI and User Interface Design"></a>S1 Introduction to HCI and User Interface Design</h2><p>成吨的理论知识……后面几个S分别扩展</p>
<p>HCI，即人机交互，包含了为达成某目标的一系列行为</p>
<p>系统开发生命周期</p>
<img src="/post/fit5152-ui-design-notes/image-20210220115032057.png" class="" title="image-20210220115032057">

<p>交互式系统设计</p>
<img src="/post/fit5152-ui-design-notes/image-20210220115139022.png" class="" title="image-20210220115139022">

<p>HCI主要的三个方面</p>
<ul>
<li>我们如何设计？（谁是用户？哪些任务？）Design</li>
<li>我们如何构造？Prototyping</li>
<li>我们如何评估？Evaluation</li>
</ul>
<h3 id="Design："><a href="#Design：" class="headerlink" title="Design："></a>Design：</h3><p>获取数据及定义需求-&gt; 用户分析，任务分析，环境/域分析，数据收集方式：采访，问卷，目标组或观察</p>
<p>Conceptual Design：</p>
<p>描述系统该做什么以及长啥样</p>
<p>Physical Design：</p>
<p>考虑系统实际细节</p>
<h3 id="Prototyping"><a href="#Prototyping" class="headerlink" title="Prototyping"></a>Prototyping</h3><p>Assignment3的内容</p>
<p>Low-fidelity (paper) prototyping</p>
<p>High-fidelity (digital) prototyping</p>
<p>Native prototyping</p>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>Expert reviews专家审阅： Heuristics evaluation 启发式评估, Cognitive walkthrough 认知走查</p>
<p>Usability testing</p>
<p>Field studies</p>
<p>Observation</p>
<h3 id="Usability"><a href="#Usability" class="headerlink" title="Usability"></a>Usability</h3><p>is a quality attribute of the UI</p>
<p><strong>effectiveness</strong>, <strong>efficiency</strong>, and <strong>satisfaction</strong> in a specified context of use</p>
<h3 id="Importance-of-UI-Design"><a href="#Importance-of-UI-Design" class="headerlink" title="Importance of UI Design"></a>Importance of UI Design</h3><p>lead to user satisfaction, business success, and cost savings…</p>
<h3 id="User-Centered-Design"><a href="#User-Centered-Design" class="headerlink" title="User-Centered Design"></a>User-Centered Design</h3><p>puts human needs, capabilities, and behavior first</p>
<p>match the needs and capabilities of the people</p>
<p>based on the needs and interests of the user</p>
<p>Users’ tasks and goals are the driving force</p>
<h3 id="Why-to-involve-users"><a href="#Why-to-involve-users" class="headerlink" title="Why to involve users"></a>Why to involve users</h3><ul>
<li>Users bring important knowledge of work tasks</li>
<li>Designers can gain a better understanding of users’ needs and goals</li>
<li>Greater acceptance of the system often results</li>
<li>Fewer problems during development</li>
<li>Lower maintenance costs over time</li>
<li>Products that are easier to learn</li>
<li>Reduction in errors</li>
<li>Users develop a feeling of ownership through contributing to the development</li>
</ul>
<h3 id="Human-Centered-Design"><a href="#Human-Centered-Design" class="headerlink" title="Human-Centered Design"></a>Human-Centered Design</h3><p>Human-centred design puts more emphasis on all stakeholders, and not just ‘users’</p>
<h3 id="Principles-of-Human-Centered-Design"><a href="#Principles-of-Human-Centered-Design" class="headerlink" title="Principles of Human-Centered Design"></a>Principles of Human-Centered Design</h3><p>The ISO standard describes 6 key principles.<br>These principles apply to user-centred design as well.<br>• The design is based upon an explicit understanding of users, tasks and environments<br>• Users are involved throughout entire development<br>• The design driven and refined by user-centered evaluation<br>• The process is iterative<br>• The design addresses the whole user experience<br>• The design team includes multidisciplinary skills and perspectives</p>
<h2 id="S2-Everyday-Design"><a href="#S2-Everyday-Design" class="headerlink" title="S2 Everyday Design"></a>S2 Everyday Design</h2><p>实际上的标题是Design Theories, Models and Principles</p>
<p>Discoverability</p>
<p>Visibility</p>
<p>Visibility is not just about what you can see</p>
<p>Principles of Discoverability</p>
<ul>
<li>Affordances: 就像椅子、button一样一看就知道咋用</li>
<li>Signifiers: 当affordance不能被察觉的时候拿来提示的（比如门上push, pull的贴纸</li>
<li>Feedback: 反馈（比如震动</li>
<li>Constraints: 约束，约束用户行为别乱搞乱用</li>
<li>Mappings: 两类物品之间的映射关系（如音量+-，还有插头插座</li>
</ul>
<h3 id="Conceptual-model-of-the-system"><a href="#Conceptual-model-of-the-system" class="headerlink" title="Conceptual model of the system"></a>Conceptual model of the system</h3><p>系统的理论模型</p>
<p>It provides understanding about the meaning of the controls and settings and what all that means</p>
<h4 id="Users"><a href="#Users" class="headerlink" title="Users"></a>Users</h4><p>尝试解释产品如何工作</p>
<p>在用户脑子里的叫mental models，通常根据experience, training or interaction with the product来形成</p>
<h4 id="Designers"><a href="#Designers" class="headerlink" title="Designers"></a>Designers</h4><p>可能和用户的（mental models）不同</p>
<p>和用户的交流局限于系统印象</p>
<ol>
<li>the <strong>physical structure</strong> of the product, and the discoverability through using affordances, signifiers, constraints and mappings</li>
<li>technical <strong>manuals</strong> and <strong>documentations</strong></li>
</ol>
<h3 id="Knowledge-in-the-head"><a href="#Knowledge-in-the-head" class="headerlink" title="Knowledge in the head"></a>Knowledge in the head</h3><p>the knowledge in the human <strong>memory</strong> system</p>
<p><strong>requires learning</strong></p>
<p>也可以把knowledge of the world然后转进head</p>
<h3 id="Knowledge-in-the-World"><a href="#Knowledge-in-the-World" class="headerlink" title="Knowledge in the World"></a>Knowledge in the World</h3><p>external knowledge</p>
<p>客观存在的知识</p>
<p>Much of the knowledge need to perform tasks can come from the information in the world (using affordances, signifiers, feedback and mappings) </p>
<p>比如键盘布局！</p>
<h3 id="Cognitive-Process"><a href="#Cognitive-Process" class="headerlink" title="Cognitive Process"></a>Cognitive Process</h3><p>认知过程</p>
<p>include:</p>
<ul>
<li><p>attention (the first step) can be visual or auditory, 就听or看见</p>
</li>
<li><p>perception and recognition, 洞察与辨别</p>
</li>
<li><p>memory, 记下来</p>
</li>
<li><p>Learning (and then reading, speaking and listening) 学习</p>
</li>
<li><p>reasoning and problem solving (reflective cognition) 推理与解决问题（反射式认知）</p>
</li>
</ul>
<p>交互时涉及大量认知过程</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>the ability to store and remember information</p>
<h4 id="Sensory-memory"><a href="#Sensory-memory" class="headerlink" title="Sensory memory"></a>Sensory memory</h4><p>感官记忆，很短，且如果无意识就很快忘</p>
<h4 id="Short-term-or-working-memory-STM"><a href="#Short-term-or-working-memory-STM" class="headerlink" title="Short-term (or working) memory (STM)"></a>Short-term (or working) memory (STM)</h4><p>少量信息。短时间</p>
<p>接触新界面时候，会学习到新元素的使用，会存储这部分内容</p>
<p>好设计应当减少其发生（E.g. using ‘recognition rather than recall’）</p>
<h4 id="Long-term-memory-LTM"><a href="#Long-term-memory-LTM" class="headerlink" title="Long-term memory (LTM)"></a>Long-term memory (LTM)</h4><p>retain the information for hours, months or years </p>
<p>无限容量</p>
<p>过去经历和知识的存储位置</p>
<p>形成了产品的mental model</p>
<h3 id="Cognitive-Load"><a href="#Cognitive-Load" class="headerlink" title="Cognitive Load"></a>Cognitive Load</h3><p>认知负载。处理某任务所花费的气力</p>
<p>减少memory load就能减少cognitive load。这对好的界面设计非常关键</p>
<h3 id="External-Cognition"><a href="#External-Cognition" class="headerlink" title="External Cognition"></a>External Cognition</h3><p>external representations and aids</p>
<p>应该最小化用户需要记忆的内容</p>
<p>通过外部认知能过减小load</p>
<p>– Externalising 外部化<br>• Transforming knowledge into external representations, e.g. using a calendar or diary (birthdays, appointments)<br>– Computational offloading 计算方面减负<br>• e.g. a calculator<br>– Annotating and cognitive tracing 注记或者认知追踪<br>• such as Word Track Changes</p>
<h2 id="S3-Requirement-Gathering-Task-Analysis"><a href="#S3-Requirement-Gathering-Task-Analysis" class="headerlink" title="S3 Requirement Gathering, Task Analysis"></a>S3 Requirement Gathering, Task Analysis</h2><h3 id="Data-gathering"><a href="#Data-gathering" class="headerlink" title="Data gathering"></a>Data gathering</h3><p>首先需要收集 user, tasks, the context of use, the environment/domain and if any constraints</p>
<h4 id="techniques"><a href="#techniques" class="headerlink" title="techniques"></a>techniques</h4><ul>
<li>Studying existing documentation</li>
<li>Researching similar systems/products</li>
</ul>
<p>就多看书or多抄</p>
<p>或者S1里Design里那些</p>
<h4 id="KYC（Know-your-user）"><a href="#KYC（Know-your-user）" class="headerlink" title="KYC（Know your user）"></a>KYC（Know your user）</h4><p>一些重要指标</p>
<p>▪    Demographics: age, gender, occupation<br>▪    Needs, capabilities and limitations<br>▪    Digital literacy<br>▪    Cultural background<br>▪    Social status</p>
<h4 id="Design-Personas"><a href="#Design-Personas" class="headerlink" title="Design Personas"></a>Design Personas</h4><p>Personas大致就是代表性用户画像的意思</p>
<p>Design personas:  Focus more on user goals, needs, motivations, and user behaviour</p>
<p>Each persona usually have <strong>2-4</strong> goals<br>Goals are different from tasks, which are performed to achieve goals</p>
<p>Scenario: 场景， 就脑补（narrative叙述）一个persona通过交互实现goal的情形</p>
<h3 id="Task-Analysis"><a href="#Task-Analysis" class="headerlink" title="Task Analysis"></a>Task Analysis</h3><p>Hierarchical Task Analysis (HTA)，就Assignment里画过的那东西。就尽可能分割任务然后用图表述。</p>
<p>S4 Navigation, Menus</p>
<h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><p>finding information by navigating through the interface</p>
<p>主要是解决<del>fps游戏</del>三大问</p>
<p>– Where am I? 我是谁<br>– What’s here? 这是哪<br>– Where can I go from here? 我该去哪</p>
<p>It requires understanding user needs and behaviour, identifying tasks, and effective content organisation</p>
<h4 id="Structural-Navigation"><a href="#Structural-Navigation" class="headerlink" title="Structural Navigation"></a>Structural Navigation</h4><p>根据页面层级</p>
<ul>
<li><p>顶级页面的主导航</p>
</li>
<li><p>次级页面里的二级导航</p>
</li>
</ul>
<img src="/post/fit5152-ui-design-notes/image-20210221101807538.png" class="" title="image-20210221101807538">

<h4 id="Associative-Navigation"><a href="#Associative-Navigation" class="headerlink" title="Associative Navigation"></a>Associative Navigation</h4><p>Associative navigation connects pages with similar topics and content or with the same level of importance without considering their location in the hierarchy</p>
<p>辅助性导航就属于是常驻的，不管页面层级</p>
<ul>
<li>Footer navigation</li>
<li>quick links </li>
<li>Contextual navigation</li>
</ul>
<p>Contextual Navigation：</p>
<p>发生在内容上的导航</p>
<ul>
<li>Embedded navigation (e.g. Links within the text)</li>
<li>Related links<ul>
<li>Usually provided at the end or to the side of page</li>
</ul>
</li>
<li>Adaptive navigation<ul>
<li>E.g. the links change based on what the site visitors do/select</li>
</ul>
</li>
</ul>
<h3 id="Utility-navigation"><a href="#Utility-navigation" class="headerlink" title="Utility navigation"></a>Utility navigation</h3><p>工具导航（不被包括进页面层级</p>
<p>–    Navigation between pages and features that helps with using the interface</p>
<p>比如搜索栏</p>
<h3 id="Visual-Flow"><a href="#Visual-Flow" class="headerlink" title="Visual Flow"></a>Visual Flow</h3><p>扫描顺序为Z形，阅读顺序为F形</p>
<p>▪    Consider the logical flow of the users’ tasks.<br>▪    Create a logical path.<br>▪    Minimise eye movement.<br>▪    Use alignment and size uniformity for screen elements</p>
<p>。。。</p>
<h2 id="S5-Form-Design"><a href="#S5-Form-Design" class="headerlink" title="S5 Form Design"></a>S5 Form Design</h2><h3 id="Issues-with-Forms"><a href="#Issues-with-Forms" class="headerlink" title="Issues with Forms"></a>Issues with Forms</h3><p>可能存在问题：</p>
<p>▪    Too <strong>long</strong><br>▪    <strong>Unclear</strong> purpose, asking for information that <strong>irrelevant</strong> to the user’s goals<br>▪    Poor information about the requirement of a given field，<strong>内容提示不足</strong><br>▪    Asking for the same (or similar) information more than once，<strong>重复</strong><br>▪    When there is an error, it does not clearly indicate where it happened or how it can be corrected，<strong>错误提示不足</strong><br>▪    Not clarifying the right <strong>data format</strong><br>▪    Not providing the necessary <strong>space</strong>，<strong>太窄</strong><br>▪    Taking user control away，<strong>不自由</strong></p>
<h3 id="Data-Quality-Problem"><a href="#Data-Quality-Problem" class="headerlink" title="Data Quality Problem"></a>Data Quality Problem</h3><p>就提交上来的数据存在的问题</p>
<p>▪    Data entered in the forms are often <strong>incomplete</strong> or have <strong>poor quality</strong><br>▪    Well designed forms can improve data quality<br>▪    目标：ensure correct data entry with minimal user effort</p>
<p>用户填表顺序</p>
<ol>
<li>Understanding the question</li>
<li>Finding an answer</li>
<li>Judging an answer</li>
<li>Entering the answer on the form</li>
</ol>
<h3 id="Guidelines"><a href="#Guidelines" class="headerlink" title="Guidelines"></a>Guidelines</h3><p>!important 这东西重要</p>
<ul>
<li>Meaningful, familiar and standard field labels</li>
<li>Consistent terminology and abbreviations</li>
<li>Optional and required fields clearly marked</li>
<li>Comprehensible instructions</li>
<li>Use visible space and boundaries for data entry fields</li>
<li>Differentiate grouped items</li>
<li>Visually appealing layout (alignment)</li>
<li>Use lists if possible to minimise errors</li>
<li>Immediate feedback</li>
<li>Completion feedback</li>
</ul>
<h2 id="S6-Evaluation"><a href="#S6-Evaluation" class="headerlink" title="S6 Evaluation"></a>S6 Evaluation</h2><p>Evaluation and Usability Testing</p>
<h3 id="Evaluation-Aims"><a href="#Evaluation-Aims" class="headerlink" title="Evaluation Aims"></a>Evaluation Aims</h3><p>评估目标</p>
<ul>
<li>Are the options and controls visible to the user?</li>
<li>Does the user know how to interact with the UI elements?</li>
<li>Is the navigation and workflow appropriate?</li>
<li>Does the product do what the user expected it to do?</li>
<li>Is the functionality correct from the user’s perspective?</li>
<li>What are the good and poor features?</li>
</ul>
<p>作用</p>
<ul>
<li>Extensive testing is a key to successful design.</li>
<li>To understand how real users use the product and if it meets their needs.</li>
<li>To identify the issues and addressing them.</li>
<li>To reduce user errors.</li>
<li>To improve user experience and increase user satisfaction.</li>
<li>To ensure the product meets the standards and guidelines.</li>
<li>To compare with similar products.</li>
<li>It is cheaper to fix a problem earlier in development than later.</li>
</ul>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Experts:</p>
<ul>
<li>Cognitive walkthrough</li>
<li>Heuristic evaluation</li>
</ul>
<p>User:</p>
<ul>
<li>Usability Testing</li>
<li>Field studies</li>
<li>Thinking aloud</li>
</ul>
<h3 id="Expert-reviews"><a href="#Expert-reviews" class="headerlink" title="Expert reviews"></a>Expert reviews</h3><p>专家审阅</p>
<p>identify usability problems and provide recommendations</p>
<p>早期或晚期</p>
<p>存在问题：</p>
<ul>
<li>Even knowledgeable experts might not know how real users, particularly first-time users, will interact with the product</li>
<li>experts may not have an adequate understanding of the task domain or user communities.”</li>
</ul>
<h3 id="Cognitive-Walkthrough"><a href="#Cognitive-Walkthrough" class="headerlink" title="Cognitive Walkthrough"></a>Cognitive Walkthrough</h3><p>认知走查</p>
<p>用于设计早期</p>
<h3 id="Heuristic-Evaluation"><a href="#Heuristic-Evaluation" class="headerlink" title="Heuristic Evaluation"></a>Heuristic Evaluation</h3><p>启发式评估,，就assignment内容</p>
<p><strong>–    Nielsen’s 10 heuristics</strong><br><strong>–    Shneiderman’s Eight Golden Rules</strong></p>
<h3 id="Nielsen’s-10-heuristics"><a href="#Nielsen’s-10-heuristics" class="headerlink" title="Nielsen’s 10 heuristics"></a>Nielsen’s 10 heuristics</h3><ol>
<li>Visibility of system status</li>
<li>Match between system and the real world</li>
<li>User control and freedom</li>
<li>Consistency and standards</li>
<li>Error prevention</li>
<li>Recognition rather than recall (menu: to underline text, you look at the menu and recognise the option)</li>
<li>Flexibility and efficiency of use</li>
<li>Aesthetic and minimalist design</li>
<li>Help users recognize, diagnose, and recover from errors</li>
<li>Help and documentation</li>
</ol>
<h3 id="Shneiderman’s-Eight-Golden-Rules"><a href="#Shneiderman’s-Eight-Golden-Rules" class="headerlink" title="Shneiderman’s Eight Golden Rules"></a>Shneiderman’s Eight Golden Rules</h3><ol>
<li>Strive for consistency (=N#4)</li>
<li>   Cater to universal usability (=N#4)</li>
<li>   Offer informative feedback (=N#9,)</li>
<li>   Design dialogs to yield closure</li>
<li>   Prevent errors</li>
<li>   Permit easy reversal of actions (undo)</li>
<li>   Support internal ‘locus of control’</li>
<li>   Reduce short term memory</li>
</ol>
<h2 id="S7-Prototyping"><a href="#S7-Prototyping" class="headerlink" title="S7 Prototyping"></a>S7 Prototyping</h2><p>成功UI的四支柱Four pillars：</p>
<img src="/post/fit5152-ui-design-notes/image-20210222203134223.png" class="" title="image-20210222203134223">

<ol>
<li>   User interface requirements<br>§    Right and complete requirements are key</li>
<li>   Guidelines documents and processes<br>§    Design principles that must be adopted within the design</li>
<li>   User-Interface software tools and prototyping<br>§    To give users a clearer idea of design and its implications</li>
<li>   Expert reviews and usability testing<br>§    To evaluate the design</li>
</ol>
<h3 id="Prototyping-1"><a href="#Prototyping-1" class="headerlink" title="Prototyping"></a>Prototyping</h3><p>重要性</p>
<p>–    test their ideas,<br>–    test possible alternatives,<br>–    clarify requirements,<br>–    validate requirements,<br>–    solicit feedback<br>–    identify problems<br>–    and improve the final product</p>
<p>类别</p>
<p>Level of fidelity:</p>
<p>§    Low-fidelity prototypes<br>§    High-fidelity prototypes</p>
<p>Type of medium used:</p>
<p>§    Sketching and paper prototypes<br>§    Digital prototypes<br>§    Native prototypes</p>
<p>Level of interactivity:</p>
<p>§    Static prototypes<br>§    Interactive prototypes</p>
<p>Level of detail:</p>
<p>§    Horizontal prototypes<br>§    Vertical prototypes</p>
<h4 id="low-fidelity"><a href="#low-fidelity" class="headerlink" title="low fidelity"></a>low fidelity</h4><p>adv</p>
<p>•    Simple, cheap and quick to create.<br>•    Truly hands-on because the designers have to manually manipulate the content.<br>•    The process of cutting, pasting, sorting, labelling forces designers to become familiar with the content elements.<br>•    It can be constructed quickly and efficiently and taken anywhere.<br>•    Even in a rough form, it gives the users a good idea of content organisation and navigation.<br>•    Easy to refine in the final product.<br>•    Prototypes appear to enhance teambuilding skills.</p>
<p>•    With low-fidelity prototypes, users and designers are often more willing to suggest changes.<br>•    Users are more comfortable working with paper and criticising it rather than the real system.<br>•    Users recognise it as a ‘prototype’ so feel more free to make recommendations.<br>•    It allows for more iterations.<br>•    It allows to test with more users and identify more problems.</p>
<h4 id="High-Fidelity"><a href="#High-Fidelity" class="headerlink" title="High-Fidelity"></a>High-Fidelity</h4><p>adv</p>
<p>•    Interactive<br>•    Enables testing navigation, graphical elements and colours, legibility, image quality, alignment and spacing.<br>•    Looks and works more like the real product, resulting in more useful feedback.<br>•    Designers can show and test real flow and interactions.<br>•    At this stage certain limitations become apparent that were not identified earlier in the design.</p>
<p>disadv</p>
<p>•    It is not as cheap as low-fidelity prototypes.<br>•    It is not as fast as low-fidelity prototypes.<br>•    It cannot be taken anywhere easily like low-fidelity prototypes.<br>•    It cannot be refined as easy as low-fidelity prototypes.</p>
<h2 id="S8-UI-Design-and-Usability-Graphics-and-Visual-Design"><a href="#S8-UI-Design-and-Usability-Graphics-and-Visual-Design" class="headerlink" title="S8 UI Design and Usability - Graphics and Visual Design"></a>S8 UI Design and Usability - Graphics and Visual Design</h2><h3 id="Visual-Design"><a href="#Visual-Design" class="headerlink" title="Visual Design"></a>Visual Design</h3><p>视觉设计</p>
<p>▪    Line<br>▪    Shape<br>▪    Size and volume<br>▪    Position<br>▪    Negative/white space<br>▪    Colour<br>▪    Basic visual elements are used to create text, images, icons, textures, and animation</p>
<p>【感觉就像SVG</p>
<h4 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h4><p>Guidelines</p>
<p>•    Select colors carefully<br>•    Minimize number of colors<br>•    Reduce eye strain instead of increasing it<br>•    Follow conventions: e.g. link colors<br>•    Be aware of accessibility rules<br>–    Be aware of color blindness<br>–    Provide sufficient contrast between foreground and background<br>–    Don’t use color alone to convey information</p>
<h4 id="Typography"><a href="#Typography" class="headerlink" title="Typography"></a>Typography</h4><p>Guidelines</p>
<p>•    Use more legible fonts<br>•    Use fewer typefaces (generally 1-2, or 3 max)<br>•    Italics, underline and bold can be used to emphasise points but should be used sparingly<br>–    Underlines can be mistaken by hyperlinks<br>•    Minimise using different sizes (1-3 max)<br>•    Support redundancy<br>•    There should be sufficient spacing between text lines to make it easy to read, and to increase reading speed<br>•    The size of the font should be large enough<br>•    The text alignment is also important and better to use left or justified alignment because the centre or right alignments make the text hard to read</p>
<h2 id="S9-UI-Design-and-Usability-Interaction-Styles"><a href="#S9-UI-Design-and-Usability-Interaction-Styles" class="headerlink" title="S9 UI Design and Usability - Interaction Styles"></a>S9 UI Design and Usability - Interaction Styles</h2><p>交互风格</p>
<h3 id="Command-Line-Interfaces"><a href="#Command-Line-Interfaces" class="headerlink" title="Command Line Interfaces"></a>Command Line Interfaces</h3><p>没错命令行也是……</p>
<p>disadv</p>
<ul>
<li>Commands are issued in a specific language and different across different platforms. </li>
<li>Hard to remember the name of commands and their order (specially for novice users).</li>
<li>Hard to provide users with feedback and handle errors.</li>
</ul>
<p>adv</p>
<ul>
<li>It is more efficient to use by expert users.</li>
<li>It is more efficient to perform repetitive tasks.</li>
<li>Lack of graphical UI elements allows the user to focus on the task.</li>
</ul>
<h3 id="Direct-Manipulation"><a href="#Direct-Manipulation" class="headerlink" title="Direct Manipulation"></a>Direct Manipulation</h3><p>直接操作</p>
<p>其实就是UI点点点这样的</p>
<p>。。。</p>
<h3 id="Fitts’s-Law"><a href="#Fitts’s-Law" class="headerlink" title="Fitts’s Law"></a>Fitts’s Law</h3><p>建议移动到目标区域所需的时间是考虑到<strong>目标的距离</strong>以及<strong>目标的宽度/大小</strong>的函数</p>
<p>它是一种预测模型，可用于确定UI元素（如按钮）的正确<strong>大小</strong>和正确<strong>位置</strong></p>
<p><img src="fit5152-ui-design-notes/image-20210222222651518.png" alt="image-20210222222651518" loading="lazy"><img src="fit5152-ui-design-notes/image-20210222222656487.png" alt="image-20210222222656487" loading="lazy"></p>
<h3 id="Hick’s-Law"><a href="#Hick’s-Law" class="headerlink" title="Hick’s Law"></a>Hick’s Law</h3><p>用户做出决定所需的时间取决于可能的选择数量</p>
<p>菜单中包含的选择越多，用户做出决定所花费的时间就越长</p>
<p>不确定和不熟悉会增加决策时间</p>
<p>KISS（保持简短和简单）</p>
<p>使用带有较长列表和菜单的图像会很有帮助，并且可以将用户快速定向到正确的内容</p>
<h3 id="Choice"><a href="#Choice" class="headerlink" title="Choice"></a>Choice</h3><p>如何选择交互风格</p>
<ul>
<li>Selecting the right input and output devices depends on: 选io设备根据<ul>
<li>Environment and context of use 使用环境</li>
<li>Speed of interaction (Games) 交互速度</li>
<li>Accuracy of actions 准确度</li>
<li>Type of tasks (if it requires entering a large amount of text) 任务类型</li>
<li>Size (of screen) 屏幕大小</li>
<li>Complexity of the system 系统复杂度</li>
<li>Users? <ul>
<li>People with disabilities 残障人士</li>
<li>Their digital skills 用户电子水平</li>
<li>Their previous experience with the device 用户对设备的使用经历</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The most important thing is to meet the users’ goals but user preferences vary.</p>
<p><strong>Interfaces change but principles do not</strong>(所以考guidelines)</p>
<h2 id="S10-Design-Styles"><a href="#S10-Design-Styles" class="headerlink" title="S10 Design Styles"></a>S10 Design Styles</h2><p>UI Design and Usability - Design Languages and Styles</p>
<p>设计语言（也就御三家的玩意……</p>
<p>– Skeuomorphic Design（老罗最爱拟物设计）</p>
<p>– Flat Design （扁平化）</p>
<p>– Metro Design (MDL), MDL2 （时代眼泪）, and Fluent Design （微软biss）</p>
<p>– Material Design （好家伙）</p>
<p>– iOS Design（好看+流畅）</p>
<h2 id="S11-Reports-amp-Error-Messages"><a href="#S11-Reports-amp-Error-Messages" class="headerlink" title="S11 Reports &amp; Error Messages"></a>S11 Reports &amp; Error Messages</h2><p>UI Design and Usability Reports - Error Messages</p>
<h3 id="Report-Guidelines"><a href="#Report-Guidelines" class="headerlink" title="Report Guidelines"></a>Report Guidelines</h3><ul>
<li>Use meaningful titles of the report.</li>
<li>Include meaningful information.</li>
<li>Balance the layout. 框架平衡</li>
<li>Design an easy navigation system for a multi-page report.</li>
<li>All important information should be highlighted. 高亮关键内容</li>
<li>For displaying text in a report, <strong>文字</strong><ul>
<li>use mixed uppercase and lowercase.</li>
<li>void using overly fancy fonts</li>
<li>use enough spacing between paragraphs.</li>
<li>left-justify text and leave a ragged right margin.</li>
<li>use abbreviations and acronyms only when they are widely understood and are significantly shorter than full-text.</li>
</ul>
</li>
<li>For displaying content in tables and lists in a report <strong>表格/列表</strong><ul>
<li>all columns and/or rows should have meaningful labels 都要有标签</li>
<li>labels should be separated from other content by using highlighting 标签从内容里拎出来且高亮</li>
<li>redisplay labels when the data extend beyond a single screen or page. 别超出屏幕</li>
<li>sort in a meaningful order 排序</li>
<li>avoid using overly fancy fonts 别用浮夸字体</li>
<li>right-justify numeric data 数字数据右对齐</li>
<li>left-justify textual data. 文字数据左对齐</li>
<li>break long sequence of alphanumeric data into small groups of 3 to 4 characters each.用符号分割长数字</li>
<li><img src="/post/fit5152-ui-design-notes/image-20210222223934093.png" class="" title="image-20210222223934093"></li>
</ul>
</li>
<li>For displaying data with visuals, use the right type of visual with the data in the report to turn report data into knowledge.<ul>
<li>Use <strong>line graph</strong> to track <strong>changes</strong> over <strong>a period of time</strong></li>
<li>Use <strong>bar graph</strong> when <strong>comparing</strong> things between different <strong>groups</strong> or when tracking <strong>changes</strong> over <strong>a period of time</strong></li>
<li>Use <strong>pie chart</strong> when <strong>comparing</strong> different <strong>parts of a whole.</strong></li>
<li>If there is a lot of data to display in a report that requires scrolling, apply filters and make use of hierarchies/drill-downs.</li>
</ul>
</li>
</ul>
<h3 id="Error-Message"><a href="#Error-Message" class="headerlink" title="Error Message"></a>Error Message</h3><ul>
<li>Be as specific and precise as possible.  尽可能精确详细</li>
<li>Choose user-centred phrasing. State problem, cause, and solution. 向用户表述问题，原因以及解决方案</li>
<li>Consider multiple levels of messages. 考虑多级消息</li>
<li>Use a positive tone. Be courteous. Avoid condemnation. 用积极语气，别骂人</li>
<li>Maintain consistent grammatical forms, terminology, and abbreviations. 用一致的格式术语缩写</li>
<li>Keep error messages next to fields in forms. 将错误消息保留在表单中的字段旁边</li>
<li>Use color to differentiate errors from normal field states 用颜色区分</li>
<li>Add iconography or subtle animation for easy scanning 加icon或动画方便发现</li>
<li>Maintain consistent visual format and placement. 保持一致的视觉格式和位置</li>
<li>Use modal dialogs for important warnings to prevent or correct critical errors 使用对话框显示重要警告，以防止或纠正严重错误<ul>
<li>Use modal dialogs only when there is a need to draw extra attention to an error that can lead to some irreparable consequences. 仅当需要特别注意可能导致某些无法弥补的后果的错误时，才使用对话框。</li>
<li>Modal dialog boxes are disruptive as they disable the main content and do not allow the user to continue interacting with the interface until the dialog box is open, thereby, interrupting the user from completing their task.  模态对话框具有破坏性，因为它们禁用了主要内容，并且在对话框打开之前不允许用户继续与界面进行交互，从而中断了用户完成其任务。</li>
</ul>
</li>
</ul>
<h2 id="S12-CURRENT-TRENDS-IN-HCI"><a href="#S12-CURRENT-TRENDS-IN-HCI" class="headerlink" title="S12 CURRENT TRENDS IN HCI"></a>S12 CURRENT TRENDS IN HCI</h2><p>略</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>UI</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT9132: Intro to DB</title>
    <url>/post/fit9132-db-notes/</url>
    <content><![CDATA[<p>整体难度不大，tutor也很给面子（要是我自己给自己打分肯定更低</p>
<p>建议尽早摘抄知识点并且在Tut/Ass时候就用起来，别像我一样前面拍脑子考前总结才发现都在PPT里。</p>
<span id="more"></span>

<h2 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h2><p>回顾历史DB发展以及名人</p>
<h2 id="W2-Conceptual-Modelling"><a href="#W2-Conceptual-Modelling" class="headerlink" title="W2 Conceptual Modelling"></a>W2 Conceptual Modelling</h2><p>理论模型</p>
<p>因为是chow’s foot图，所以复合（1：1）、多值（1：N）属性记得加个实体来表述会更直观</p>
<h3 id="理论模型设计"><a href="#理论模型设计" class="headerlink" title="理论模型设计"></a>理论模型设计</h3><p>开发企业数据模型。</p>
<ul>
<li>对应于ANSI / SPARC体系结构的概念级别。</li>
<li>独立于所有物理实施注意事项（要使用的数据库类型）。</li>
<li>可以采用各种设计方法，例如UML，ER（实体关系）。</li>
<li>ER由实体之间的<strong>实体</strong>和<strong>关系</strong>组成</li>
</ul>
<p>ENTITY具有属性（我们希望记录的东西），其中一个或多个属性将标识实体实例（称为KEY）</p>
<h3 id="强弱实体"><a href="#强弱实体" class="headerlink" title="强弱实体"></a>强弱实体</h3><p><strong>强实体</strong></p>
<blockquote>
<p>具有可以在不参考其他实体的情况下定义的Key。例如EMPLOYEE实体。</p>
<img src="/post/fit9132-db-notes/image-20210218223640286.png" class="" title="image-20210218223640286">
</blockquote>
<p><strong>弱实体</strong></p>
<blockquote>
<p>具有要求存在一个或多个其他实体的Key。例如FAMILY实体-需要包括员工的KEY才能为家庭创建合适的密钥</p>
<img src="/post/fit9132-db-notes/image-20210218223450092.png" class="" title="image-20210218223450092">
</blockquote>
<p>数据库设计人员通常根据业务规则确定一个实体是否可被描述为弱实体，例如</p>
<blockquote>
<p> 客户每月支付帐款</p>
<p> Key：cust_no，date_paid</p>
<p>或者：payment_no（如果是凭空创造的surrogate Key？- 不属于理论模型）</p>
</blockquote>
<p>理论模型不加surrogate Key！</p>
<table>
<thead>
<tr>
<th>显著Identifying</th>
<th>不显著Non-identifying</th>
</tr>
</thead>
<tbody><tr>
<td>Identifier of A is part of identifier of B.</td>
<td>Identifier of A is NOT part of identifier of B.</td>
</tr>
<tr>
<td>实线</td>
<td>虚线</td>
</tr>
<tr>
<td>ENROLMENT - STUDENT Enrolment key includes student id, which is an identifier of student.<br />CAR - CAR_COLOR<br />存在同样的key</td>
<td>Department no (identifier of department) is not part of Employee’s identifier.</td>
</tr>
</tbody></table>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>类型: 简易，复合，单值，多值，派生</p>
<p>鱼尾纹chow’s foot表示法不支持多值属性。 值被列为单独的属性。</p>
<p>关联（或复合）实体</p>
<h2 id="ERD"><a href="#ERD" class="headerlink" title="ERD"></a>ERD</h2><p>关系数据库模型，即ERM，构成ERD(实体关系图)的基础。<br>ERD代表最终用户查看的概念数据库。<br>ERD描述了数据库的主要组成部分：实体，属性和关系。<br>因为实体代表现实世界中的对象，所以实体和对象一词经常互换使用。 </p>
<p>正好实体关系图也能在vuepress里用markdown+mermaid绘制，所以可以直接画着玩。由于还处于experimental，所以是只能表现实体和关系，并不能展示属性</p>
<p>在mermaid里，几对几这样的关系分成左右两部分描述。</p>
<table>
<thead>
<tr>
<th>左边</th>
<th>右边</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>`</td>
<td>o`</td>
<td>`o</td>
</tr>
<tr>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td><code>&#125;o</code></td>
<td><code>o&#123;</code></td>
<td>零或多个 (无上限)</td>
</tr>
<tr>
<td>`}</td>
<td>`</td>
<td>`</td>
</tr>
</tbody></table>
<pre class="mermaid">erDiagram
    CUSTOMER ||--o{ ORDER : places</pre>

<p>表示<strong>一个</strong>CUSTOMER强对应<strong>0或多个</strong>ORDER，即一个顾客对应着0个(未点单)或多个其点过的订单</p>
<pre class="mermaid">erDiagram
    ORDER ||--|{ ITEM : contains</pre>

<p>表示<strong>一个</strong>ORDER强对应<strong>0或多个</strong>ITEM，即一份订单上存在一个或多个商品</p>
<pre class="mermaid">erDiagram
    CUSTOMER }|..|{ ADDRESS : uses</pre>

<p>表示<strong>0或多个</strong>CUSTOMER弱对应<strong>0或多个</strong>ADDRESS，即存在多个顾客且存在多个地址，之间存在弱对应关系</p>
<h2 id="W3-Relational-Model"><a href="#W3-Relational-Model" class="headerlink" title="W3 Relational Model"></a>W3 Relational Model</h2><p>Relational Model&amp;Relational Algebra关系模型与代数</p>
<p>这个作业里是用SQL Developer从Logical里生成出来的，所以到SQL（DDL）部分才开始create。</p>
<p>这里主要讲的是</p>
<ul>
<li>用NAME(Attribs…)表示的实体，每个数据都是一个tuple</li>
<li>其中的各种key: SuperKey(一或多个属性，独一无二), CK（一或多个属性）, PK（从CK中选的一个），AK（alternate keys。PK以外的CK）</li>
<li>代数（select，project，join，其他union，diff，div啥的都不用）顺便为后面归一化做准备</li>
</ul>
<p>功能性依赖Functional Dep</p>
<p>如果在任何时候属性（集）A的值都确定单属性B值（当且仅当），则属性B在A上是功能依赖的。</p>
<p>• order_no → order_date<br>• prod_no → prod_desc<br>• order_no, prod_no → ordered_qty</p>
<p>RM 特点：</p>
<ul>
<li>要有独一无二的名字</li>
<li>每个属性要有独一无二名字（用prefix</li>
<li>属性不能多值</li>
<li>所有属性值应当来自同一个域</li>
<li>必须有主键</li>
<li>relations 之间的 Logical (not physical) connections 通过primary/foreign keys表示</li>
</ul>
<h2 id="W4-Normalisation"><a href="#W4-Normalisation" class="headerlink" title="W4 Normalisation"></a>W4 Normalisation</h2><p>归一化</p>
<ul>
<li><p>为了避免在插入，更新和删除数据时可能发生的异常，应规范化关系。</p>
</li>
<li><p>规范化是一系列系统步骤，用于逐步完善数据模型。</p>
</li>
<li><p>基于primary key（或候选 candidate keys）分析关系的正式方法 密钥）和功能依赖项。用作：“自下而上设计”的一种设计技术，以及作为一种验证通过“自上而下的设计”产生的结构的方式（将ER模型转换为逻辑模型-参见下周）</p>
</li>
</ul>
<p>更新异常的类型包括：</p>
<p>•插入异常-仅在新员工被分配到项目时才插入</p>
<p>•删除异常-删除分配给项目的唯一员工？</p>
<p>​    –删除特定工作类别的唯一员工？</p>
<p>•修改（或 更新）异常</p>
<p>​    -更新作业类别的每小时费率 - 需要更新多行</p>
<p>归一化目标</p>
<ul>
<li><p>创建有效的关系，即每个关系都符合关系模型的属性。 特别是：–实体完整性–引用完整性–没有多对多关系–每个单元格都包含一个值（是原子的）。</p>
</li>
<li><p>在RDBMS中实施时，实际上：–每个表代表一个主题 –没有数据项 将不必要地存储在多个表中。–可以建立表之间的关系（标识了PK和FK对）。–每个表都没有插入，更新和删除异常。</p>
</li>
</ul>
<p>功能性依赖Functional Dep</p>
<p>参照前面</p>
<p>部分依赖Partial Dep（1-&gt;2）</p>
<p>缺少对多个属性键的完全依赖</p>
<ul>
<li>ORDERNO, PRODNO ➔ PRODDESC, QTY_ORDERED</li>
<li>尽管qty_ordered完全取决于orderno和prodno，但仅需prodno即可确定proddesc</li>
<li>proddesc部分依赖于orderno和prodno</li>
<li>用人话说，就是现在看起来是主键是orderno，但是要是有个prodno也能决定qty ，那就把prodno和qty拎出去</li>
<li>拎出去之后那个新实体的key在原位置保留且<strong>作为key</strong>！</li>
</ul>
<p>传递依赖Transitive Dep（2-&gt;3）</p>
<ul>
<li>当Y取决于X，Z取决于Y时发生</li>
<li>因此Z也取决于X，即。 X➔Y➔Z 并且Y不是候选键（或候选键的一部分）</li>
<li>ORDER_NO➔CUST_NO➔CUST_NAME: CUSTOMER(<u>CUST_NO</u>, CUST_NAME)</li>
<li>emp_no➔job_class➔chg_hour: JOB (<u>job_class</u>, chg_hour)</li>
<li>拎出去之后那个新实体的key在原位置保留但是<strong>不作为key</strong>！</li>
</ul>
<p>UNF-&gt;1NF</p>
<ol>
<li><p>确定重复组的Key。</p>
</li>
<li><p>删除任何重复组以及主要关系的PK。</p>
</li>
<li><p>由于重复组的去除而导致的新关系的PK通常具有由主要关系的PK组成的复合PK 以及上面1.中选择的唯一标识符，但是必须进行检查。说人话就是拎出来的实体要带原来的Key，也要有自己的Key，就反正至少俩</p>
</li>
</ol>
<p>最后写出所有的Partial dependencies</p>
<p>1NF -&gt; 2NF</p>
<p>2NF下的关系</p>
<ul>
<li>继承前面的</li>
<li>把所有Partial dependencies<strong>部分依赖</strong>拎出来</li>
</ul>
<p>最后写出所有的Transitive dependencies</p>
<p>2NF -&gt; 3NF</p>
<p>如果3NF，则存在关系</p>
<ul>
<li>继承前面的</li>
<li>把所有Transitive dependencies<strong>传递依赖</strong>项都拎出来</li>
</ul>
<p>最后要写出所有的Full Dependencies</p>
<h2 id="W5-Logical-Model"><a href="#W5-Logical-Model" class="headerlink" title="W5 Logical Model"></a>W5 Logical Model</h2><p>就是Assignment里让你画在SQL Developer里那个。按实际制作流程来看应该比relational model先讲。</p>
<p>在Conceptual Model正确情况下较简单，但是别像我一样拍脑子做。</p>
<h3 id="逻辑设计（1b）"><a href="#逻辑设计（1b）" class="headerlink" title="逻辑设计（1b）"></a>逻辑设计（1b）</h3><ul>
<li>开发针对特定数据库模型的数据模型（例如关系，分层，网络，面向对象，noSQL）。</li>
<li>独立于任何特定供应商DBMS软件包的任何实施细节。</li>
<li>归一化技术（请参阅w4）用于测试关系逻辑模型的正确性。</li>
</ul>
<h3 id="1-映射常规（强）实体"><a href="#1-映射常规（强）实体" class="headerlink" title="1. 映射常规（强）实体"></a>1. 映射常规（强）实体</h3><p>先是把Conceptual Model里的Key转为PK或者FK，加UQ</p>
<h3 id="2-映射弱实体"><a href="#2-映射弱实体" class="headerlink" title="2. 映射弱实体"></a>2. 映射弱实体</h3><h3 id="3-映射二元关系"><a href="#3-映射二元关系" class="headerlink" title="3. 映射二元关系"></a>3. 映射二元关系</h3><h4 id="1-M"><a href="#1-M" class="headerlink" title="1:M"></a>1:M</h4><p>记得加fk到M那侧</p>
<h4 id="M-N"><a href="#M-N" class="headerlink" title="M:N"></a>M:N</h4><p>Conceptual里的M:N关系需要转为1:N和N:1</p>
<p>例如</p>
<img src="/post/fit9132-db-notes/image-20210217003847464.png" class="" title="image-20210217003847464">

<p>转为</p>
<img src="/post/fit9132-db-notes/image-20210217003857615.png" class="" title="image-20210217003857615">

<p>如图TEAM和EMPLOYEEE之间的leads关系</p>
<img src="/post/fit9132-db-notes/image-20210217225042251.png" class="" title="image-20210217225042251">

<img src="/post/fit9132-db-notes/image-20210217225057637.png" class="" title="image-20210217225057637">

<p>在强制侧的PK变成可选那侧的FK（如emp_no的到了team成了fk，虽然人家是1:M</p>
<p>如果都是可选的，那就加到null最少那侧</p>
<p>如果两边都强制那就考虑合并吧</p>
<h3 id="4-映射关联实体"><a href="#4-映射关联实体" class="headerlink" title="4. 映射关联实体"></a>4. 映射关联实体</h3><p>就类似上面M:N的处理，不过关联实体往往有surrogate key，例如XXX_no，所以就这个no加P别的纯粹F</p>
<h3 id="5-映射一元关系"><a href="#5-映射一元关系" class="headerlink" title="5. 映射一元关系"></a>5. 映射一元关系</h3><p>1:1，1:M 不变</p>
<p>MN：加实体</p>
<img src="/post/fit9132-db-notes/image-20210217230405132.png" class="" title="image-20210217230405132">







<h3 id="6-映射三元关系"><a href="#6-映射三元关系" class="headerlink" title="6. 映射三元关系"></a>6. 映射三元关系</h3><p>拆成三个二元</p>
<h2 id="W6-DDL"><a href="#W6-DDL" class="headerlink" title="W6 DDL"></a>W6 DDL</h2><p>SQL create</p>
<p>uq的constraint写inline</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> unit</span><br><span class="line">(</span><br><span class="line">unit_code <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">unit_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">CONSTRAINT</span> uq_unit_name <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> pk_unit <span class="keyword">PRIMARY</span> KEY (unit_code)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>这里提一下前面W3里的内容，就是FK要么是其他的PK，要么就是NULL，所以就基本上不写NOT NULL。另外FK一般拎出来alter。ON DELETE CASCADE保证引用完整性（感觉一般不用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> enrolment</span><br><span class="line"><span class="keyword">ADD</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_enrolment_student <span class="keyword">FOREIGN</span> KEY (stu_nbr) <span class="keyword">REFERENCES</span> student ( stu_nbr),</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_enrolment_unit <span class="keyword">FOREIGN</span> KEY (unit_code) <span class="keyword">REFERENCES</span> unit (unit_code)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>值的约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">ADD (stu_address varchar(200),</span><br><span class="line">status char(1) DEFAULT &#39;C&#39;,</span><br><span class="line">constraint status_chk CHECK (status in (&#39;G&#39;,&#39;C&#39;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>





<h2 id="W7-SQL"><a href="#W7-SQL" class="headerlink" title="W7 SQL"></a>W7 SQL</h2><p>主要讲的就是select和where</p>
<p>限定词：</p>
<ul>
<li>=, !=, &lt;&gt;, &lt;, &gt;, &gt;=, &lt;=</li>
<li>between</li>
</ul>
<p>NOTE: between aaa and bbb时候aaa和bbb<strong>都</strong>是被包括进去的</p>
<ul>
<li>in (‘aaa’, ‘bbb’ …)</li>
<li>like: %表示0+个字符, _表示单字符</li>
<li>is null, is not null (判断null时候不能用=或!=)</li>
<li>any, all</li>
<li>exists</li>
</ul>
<p>select执行后三种状态：True, False和Unknown（匹配到NULL）。是True才算被检索到。</p>
<p>select 检索时候做运算（如grade+1）则列名变成该算式（”grade+1”），反正就很难看，所以一般用as 重命名一下。当as的新名字有空格，用**” “**去包围（不是单引号！），列名始终用双引号。</p>
<p>NULL算啥都还是NULL，也可以用NVL(原列名, 值)来代替NULL做运算（如NVL(enrol_mark, 0)默认NULL为0）</p>
<p>Order by</p>
<ul>
<li><p>NULL<strong>S</strong> LAST, NULL<strong>S</strong> FIRST</p>
</li>
<li><p>DESC （默认ASC故可省略）</p>
</li>
</ul>
<p>SELECT DISTINCT 去重复行</p>
<p>JOIN</p>
<blockquote>
<p>from aaa JOIN bbb ON aaa.a = bbb.b</p>
<p>from aaa JOIN bbb ON aaa.key = bbb.key </p>
<p>from aaa JOIN bbb USING (key) </p>
<p>from aaa NATURAL JOIN bbb</p>
</blockquote>
<p>to_char(SYSDATE, ‘dd-Mon-yyyy hh:mi:ss PM’)</p>
<p>反过来就to_date(datetime, ‘dd-Mon-yyyy hh:mi:ss PM’ )</p>
<p>一些系统变量SYSDATE SYSDATETIME USER </p>
<p>另外数字的format里0和9区别: 9占位但不padding（除非小数，但用FM连小数也不），0占位还padding</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; select to_char(1, &#39;999.999&#39;),</span><br><span class="line">  2         to_char(1, &#39;000.000&#39;),</span><br><span class="line">  3         to_char(1, &#39;900.009&#39;),</span><br><span class="line">  4         to_char(1, &#39;999.000&#39;)</span><br><span class="line">  5  from   dual;</span><br><span class="line"></span><br><span class="line">1.000</span><br><span class="line">001.000</span><br><span class="line">01.000</span><br><span class="line">1.000</span><br><span class="line"></span><br><span class="line">select to_char(1, &#39;FM999.999&#39;),</span><br><span class="line">       to_char(1, &#39;FM000.000&#39;),</span><br><span class="line">       to_char(1, &#39;FM900.009&#39;),</span><br><span class="line">       to_char(1, &#39;FM999.000&#39;)</span><br><span class="line">from   dual;</span><br><span class="line"></span><br><span class="line">1.</span><br><span class="line">001.000</span><br><span class="line">01.00</span><br><span class="line">1.000</span><br></pre></td></tr></table></figure>



<h2 id="W8-DML"><a href="#W8-DML" class="headerlink" title="W8  DML"></a>W8  DML</h2><p>Update, Delete and Transaction Management</p>
<p>记得每个insert/update 都要commit！</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>主要讲事务上的读写锁S（shared lock）和X（exclusive lock）</p>
<p>当一个新Tx，</p>
<ul>
<li>读SLock: 更新SLock到S(Tx)</li>
<li>写SLock: 新Tx wait 上个老Tx</li>
<li>读XLock: wait</li>
<li>写XLock: wait</li>
</ul>
<p><strong>最后画个wait的图</strong>，判断是否deadlock（回环）</p>
<h3 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h3><p>rolled forward：REDO+after-images</p>
<p>rolled back：UNDO+before-images</p>
<p>checkpoint：就把在checkpoint后fail前commit的重做（REDO），未完成的rollback（UNDO），区间前面完成的也不理</p>
<img src="/post/fit9132-db-notes/image-20210217155937874.png" class="" title="image-20210217155937874">

<p>如图</p>
<p>T1: 无需操作</p>
<p>T3,T5 roll back: 因为没commit</p>
<p>T2 roll forward: 因为在checkpoint点和fail点中间提交的</p>
<p>T4 roll forward: 因为在检查点后开始且fail前提交的</p>
<h2 id="W9-Aggregate-Functions"><a href="#W9-Aggregate-Functions" class="headerlink" title="W9 Aggregate Functions"></a>W9 Aggregate Functions</h2><p>COUNT, MAX, MIN, AVG</p>
<p>COUNT，AVG ignore null rows</p>
<p>GROUP BY -&gt; 合并keys相同的rows，对每个合并后的Aggregate使用Fn</p>
<p>HAVING -&gt; 对Group BY的结果进行约束 </p>
<p>IN</p>
<p>ANY, ALL</p>
<p>extract</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extract(year from ofyear) as year</span><br></pre></td></tr></table></figure>



<p>decode: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">decode (cltype, </span><br><span class="line">  <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;Lecture&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;Tutorial&#x27;</span>) <span class="keyword">as</span> Classtype</span><br></pre></td></tr></table></figure>



<p>lpad</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lpad(</span><br><span class="line">  extract(year from ofyear) || &#39; S&#39; || semester,</span><br><span class="line">  10,&#39; &#39;) as offering</span><br></pre></td></tr></table></figure>





<h2 id="W10-Advanced-SQL"><a href="#W10-Advanced-SQL" class="headerlink" title="W10 Advanced SQL"></a>W10 Advanced SQL</h2><p>好家伙分数大头</p>
<h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><ul>
<li>case when expr then val end</li>
<li>case var then val end</li>
</ul>
<h3 id="Subquery"><a href="#Subquery" class="headerlink" title="Subquery"></a>Subquery</h3><p>基本上哪里都能套</p>
<h4 id="nested"><a href="#nested" class="headerlink" title="nested"></a>nested</h4><p>xxx in (select)</p>
<h4 id="correlated"><a href="#correlated" class="headerlink" title="correlated"></a>correlated</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> studid, unitcode, mark</span><br><span class="line"><span class="keyword">from</span> uni.enrolment e1</span><br><span class="line"><span class="keyword">where</span> mark <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(mark)</span><br><span class="line">  <span class="keyword">from</span> uni.enrolment e2</span><br><span class="line">  <span class="keyword">where</span> e1.unitcode <span class="operator">=</span> e2.unitcode)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> unitcode, studid;</span><br></pre></td></tr></table></figure>

<p>这个也能用在update，insert这些上（很好用</p>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> studid, e.unitcode, mark</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> unitcode, <span class="built_in">max</span>(mark) <span class="keyword">as</span> max_mark</span><br><span class="line">  <span class="keyword">from</span> uni. enrolment</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> unitcode) max_table</span><br><span class="line"><span class="keyword">join</span> uni.enrolment e <span class="keyword">on</span> e.unitcode <span class="operator">=</span>   max_table.unitcode <span class="keyword">and</span></span><br><span class="line">e.mark <span class="operator">=</span> max_table.max_mark</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> unitcode, studid;</span><br></pre></td></tr></table></figure>

<p>这里max_table就是select出来内容的alia</p>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">grade,</span><br><span class="line"><span class="built_in">count</span>(grade) <span class="keyword">as</span> grade_count,</span><br><span class="line">(<span class="keyword">SELECT</span> </span><br><span class="line">  <span class="built_in">count</span>(grade) <span class="keyword">from</span> uni.enrolment) <span class="keyword">as</span> total_rows,</span><br><span class="line">  <span class="number">100</span><span class="operator">*</span><span class="built_in">count</span>(grade)<span class="operator">/</span>(<span class="keyword">SELECT</span> <span class="built_in">count</span>(grade) <span class="keyword">FROM</span> uni.enrolment</span><br><span class="line">) <span class="keyword">as</span> percentage</span><br><span class="line"><span class="keyword">FROM</span> uni.enrolment</span><br><span class="line"><span class="keyword">where</span> grade <span class="keyword">is</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> grade;</span><br></pre></td></tr></table></figure>

<p>套中套</p>
<h3 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h3><p>基本不用 （因为ass不让</p>
<p>考试应该就可以</p>
<p>但是基本上功能和前面subquery差不多</p>
<h3 id="Joins"><a href="#Joins" class="headerlink" title="Joins"></a>Joins</h3><p>natural join, self join, outer join </p>
<p>这个就没前面的natural join那样慈眉善目了，丢分巨头</p>
<h4 id="self-join"><a href="#self-join" class="headerlink" title="self join"></a>self join</h4><p>Show the name of the manager for each employee.</p>
<p>因为manager也是employee，所以就算self join，通过mgrno和empno来对应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM emp.employee e1 JOIN emp.employee e2</span><br><span class="line">ON e1.mgrno &#x3D; e2.empno;</span><br></pre></td></tr></table></figure>

<p>吓得我去看了眼考试SQL的模型，还好没一元关系</p>
<h4 id="outer-join"><a href="#outer-join" class="headerlink" title="outer join"></a>outer join</h4><p>这个用的比较多</p>
<h5 id="full-outer-join"><a href="#full-outer-join" class="headerlink" title="full outer join"></a>full outer join</h5><p>两边对应不上的都保留</p>
<img src="/post/fit9132-db-notes/image-20210218213524538.png" class="" title="image-20210218213524538">

<p>如图，左边的id=3没对应所以右边空null，右边4没对应所以左边空null</p>
<h5 id="left-right-outer-join"><a href="#left-right-outer-join" class="headerlink" title="left/right outer join"></a>left/right outer join</h5><p>left只保证左边的都有对应，因此只保留右边的null</p>
<p>right只保证右边的都有对应，因此只留左边的null。</p>
<p>另外左右是根据join关键词的左边右边决定的，比如上面的full就是<code>id_name full outer join id_subj_mark</code></p>
<h3 id="Set-Operators"><a href="#Set-Operators" class="headerlink" title="Set Operators"></a>Set Operators</h3><p>大前提：列能对的上</p>
<p>Union All 加法（不去重）</p>
<p>Union 加法（去重）</p>
<p>Intersect 重叠部分，即$A \and B$</p>
<p>Minus 减法，即$A-(A \and B)$</p>
<p>另外，union优先级比order by高</p>
<h3 id="Oracle-Functions"><a href="#Oracle-Functions" class="headerlink" title="Oracle Functions"></a>Oracle Functions</h3><p>见文档</p>
<h2 id="W11-BigData"><a href="#W11-BigData" class="headerlink" title="W11 BigData"></a>W11 BigData</h2><p>纯介绍+NoSQL</p>
<p>JSON_OBJECT(‘key’ value val FORMAT JSON)</p>
<p>JSON_ARRAYAGG(JSON_OBJECT(), JSON_OBJECT())</p>
<p>MongoDB</p>
<p>insertOne(), insertMany([])</p>
<p>find({})或者find(匹配, 需要的列)，例如find({_id: 2}, {name: 1})只取id=2那列的name</p>
<p>op: </p>
<p>{$and: [{}, {}]}</p>
<p>{$or: [{}, {}]}</p>
<p>updateOne(匹配, {$set: {}})</p>
<p>$ 替代符 placeholder to update the <strong>first element</strong> that matches the query condition，例如 client.$.addr</p>
<p>deleteOne()</p>
<p>deleteMany()</p>
<h2 id="W12"><a href="#W12" class="headerlink" title="W12"></a>W12</h2><p>无Lec</p>
<h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><p>输出<code>   Fri 01 February 2019 RM</code>这样的date str用<code> lpad(rtrim(to_char(ca.carndate, &#39;Dy DD Month&#39;)) || &#39; &#39; || to_char(ca.carndate, &#39;YYYY&#39;),23) AS carnival_date,</code>（人裂开</p>
<h2 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h2><p>Sample给的这么全面想想也不会考的很简单……</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h4 id="Relational-Model-10"><a href="#Relational-Model-10" class="headerlink" title="Relational Model 10"></a>Relational Model 10</h4><ol>
<li>不同attrib（估计考试会换成不同的key）</li>
<li>a. &amp; b. 代数式（一定要记得最后再π一下去掉不必要的列</li>
</ol>
<h4 id="Database-Design-20"><a href="#Database-Design-20" class="headerlink" title="Database Design 20"></a>Database Design 20</h4><p>根据文章徒手撸Logical Model（简易版，其实就和ASS1的Conceptual差不多了）</p>
<p>写纸上</p>
<h4 id="Normalisation-10"><a href="#Normalisation-10" class="headerlink" title="Normalisation 10"></a>Normalisation 10</h4><p>写全过程（记得最后一定要跟上Full Dep</p>
<h4 id="SQL-40"><a href="#SQL-40" class="headerlink" title="SQL 40"></a>SQL 40</h4><p>根据给出的Model写</p>
<ol>
<li>insert，alter还有update</li>
<li>简单select + 巨难的left outer join</li>
<li>又是left outer join再配合having count(distinct ) + select subquery </li>
</ol>
<h4 id="Big-Data-and-No-SQL-10"><a href="#Big-Data-and-No-SQL-10" class="headerlink" title="Big Data and No SQL 10"></a>Big Data and No SQL 10</h4><ol>
<li><p>json和mongodb</p>
</li>
<li><p>神tm名词解释Volume，Velocity，Variety。估计考试要求介绍NOSQL了</p>
</li>
</ol>
<h4 id="Transaction-10"><a href="#Transaction-10" class="headerlink" title="Transaction 10"></a>Transaction 10</h4><ol>
<li>锁</li>
<li>checkpoint</li>
</ol>
<h2 id="Exam-1"><a href="#Exam-1" class="headerlink" title="Exam"></a>Exam</h2><p>题型的确和Sample一模一样</p>
<p>前四个除了第一个问答题以外不用多说，老内容了，而且感觉更简单？（也可能是我掉坑）。</p>
<p>第一个问答题改成了Relation里tuple的特性</p>
<img src="/post/fit9132-db-notes/image-20210219224938123.png" class="" title="image-20210219224938123">

<p>就这部分内容</p>
<p>后面BigData部分，mongodb直接要求写find和insertOne，find有点难因为是在一个list/array里找匹配的object。问题没有根据预测考NoSQL，考的是Volume的内容</p>
<img src="/post/fit9132-db-notes/image-20210219225409532.png" class="" title="image-20210219225409532">

<p>checkpoint也变名词解释Write Through和Deferred Write</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT9137: Arch and Net notes</title>
    <url>/post/fit9137-arch_and_net-notes/</url>
    <content><![CDATA[<p>虽然在定义上是个基础课，但是实际上比国内的大计基深入的不是一点点。如果不是前阵子因为cryptocurrency mining的研究一直都在钻研底层，估计还挺难消化的。即便如此，不仔细的我到现在的quiz还是没能拿到过100……</p>
<span id="more"></span>

<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>w1 到 w3 是非常快速且底层的计算机（与系统）架构介绍。</p>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>w4 开始讲的就是Netowork的内容，直到w12，所以可以认为是整个课其实重点就在这里……</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>网络的基本组成部分：Client，Sever，Router，Comm-Links（inter-connects network devices，换句话说就是medium）</p>
<p>网络的形式（规模）：LAN（本地网络），BN（主干网），MAN（城域网），WAN（广域网）</p>
<p>还有个大一统的Internet</p>
<h4 id="消息的传输"><a href="#消息的传输" class="headerlink" title="消息的传输"></a>消息的传输</h4><p>基于包交换的网络： 消息被分割为多个包packets</p>
<h5 id="传输速率："><a href="#传输速率：" class="headerlink" title="传输速率："></a>传输速率：</h5><p>home2ISP: 1Mbps</p>
<p>home2home: 10-20Mbps</p>
<p>WLAN: 50-500Mbps</p>
<p>LAN: 1Gbps</p>
<p>BN: 10Gbps</p>
<p>光纤: Tbps</p>
<h5 id="层级（Layers）与协议（Protocols）"><a href="#层级（Layers）与协议（Protocols）" class="headerlink" title="层级（Layers）与协议（Protocols）"></a>层级（Layers）与协议（Protocols）</h5><p>TCP/IP模型</p>
<table>
<thead>
<tr>
<th>Layers</th>
</tr>
</thead>
<tbody><tr>
<td>5. Application (App)</td>
</tr>
<tr>
<td>4. Transport (Logical conn)</td>
</tr>
<tr>
<td>3. Network (Routing)</td>
</tr>
<tr>
<td>2. Datalink (Low-level conn)</td>
</tr>
<tr>
<td>1. Physical (Hardware)</td>
</tr>
</tbody></table>
<p>Switch: 1+2</p>
<p>Router: 1+2+3</p>
<p>Protocol Data Unit (PDU): </p>
<ol start="5">
<li><p>Message (HTTP)</p>
</li>
<li><p>Segment (TCP)</p>
</li>
<li><p>Packet (IP)</p>
</li>
<li><p>Frame (Ethernet)</p>
</li>
<li><p>Bit</p>
</li>
</ol>
<p>每一层都对数据会进行调制/解调（en/decapsulate），就类似tcp conn里套socks5再套ss/ssr一样</p>
<p>模块化设计</p>
<p>优秀的协议栈有三种特征：</p>
<p>低耦合（Low Coupling）高聚合（High Cohesive）无信息（Information Hiding）</p>
<h3 id="Physical-DataLink-Layer"><a href="#Physical-DataLink-Layer" class="headerlink" title="Physical/DataLink Layer"></a>Physical/DataLink Layer</h3><p>Intro</p>
<p>物理层：直接连接设备</p>
<p>数据链接层：管理俩设备间的物理连接</p>
<p>物理层：主要焦点于如何将bits转换为信号以及转回bits</p>
<p>数据链接层：</p>
<ul>
<li>Media Access Control：在设备发送时控制</li>
<li>Error Control：确保数据正确到达</li>
<li>Protocols：同步与异步传输</li>
<li>Transmission Efficiency：消息长度vs错误率</li>
</ul>
<h5 id="数字信号与模拟信号"><a href="#数字信号与模拟信号" class="headerlink" title="数字信号与模拟信号"></a>数字信号与模拟信号</h5><p>老古董POTS: Plain Old Telephone Service</p>
<ul>
<li><p>语音在电话之间传递</p>
</li>
<li><p>声音（模拟）转换成电波（麦克风）</p>
</li>
<li><p>电波通过铜线传播</p>
</li>
<li><p>电波（扬声器）转回声音</p>
</li>
</ul>
<p>通过使用Modem来将数字信号转换成模拟信号</p>
<p>Modem（<strong>Mo</strong>dulator/<strong>Dem</strong>odulator）</p>
<p>这里我们都使用正弦（sin）波。y = A * sin(f*2πX+φ) 波具有三个属性：</p>
<ul>
<li>振幅A</li>
<li>频率f</li>
<li>相位φ</li>
</ul>
<h3 id="数据链接层"><a href="#数据链接层" class="headerlink" title="数据链接层"></a>数据链接层</h3><p>两个子层</p>
<h4 id="逻辑链接控制（LLC）"><a href="#逻辑链接控制（LLC）" class="headerlink" title="逻辑链接控制（LLC）"></a>逻辑链接控制（LLC）</h4><ul>
<li>处理PDU头</li>
<li>错误控制</li>
<li>定义与网络层的接口</li>
</ul>
<h4 id="媒体访问控制（MAC）"><a href="#媒体访问控制（MAC）" class="headerlink" title="媒体访问控制（MAC）"></a>媒体访问控制（MAC）</h4><ul>
<li>在与物理层符号和frame之间编码/解码</li>
<li>错误检测</li>
<li>当设备传输时控制</li>
</ul>
<p>[WIP]</p>
<h3 id="LAN-amp-WLAN"><a href="#LAN-amp-WLAN" class="headerlink" title="LAN &amp; WLAN"></a>LAN &amp; WLAN</h3><p>Why use a LAN</p>
<p>信息共享（文件，数据库，email等交流），资源共享（打印机等硬件，软件授权，公网连接）</p>
<h4 id="LAN的类型"><a href="#LAN的类型" class="headerlink" title="LAN的类型"></a>LAN的类型</h4><p>专用服务器LAN</p>
<ul>
<li><p>网络包含服务器和客户端</p>
</li>
<li><p>每个服务器有一个或多个<strong>特定任务</strong>（e.g. DHCP，email…）</p>
</li>
<li><p>是<strong>最流行</strong>的企业网络</p>
</li>
</ul>
<p>P2P LAN（例如家庭LAN，更便宜但性能更差）</p>
<ul>
<li><p>无专用服务器</p>
</li>
<li><p>所有的计算机都作为服务端也作为客户端</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>专用服务器LAN</th>
<th>P2P LAN</th>
</tr>
</thead>
<tbody><tr>
<td>成本</td>
<td>贵（需要更多硬件）</td>
<td>便宜（重用存在的硬件）</td>
</tr>
<tr>
<td>性能</td>
<td>很高，可拓展</td>
<td>第，不太能拓展</td>
</tr>
<tr>
<td>可靠性</td>
<td>很高（企业级组件）</td>
<td>低</td>
</tr>
<tr>
<td>管理</td>
<td>更简单（中心化）</td>
<td>更困难</td>
</tr>
</tbody></table>
<h4 id="基础LAN组件"><a href="#基础LAN组件" class="headerlink" title="基础LAN组件"></a>基础LAN组件</h4><p>NOS（Network Operating System）</p>
<p>NIC（Network Interface Card）网卡</p>
<p>Switch</p>
<p>Cable</p>
<p>Client，Server</p>
<h5 id="NIC网卡"><a href="#NIC网卡" class="headerlink" title="NIC网卡"></a>NIC网卡</h5><p>实现了物理层与数据链接层</p>
<ul>
<li><p>包括独一无二的数据链接层地址（MAC Address）</p>
</li>
<li><p>提供到网络的物理连接（socket插座或antenna天线）</p>
</li>
<li><p>实现了协议（错误检测，frame构建，调制解调等等）</p>
</li>
</ul>
<p>连接到电脑</p>
<ul>
<li>通常内置于主板</li>
<li>或者通过USB/PCI-Express等接口连接</li>
</ul>
<h5 id="Network-Cables网线"><a href="#Network-Cables网线" class="headerlink" title="Network Cables网线"></a>Network Cables网线</h5><p>网络设备间的物理连接</p>
<p>不同的类别：</p>
<ul>
<li><p>UTP （LAN最常用类型）</p>
</li>
<li><p>STP （防护双绞线）</p>
</li>
<li><p>光纤 （当前LAN不常用）</p>
</li>
<li><p>同轴线 （只有老LAN在用）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>品名</th>
<th>数据速率</th>
<th>网线</th>
</tr>
</thead>
<tbody><tr>
<td>10BASE-T</td>
<td>10Mbps</td>
<td>UTP cat3 / cat5，三类线五类线</td>
</tr>
<tr>
<td>100BASE-T</td>
<td>100Mbps</td>
<td>UTP cat5</td>
</tr>
<tr>
<td>1000BASE-T</td>
<td>1Gbps</td>
<td>UTP 5e，6 &lt;-现在常用</td>
</tr>
<tr>
<td>1000BASE-X</td>
<td>1Gbps</td>
<td>光纤 （单模式或多模式）</td>
</tr>
<tr>
<td>10GbE</td>
<td>10Gbps</td>
<td>UTP cat6，ca7，光纤</td>
</tr>
<tr>
<td>40GbE/100GbE</td>
<td>40Gbps/100Gbps</td>
<td>光纤</td>
</tr>
</tbody></table>
<h5 id="NOS网络操作系统"><a href="#NOS网络操作系统" class="headerlink" title="NOS网络操作系统"></a>NOS网络操作系统</h5><p>用来访问与控制LAN的软件</p>
<ul>
<li>服务端NOS提供网络管理工具与网络服务</li>
<li>客户端NOS提供访问网络服务的方式</li>
</ul>
<p>由服务端NOS提供的服务</p>
<ul>
<li>文件夹服务</li>
<li>网络与用户描述</li>
<li>文件，web，打印，email服务器等等</li>
</ul>
<p>NOS服务端软件</p>
<p>处理网络功能</p>
<ul>
<li>全协议栈（数据链接，网络，传输，应用层）</li>
<li>包括应用软件如HTTP，FTP，SMTP，DHCP，LDAP，DHCP，DNS，SQL…</li>
</ul>
<p>替代或加强普通操作系统</p>
<ul>
<li>可以得到服务器性能上的优化而非用户程序</li>
</ul>
<p>例如</p>
<ul>
<li>Linux</li>
<li>Microsoft Windows Server</li>
</ul>
<p>NOS客户端软件</p>
<p>处理网络连接</p>
<ul>
<li>数据连接层，网络层，传输层</li>
<li>和应用层交互</li>
<li>曾经是分离的系统</li>
<li>现在被整合进了所有的主流操作系统</li>
</ul>
<p>客户端现在可以查阅与获取网络资源</p>
<ul>
<li>现在客户端可用的服务</li>
</ul>
<h3 id="以太网，集线器与交换机"><a href="#以太网，集线器与交换机" class="headerlink" title="以太网，集线器与交换机"></a>以太网，集线器与交换机</h3><p>主流LAN技术</p>
<ul>
<li>标准化如IEEE802.3</li>
<li>被几乎所有LAN使用</li>
<li>1973年开发，1980年被标准化</li>
</ul>
<p>物理层</p>
<ul>
<li>起初是基于共享媒介的同轴电缆，10Mbps</li>
<li>现在大多转换成了基于UTP的100Mbps或1Gbps网络</li>
<li>光纤的标准能最高100Gbps</li>
</ul>
<p>以太网<br>拓扑结构：</p>
<ol>
<li>共享线路</li>
<li>星状（P2P）</li>
<li>多hub设计</li>
</ol>
<p>以太网MAC（扼要重述）</p>
<p>基于意图的媒体获取</p>
<ul>
<li>设备间资源获取上的竞争</li>
<li>如果设备同时发送frame会发生冲突</li>
</ul>
<p>冲突</p>
<ul>
<li>没有被避免，但是可容忍可检测</li>
<li>在小型和中型网络里非常高效</li>
</ul>
<p>媒体获取控制（Media Access Control）：CSMA/CD</p>
<ul>
<li>事件感知（CS）：在线路上侦听，只在没有其他型号被感知时传输</li>
<li>多重获取（MA）：多个设备访问同一个介质</li>
<li>冲突检测（CD）：当非己信号被检测到<br>传输拥挤信号（因此所有其他设备检测冲突）<br>都在重新发送前等待随机时间</li>
</ul>
<p>共享以太网中的问题<br>半双向：同一时间只有一个设备能够发送</p>
<h2 id="W8"><a href="#W8" class="headerlink" title="W8"></a>W8</h2><p>又到了不温习就不会做作业的地步了……</p>
<p>网络层： Routing</p>
<p>A router is a layer 3 device</p>
<ul>
<li><p>one IP address per interface, i.e. typically per subnet it is connected to</p>
</li>
<li><p>Clients send packets to routers if destination is outside their own subnet</p>
</li>
<li><p>Routers use IP address to determine over where the packet is sent next</p>
</li>
</ul>
<p>For each incoming packet, the router</p>
<ul>
<li>looks at the packet’s destination IP<br>address</li>
<li>consults the routing table:<br><em>to which other router should I send a packet for this destination, or can I deliver it directly?</em></li>
<li>if destination not in table: send to default gateway</li>
<li>if no default gateway configured: packet can’t be routed</li>
</ul>
<p>Three components:</p>
<ul>
<li>The routing protocol:<br>how to find the best route between a sender and a receiver through the network</li>
<li>The routing table:<br>the best routes currently known are stored in a lookup table for fast access</li>
<li>The routing decisions:<br>deciding for each incoming packet where it is sent next</li>
</ul>
<p>Types of routing</p>
<ol>
<li>Centralized<ul>
<li>All clients connect to central computer, which makes the routing decisions</li>
<li>Used on small, host-based networks</li>
</ul>
</li>
<li>Decentralized<ul>
<li>Each device makes its own decisions</li>
<li>Information needs to be exchanged to prepare routing tables</li>
<li>Used on the Internet</li>
</ul>
</li>
</ol>
<p>Decentralized routing:</p>
<p>Static routing:</p>
<ul>
<li>Network manager prepares <strong>fixed routing tables</strong></li>
<li>Manually updated when the network changes</li>
<li>Used in simple networks that don’t change a lot</li>
</ul>
<h2 id="IP-subnets"><a href="#IP-subnets" class="headerlink" title="IP subnets"></a>IP subnets</h2><p>mask 计算方式就是bin对比，比如/20表示<code>&quot;1&quot;*20+&quot;0&quot;*(32-20)</code>，mask则是取ip（每个数字分开LE encode，从右往左写）与这个的&amp;值（即上下都是1就取1否则0）</p>
<p>要看清楚到底是ip还是mask。X.X.0.0这种就是mask，因为可以作为一个subnet的Network(gateway) address。作为mask的ip可能不带<code>/20</code>这样的后缀（因为人家能表达了）</p>
<p>X.X.X.X(/XX)在mask /XX（或者X.X.X.X）有几个subnet？先算前面那个的<code>/XX</code>比如20。再算后面那个的那比如24。那么subnet个数就是2^(24-20) = 16个。每个subnet里的ip数就是2^(32-24)=256，其中host ip数就是256-2 = 254</p>
<h2 id="错题集！"><a href="#错题集！" class="headerlink" title="错题集！"></a>错题集！</h2><blockquote>
<p>Q: An access point ensures that all computers within range of the access point can communicate with each other</p>
<p>A: T</p>
</blockquote>
<p>做的时候选了F，想的是没准就有内网隔离你访问个锤子。看到答案可能应该是想表达在一个LAN的意思。</p>
<blockquote>
<p>Q: IPv6 is backwards compatible with IPv4.</p>
<p>A: F</p>
</blockquote>
<p>做的时候以为是v6兼容不兼容v4，那肯定兼容啊。2002就是划给v4的（<a href="https://en.wikipedia.org/wiki/6to4" target="_blank" rel="noopener">6to4</a>）。直到看到答案才意识到问题意思应该是<strong>直接兼容</strong>。6to4毕竟是走了个转换通道的。而且google之后有明确答案。</p>
<blockquote>
<p>Q: What is the main advantage of fibre-optic cables over copper cables?</p>
<p>Select one:</p>
<p>a. Higher latency</p>
<p>b. All of the other answers</p>
<p>c. Cheaper</p>
<p>d. Lower resistance</p>
<p>e. Much faster data rates</p>
<p>A: e</p>
</blockquote>
<p>本来想想光纤无敌无脑选b。现在想想应该是铜在工艺和成本上来说是更便宜的，latency的话查了是copper更快（<a href="https://www.arista.com/assets/data/pdf/Copper-Faster-Than-Fiber-Brief.pdf" target="_blank" rel="noopener">This is close to the oft-quoted <strong>5 ns</strong> per meter for <strong>fiber</strong>. The <strong>latency</strong> for the twinax <strong>copper</strong> cables shown is <strong>4.60</strong> ns per meter</a>）</p>
<blockquote>
<p>An advantage of centralized routing is:</p>
<p>Select one:</p>
<p>a. routing does reflect changing network conditions, such as computers that are overloaded by many messages</p>
<p>b. if anything happens to the computer developing the routing table, the routing tables cannot be changed until that computer is fixed, or until a new computer is selected to perform the function</p>
<p>c. it requires more processing by each computer or router in the network than dynamic routing</p>
<p>d. the routing tables are stored at all computers in the network</p>
<p>e. routing decisions are simple</p>
<p>A: e</p>
</blockquote>
<p>不懂，背一下吧</p>
<blockquote>
<p>How can a set of 802.11b access points be configured to operate without interference?</p>
<p>Select one:</p>
<p>a. assign the same channel to no more than two access points</p>
<p>b. assigning each access point a different channel to communicate with clients</p>
<p>c. none of the above</p>
<p>d. separate each access point by more than 10 meters</p>
<p>e. use omnidirectional antennas on some access points and directional on others.</p>
<p>A: b</p>
</blockquote>
<p>很果断地选c，因为觉得肯定得首先不一样其次要1，6，11三个选。答案b其实就是不一样的意思，1，6，11应该只是最优情况。</p>
<p><a href="http://www.wireless-nets.com/resources/tutorials/assign_ap_channels.html" target="_blank" rel="noopener">http://www.wireless-nets.com/resources/tutorials/assign_ap_channels.html</a></p>
<blockquote>
<p>_____ indicates what resources on each server are available on the network for use by other computers and what people are allowed what access to the network.</p>
<p>Select one:</p>
<p>a. server allocation list</p>
<p>b. network profile</p>
<p>c. network operating system</p>
<p>d. user access log</p>
<p>e. user profile</p>
<p>A: e</p>
</blockquote>
<p>完全不记得啥时候讲了user profile。用Acrobat搜了一下在W6（LAN&amp;WAN）。</p>
<p>就user profile是一个Server NOS（Network OS）的一个service</p>
<p>总的来说就这几个</p>
<ul>
<li>directory service</li>
<li>network &amp; user profiles</li>
<li>file, web, print, email server etc</li>
</ul>
<p>然而后面就没具体介绍了……这题就当介绍一下（别的几个知道的</p>
<blockquote>
<p>How many bits are required to sample an incoming signal 4000 times per second using 64 different amplitude levels?</p>
<p>A: 6</p>
</blockquote>
<p>写了是64的我一脸懵逼。现在来复盘一下。先用Acrobat定位了一下知识点在W6。$s(t) = A sin(2\pi ft + \phi)$。这里$f$已经确定了是个常量<em>4000 times per second</em>，$\phi$没提到，变的应该只有A，有64个不同的值。<del>首先已知了我们64错了。</del></p>
<img src="/post/fit9137-arch_and_net-notes/image-20210212012622535.png" class="" title="image-20210212012622535">

<p>题目说了有64个amplitude的值，另外求的是可以代表bit的数量。意思应该就是64个值可以用几个bit概括？一个bit可以表示0，1。两个就是00，01，10，11四个，以此类推就是n个bit代表$2^n$个。$64 = 2^6$。所以是6。（要注意审题啊完全没意识到是bit）</p>
<blockquote>
<p>Which of the following is <strong>not</strong> a controlled access method of media access control?</p>
<p>Select one:</p>
<p>a. CSMA/CD</p>
<p>b. hub polling</p>
<p>c. roll call polling</p>
<p>d. Token passing</p>
<p>e. polling</p>
<p>A: a. CSMA/CD</p>
</blockquote>
<p>相关知识忘得差不多了，只记得CSMA/CD是和Media有关的。CSMA/CD也是W6（LAN&amp;WLAN）的内容。</p>
<p>CSMA/CD是一个Media Access Control。</p>
<ul>
<li>Carrier Sense (CS):<br>listen on bus, only transmit if no other signal is “sensed”</li>
<li>Multiple Access (MA):<br>several devices access the same medium</li>
<li>Collision Detection (CD):<br>when signal other than own is detected:<ul>
<li>transmit jam signal (so all other devices detect collision)</li>
<li>both wait random time before re-transmitting</li>
</ul>
</li>
</ul>
<p>CSMA/CD limits size of collision domain</p>
<p>而那些Polling是W5（Physical &amp; DataLink Layer）的内容。</p>
<ol>
<li>Roll Call Polling （类hub）</li>
<li> Hub Polling / Token Passing （P2P）</li>
</ol>
<p>人家都叫Controlled Access。</p>
<blockquote>
<p>Errors normally appear in ？？？, which is when more than one data bit is changed by the error-causing condition.</p>
<p>A: burst</p>
</blockquote>
<p>我tm写的DataLink Layer……找了一圈也没看见这个in burst的说法，背一下吧</p>
<blockquote>
<p>_____ controls errors by detecting and correcting them at the receiving end without retransmission of the original message.</p>
<p>Select one:</p>
<p>a. Hamming code</p>
<p>b. Wave division multiplexing</p>
<p>c. Huffman encoding</p>
<p>d. Hub polling</p>
<p>e. Front end processing</p>
<p>A: Hamming code</p>
</blockquote>
<p>Hamming code出现在W5（Phy&amp;DL Layer）的Forward Error Correction的example里。example分别为</p>
<ul>
<li>Hamming code 汉明码 (used e.g. in error correcting memory)</li>
<li>Reed-Solomon codes  里德-所罗门码 (CDs, DVDs, Blue-ray, QR Codes, Digital TV broadcast, DSL)</li>
</ul>
<p>其他的Wave division multiplexing没找到，但是multiplex应该是多路复用和error关系不大</p>
<p>Huffman encoding没找到</p>
<p>Hub polling前面说了是个Controlled Access</p>
<p>Front end processing前端处理？听着就不靠谱，也没找到。</p>
<blockquote>
<p>In ARQ, a NAK:</p>
<p>Select one:</p>
<p>a. is sent by the sender at the same time as it sends a data packet</p>
<p>b. refers to non-asynchronous Kermit technique</p>
<p>c. means that the sender should continue with sending the next message</p>
<p>d. is sent by the recipient if the message contains an error</p>
<p>e. is sent by the recipient if the message was received without error</p>
<p>A: d</p>
</blockquote>
<p>ARQ（包括NAK）也在W5.</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210212020517127.png" class="" title="image-20210212020517127">

<img src="/post/fit9137-arch_and_net-notes/image-20210212020527545.png" class="" title="image-20210212020527545">

<p><strong>acknowledgement</strong> (<strong>ACK</strong>) <strong>negative-acknowledgement</strong> (<strong>NAK</strong> or <strong>NACK</strong>)</p>
<p>这里干脆吧<a href="https://en.wikipedia.org/wiki/Automatic_repeat_request" target="_blank" rel="noopener">ARQ（Automatic Repeat Request/automatic repeat query)</a>也看掉。ARQ是一种用于数据传输的错误控制方法，它使用确认（接收方发送的消息，表明它已正确接收到一个数据包）和超时（在接收确认之前经过了指定的时间段）来实现可靠的数据传输 通过不可靠的通信渠道。 如果发送方在超时之前未收到确认，则通常会重新传输数据包，直到发送方收到确认或超过预定义的重传次数为止。（就等于是一直ping你直到ping通或者次数到</p>
<blockquote>
<p>A _____ is a user’s connection into a packet switched service.</p>
<p>Select one:</p>
<p>a. packet asynchronous/discrete device</p>
<p>b. packet asymmetric/data transmission device</p>
<p>c. packet analyzer/decoder device</p>
<p>d. packet assembly/disassembly device</p>
<p>e. packet analog/digital device</p>
<p>A: d. packet assembly/disassembly device</p>
</blockquote>
<p>W11(Backbones MAN WAN)里WAN Packet Switched Services讲到的packet assembly/disassembly （简称PAD）。如图，背一背吧</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210212021401150.png" class="" title="image-20210212021401150">





<blockquote>
<p>_____ refers to changing the shape of a wave in different ways to represent a 1 or a 0.</p>
<p>Select one:</p>
<p>a. demodulation</p>
<p>b. modulation</p>
<p>c. digitizing.</p>
<p>d. sampling</p>
<p>e. shaping</p>
<p>A: a. demodulation</p>
</blockquote>
<p>脑补的是调制解调器，网线（01）到电话线（wave）是调制，回来解调。这里要求的是wave → 01所以是解调。（看反了</p>
<blockquote>
<p>Web-based e-mail like Hotmail is an example of three-tier client-server architecture that provides access to e-mail messages.</p>
<p>A: T</p>
</blockquote>
<p>想的是B/S，通过<em>three-tier client-server architecture</em>关键词查了下看见<a href="https://en.wikipedia.org/wiki/Multitier_architecture#Three-tier_architecture" target="_blank" rel="noopener">Wikipedia</a>里说: <em>In the <a href="https://en.wikipedia.org/wiki/Web_development" target="_blank" rel="noopener">web development</a> field, three-tier is often used to refer to <a href="https://en.wikipedia.org/wiki/Website" target="_blank" rel="noopener">websites</a>, commonly <a href="https://en.wikipedia.org/wiki/Electronic_commerce" target="_blank" rel="noopener">electronic commerce</a> websites</em></p>
<blockquote>
<p>In unix or Linux Operating System, the most common types of files are ____________.</p>
<p>Select one:</p>
<p>a. device file</p>
<p>b. directory file</p>
<p>c. ordinary file and directory file</p>
<p>d. ordinary file</p>
<p>A: d. ordinary file</p>
</blockquote>
<p>错两次了不应该</p>
<blockquote>
<p>Which of the following technique is used for encapsulation?</p>
<p>Select one:</p>
<p>a. one of the pieces that results when an IP gateway divides an IP datagram into smaller pieces for transmission across a network that cannot handle the original datagram size</p>
<p>b. the technique used by protocols in which a lower level protocol accepts a message from a higher level protocol and places it in the data portion of the low level frame</p>
<p>c. the technique used in best-effort delivery systems to avoid endlessly looping packets</p>
<p>d. all of these options</p>
<p>A: b</p>
</blockquote>
<p>encapsulation封装的定义</p>
<blockquote>
<p>In which type of routing do computers or routers count the number of hops along a route and periodically exchange information on the hop count with their neighbors?</p>
<p>Select one:</p>
<p>a. circuitous</p>
<p>b. decentralized</p>
<p>c. distance vector</p>
<p>d. link state</p>
<p>e. indirect</p>
<p>A: distance vector</p>
</blockquote>
<p>W8 Routing的内容</p>
<p>Distance vector 交换目的地距离，选择最短路径（RIP (Routing Information Protocol) BGP(Border Gateway Protocol)）</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210224213438907.png" class="" title="image-20210224213438907">

<p>link state 交换链接质量消息，选最快路径（OSPF）</p>
<p>别的都没出现。</p>
<blockquote>
<p>An exception condition in a computer system caused by an event external to the CPU is known as?</p>
<p>Select one:</p>
<p>a. Halt</p>
<p>b. Process</p>
<p>c. Interrupt</p>
<p>d. None of above</p>
<p>A: c</p>
</blockquote>
<p>Halt虽然也是停，但真没东西叫这个</p>
<blockquote>
<p>An interrupt is a signal to the processor to suspend its current tasks and deal with whatever caused the interrupt. Which of the following method cannot be classified as Interrupts?</p>
<p>Select one:</p>
<p>a. Program/Software triggered</p>
<p>b. Timer triggered</p>
<p>c. I/O operation triggered</p>
<p>d. Other Hardware triggered</p>
<p>e. Page fault triggered</p>
<p>A: e</p>
</blockquote>
<img src="/post/fit9137-arch_and_net-notes/image-20210224214502048.png" class="" title="image-20210224214502048">

<p>PageFault是后面（内存）才出现的</p>
<blockquote>
<p>A solution to resolve the problem of external fragmentation is to _________________</p>
<p>Select one:</p>
<p>a. permit the logical address space of a process to be non contiguous</p>
<p>b. permit smaller processes to be allocated memory at last</p>
<p>c. permit larger processes to be allocated memory at last</p>
<p>d. All of these options</p>
<p>A: a</p>
</blockquote>
<img src="/post/fit9137-arch_and_net-notes/image-20210224214748781.png" class="" title="image-20210224214748781">

<p>解决方案：paging</p>
<blockquote>
<p>For purposes of routing, the Internet is divided into ___________.</p>
<p>Select one:</p>
<p>a. wide area networks</p>
<p>b. autonomous networks</p>
<p>c. autonomous systems</p>
<p>d. none of these options</p>
<p>A:  c. autonomous systems</p>
</blockquote>
<p>W8的内容，自治系统（差不多就ISP的网）</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210224215420764.png" class="" title="image-20210224215420764">



<blockquote>
<p>In 802.3, the address consisting of all 1 bits is reserved for ___________________.</p>
<p>Select one:</p>
<p>a. Unicast</p>
<p>b. Multicast</p>
<p>c. Broadcast</p>
<p>d. Ordinary</p>
<p>A: c. Broadcast</p>
</blockquote>
<p>802.3是以太网的协议。从Ethernet Frame里根本没找到这个……背吧</p>
<blockquote>
<p>In IEEE802.11, the addressing machanism can include upto ________________ addresses.</p>
<p>Select one:</p>
<p>a. four</p>
<p>b. five</p>
<p>c. six</p>
<p>d. none of these options</p>
<p>A: a. four</p>
</blockquote>
<p>IEEE802.11 是WLAN的协议。</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210224220918086.png" class="" title="image-20210224220918086">

<blockquote>
<p>OC-3072 has a data rate of</p>
<p>Select one:</p>
<p>a. 1.244 Gbps</p>
<p>b. 159.25 Gbps</p>
<p>c. 39.813 Gbps</p>
<p>d. 1.544 Mbps</p>
<p>e. 100 Mbps</p>
</blockquote>
<p>OC-X = X * 51.84 Mbps</p>
<blockquote>
<p>Both the _____ layer perform error checking.</p>
<p>Select one:</p>
<p>a. presentation and transport</p>
<p>b. application and presentation</p>
<p>c. transport and data link</p>
<p>d. physical and data link</p>
<p>e. network and physical</p>
<p>A: c. transport and data link</p>
</blockquote>
<blockquote>
<p>_____ is a line-of-sight type of wireless media.</p>
<p>Select one:</p>
<p>a. microwave</p>
<p>b. radio</p>
<p>c. twisted pair</p>
<p>d. coaxial cable</p>
<p>e.  fiber optic</p>
<p>A: microwave</p>
</blockquote>
<img src="/post/fit9137-arch_and_net-notes/image-20210224225948321.png" class="" title="image-20210224225948321">

<p>直接拿来覆盖范围的，就好像学校到处有的校园网</p>
<blockquote>
<p>Which of the following is not true about CSMA/CD?</p>
<p>Select one:</p>
<p>a. It is used in token ring protocol LANs</p>
<p>b. It is a contention-based media access control technique</p>
<p>c. When a collision has occurred, the computers that wish to transmit wait a random amount of time after a colliding message before attempting to retransmit</p>
<p>d. Computers on the circuit ‘listen’ before transmitting</p>
<p>e. The acronym refers to Carrier Sense Multiple Access with Collision Detection</p>
<p>A: a. It is used in token ring protocol LANs</p>
</blockquote>
<p>CSMA/CD是W6 Ethernet内容</p>
<p>前面只有hub，hub的逻辑拓扑是shared bus，物理拓扑是star</p>
<blockquote>
<p>The probability of detecting an error, provided that one has occurred, using cyclic redundancy checking is about</p>
<p>Select one:</p>
<p>a. &gt;99%</p>
<p>b. 75%</p>
<p>c. 0%</p>
<p>d. 50%</p>
<p>e. exactly 100%</p>
<p>A: a. &gt;99%</p>
</blockquote>
<p>cyclic redundancy checking 就是CRC。W5里的。</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210224232144187.png" class="" title="image-20210224232144187">

<p>所以就相当于$ 99% &lt; \frac{\infin-1}{\infin} &lt; 100% $</p>
<p>Breaking a network into smaller parts is called  Network Segmentation  -&gt; W6</p>
<p>dynamic routing -&gt; W8</p>
<p>drawback: The transmission of status information “wastes” network capacity that could be used to send user messages</p>
<p>Many organizations today are installing traditional wired Ethernet for desktop users and install Wi-Fi as <strong>overlay networks</strong></p>
<p>Layer-2地址：L2即DL层，真实网卡MAC地址</p>
<p>Layer-3：L3即Net层，logical address，arp得到L2</p>
<p>802.11b?</p>
<p>802.11g?</p>
<p>802.3</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>architecture</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>LELTS Notes</title>
    <url>/post/ielts-notes/</url>
    <content><![CDATA[<p>雅思笔记</p>
<span id="more"></span>

<h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><h2 id="题目对应文章内容顺序"><a href="#题目对应文章内容顺序" class="headerlink" title="题目对应文章内容顺序"></a>题目对应文章内容顺序</h2><table>
<thead>
<tr>
<th>题型</th>
<th>顺序？</th>
</tr>
</thead>
<tbody><tr>
<td>选择</td>
<td>顺序</td>
</tr>
<tr>
<td>填空（段落概括）</td>
<td>个别答案乱序</td>
</tr>
<tr>
<td>填空（其他）</td>
<td>简答，句子填卡，表格填卡，笔记填空，流程图填空，示意图填空均顺序</td>
</tr>
<tr>
<td>配对</td>
<td>乱序</td>
</tr>
<tr>
<td>总体</td>
<td>跨题型不一定顺序</td>
</tr>
</tbody></table>
<h1 id="L-听力"><a href="#L-听力" class="headerlink" title="L: 听力"></a>L: 听力</h1><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><p>考试时间30min+10填卡，共4*10问</p>
<p>题型</p>
<ul>
<li>信息表题</li>
<li>分类比较表</li>
<li>笔记填空</li>
<li>单句填空</li>
<li>简答填空</li>
<li>分类配对</li>
<li>单选多选</li>
<li>(地图流程)</li>
</ul>
<table>
<thead>
<tr>
<th>场景</th>
<th>要点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>租房住宿</strong></td>
<td>房价水电煤价(数字)，地理位置，家具，花园，车库，厨房设施</td>
</tr>
<tr>
<td><strong>旅行</strong></td>
<td>度假地，娱乐内容，交通工具，住处，人数，价格，预定机票房价(细节)</td>
</tr>
<tr>
<td>购物</td>
<td>优缺点，价格，个人信息，专家意见</td>
</tr>
<tr>
<td>地理</td>
<td>地点，人名，气候，语言，当地主要产业，主要景点，优缺点</td>
</tr>
<tr>
<td>图书馆</td>
<td>办证所需材料，使用须知等</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>题号</th>
<th>场景类别</th>
</tr>
</thead>
<tbody><tr>
<td>L1</td>
<td>日常活动</td>
</tr>
<tr>
<td>L2</td>
<td>新生入学</td>
</tr>
<tr>
<td>L3</td>
<td>选课，论文研究</td>
</tr>
<tr>
<td>L4</td>
<td>学术讲座: 野生动物，地理</td>
</tr>
</tbody></table>
<h3 id="信息表"><a href="#信息表" class="headerlink" title="信息表"></a>信息表</h3><h4 id="人名"><a href="#人名" class="headerlink" title="人名"></a>人名</h4><ol>
<li>拼写</li>
</ol>
<ul>
<li>大小写</li>
<li>辨析l/o m/n t/s a/i/r</li>
<li>fullname (first-last, given-family, fore-sur)</li>
</ul>
<ol start="2">
<li>名字格式</li>
</ol>
<p>Title: Mr./Mrs./Miss/ Ms.(发音类Mizi)/Dr./Prof. + 姓氏</p>
<ol start="3">
<li>常见名字</li>
</ol>
<p>默认考生会写</p>
<p>Kevin, Helen, Mike, John, Lee</p>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><ul>
<li><strong>英式</strong>: DD/MM/YY =&gt; 8th March, 2004</li>
<li>美式: MM/DD/YY =&gt; March 8th, 2004</li>
</ul>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>纯数字:</p>
<ul>
<li>Telephone number</li>
<li>Fax number </li>
<li>Account number</li>
<li>Credit card number</li>
</ul>
<p>数字字母组合:</p>
<ul>
<li>Driver’s license number</li>
<li>Passport number</li>
<li>Flight number</li>
<li>Membership number</li>
<li>Student ID number</li>
<li>Postcode</li>
</ul>
<p>Tricks:<br>| 情况 | 方法 |<br>|–|–|<br>| 两个或三个数字重复 | double/triple |<br>| 0 | o, zero, nought/naught |<br>| 18003456000 | 800 =&gt; eight hundred, 6000 =&gt; six thousand, 其他逐个 |<br>| 电话 | 出现area code或country code必须加上 |</p>
<h4 id="国籍"><a href="#国籍" class="headerlink" title="国籍"></a>国籍</h4><p>必须形容词形式 e.g. London =&gt; British |</p>
<h4 id="受教育水平"><a href="#受教育水平" class="headerlink" title="受教育水平"></a>受教育水平</h4><p>Undergraduate =&gt; Postgraduate</p>
<h4 id="教职"><a href="#教职" class="headerlink" title="教职"></a>教职</h4><p>学院: faculty/department</p>
<h4 id="主修"><a href="#主修" class="headerlink" title="主修"></a>主修</h4><p>subject/major</p>
<h3 id="考察频率"><a href="#考察频率" class="headerlink" title="考察频率"></a>考察频率</h3><p>最常: Social/ Environment/ Science</p>
<p>不常: Crime/ Culture/ Language/ Celebrity</p>
<h2 id="分类比较表"><a href="#分类比较表" class="headerlink" title="分类比较表"></a>分类比较表</h2><p>扫描横纵轴=&gt;表格整体内容</p>
<p>听前: 根据已知信息=&gt; 预判缺失信息</p>
<p>听时: =&gt; 定位未知信息 (顺序)</p>
<p>所听即所得。</p>
<p>注意点：</p>
<ul>
<li>题目要求(words&amp;number count)&amp;拼写规律</li>
<li>n. 单复数</li>
<li>v. 时态</li>
<li>adj. 比较级最高级(上下一致)</li>
</ul>
<h2 id="单句填空"><a href="#单句填空" class="headerlink" title="单句填空"></a>单句填空</h2><ol>
<li>获取背景</li>
<li>画出信号词=&gt;预测词性</li>
<li>注意多个信息同时给出情况</li>
<li>注意：<strong>时间， 人名，数字，专有书写</strong></li>
<li>首字母大写</li>
</ol>
<p>信号词后置情况</p>
<ol>
<li>被动 A include B =&gt; B is included in A</li>
<li>形容词结构 Excellent XX =&gt; I thought sth was excellent</li>
<li>介词+n. A+of/for/about/in/on/to+B= B A  e.g. the habit of animals = animals habit</li>
</ol>
<p>aaa’s xxx : aaa有生命</p>
<p>xxx of bbb : bbb无生命</p>
<p>key <strong>to</strong></p>
<p>solution <strong>to</strong> </p>
<ol start="4">
<li>修饰词后置 goods made of aaa &amp; bbb: The tech they introduced meant that <em>metal</em> and <em>leather</em> goods were produced …</li>
<li>位置拆分: xxx is header of ____? A: Yes she is in Computer center B: She is header now.</li>
</ol>
<h2 id="笔记填空"><a href="#笔记填空" class="headerlink" title="笔记填空"></a>笔记填空</h2><p>一般L3，L4，题材为lecture</p>
<p>所听即所得</p>
<p>信号词</p>
<ul>
<li>实词(adj. n. v.) or 其替换词</li>
<li>逻辑关系</li>
<li><strong>转折</strong></li>
<li>顺序，序列</li>
<li>解释</li>
<li>因果</li>
</ul>
<p>and/ in addition/ one more thing/ what’s more/ besides/ either/ also</p>
<p>too/ as well / moreover / together/ further more</p>
<p>for instance/ for example / such as / like = <strong>saying</strong></p>
<p>likewise/ similary</p>
<p>Although/ by(in) contrast/ as a matter of fact/ nevertheless/ instead/ however/ otherwise/ while/ but / despite / on the contrary/ on the other hand / in spite of / whereas</p>
<p>顺序序列:<br>first/ in the first place/ first of all/ to begin with/ previously/ second/ then/ subsequently/ last but not least/ third/ in the middle/ after/ between/ before/ meanwhile/ after/ between/ before/ meanwhile/ until</p>
<p>for a start/ afterward/ finally/ for one thing/ for another</p>
<p>解释强调:<br>That is/ particular/ I mean/ namely/ especially/ actually/ specially/ equally/ in other words/ that is to say/ another way of saying</p>
<p>因果关系-&gt;(果)<br>as a result/ therefore/ so/ for this reason/ consquently/ thus/ because of / for / since</p>
<p>总结<br>as a result in short/ in sum/ on the whole/ in concluction/ in brief/ to conclude/ in a word/ to sum up/ to summarize/ altogether/ finally/ consequently/ thus/ therefore/ overall</p>
<p>预示关键信息到来<br>What I mean is xxx / and I will xxx / before I move on to xxx / no. sorry</p>
<p>场景词(图书馆+论文)</p>
<ul>
<li>questionaire 问卷/调查对象</li>
<li>wording 措辞</li>
<li>response rate 回收率</li>
<li>car park = parking lot = 停车场</li>
<li>respondents 调查对象</li>
</ul>
<p>身体部位:<br>skin/ fur/ feather/ quill/ hair/ wing/ claw/ hoof/ paw/ front feet/ back leg/ muscle/ lip/ membrane(膜)/ beak/ nose hole= nostril/ neck/ back/ skull/ skeleton/ tail/ bladder(膀胱) / scale(鳞片)/ nail </p>
<p>prevent from predator/ prey/ squirrel松鼠/ squid乌贼/ raccoon狸</p>
<p>maintain  the group/unity</p>
<p>camouflage</p>
<p>feed/breed offsprings</p>
<p>move underground</p>
<p>adapt to harsh env</p>
<h3 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h3><p>who/when/where/what/why</p>
<h3 id="分类配对"><a href="#分类配对" class="headerlink" title="分类配对"></a>分类配对</h3><ul>
<li>题干展开</li>
<li>选项展开</li>
</ul>
<p>不要忽略I agree with/ it is the same as …</p>
<h3 id="地图流程题"><a href="#地图流程题" class="headerlink" title="地图流程题"></a>地图流程题</h3><h3 id="单选-多选"><a href="#单选-多选" class="headerlink" title="单选/多选"></a>单选/多选</h3><p>L2/L3</p>
<ul>
<li><strong>补全式选择</strong></li>
<li>问答式选择</li>
</ul>
<p>选项</p>
<ul>
<li>短: 只需比较之间相同与不同之处做纵向扫描</li>
<li>长: 至少把最长选项划出核心词</li>
</ul>
<p>原则<br>顺序: 最后一个往往正确<br>同性相斥: 俩同一概念则都不正确<br>陌生词汇: 陌生词汇往往不是答案<br>绝对性: only must只要注意材料里有没有绝对判断，往往不是答案<br>最近答案: 不要看到选项文字一致就选择，答案往往是同义表达(trap)。</p>
<p>陷阱</p>
<ul>
<li>v. n. 替换</li>
<li>形容词 副词 替换</li>
</ul>
<p>数字替换</p>
<ul>
<li>a quarter = 25% = 1/4 = 15min = 3month</li>
<li>in the 1980s = in the 20th centry</li>
<li>fortnight = 14d = 2week</li>
<li>couple = 2</li>
<li>dozen = 12</li>
<li>decade = 10y</li>
<li>century = 100y</li>
<li>1980s = 1980~1989</li>
</ul>
<p>同义词，同义词组 替换</p>
<ul>
<li>approach =&gt; method</li>
<li>assistance =&gt; help</li>
<li>travel =&gt; goto</li>
<li>A rather than B =&gt; prefer A to B</li>
</ul>
<p>句式转换</p>
<ul>
<li>双重否定 =&gt; 肯定</li>
<li>主动 =&gt; 被动</li>
</ul>
<p>fee =&gt; charge<br>permit =&gt; allow<br>scientist =&gt; reseacher<br>disadv =&gt; downside<br>sign =&gt; dication</p>
<h1 id="S-口语"><a href="#S-口语" class="headerlink" title="S: 口语"></a>S: 口语</h1><h1 id="S1"><a href="#S1" class="headerlink" title="S1"></a>S1</h1><p>It is important to do … for undergraduate</p>
<p>How + adj + 主 + 谓 =&gt; How excited we are</p>
<p>be disappointed <strong>at</strong> </p>
<p>whether to do (or not)</p>
<p>look forwarding to <strong>doing</strong></p>
<p>insist on <strong>doing</strong>/ sth/ one’s doing</p>
<p>He insists on <strong>our</strong> accepting the xxx</p>
<ul>
<li>hear sb. doing</li>
<li>find sb. done</li>
</ul>
<p>sth 介词短语 in order 处于状态</p>
<p>类型</p>
<ul>
<li><strong>喜好</strong></li>
<li><strong>个人习惯</strong></li>
<li><strong>个人偏好</strong></li>
<li>比较</li>
<li>观点</li>
<li>解释</li>
<li>未来计划</li>
<li>大群体问题</li>
<li>问题解决方案</li>
<li>引子（引导）</li>
</ul>
<p>WH: sb. do sth + 人 + 时 + 地 + 目的</p>
<p>I always <strong>go</strong> swimming <strong>when</strong> I have free time <strong>on</strong> local swimming stadium <strong>to</strong> practice my swimming rings</p>
<h3 id="喜好"><a href="#喜好" class="headerlink" title="喜好"></a>喜好</h3><ul>
<li>I like </li>
<li>I’m really into</li>
<li>I’m fond of</li>
<li>I enjoy</li>
</ul>
<p>人的需求(meet)</p>
<ul>
<li>social needs</li>
<li>material/phyical needs</li>
<li>spritual needs</li>
</ul>
<p>套路：</p>
<ol>
<li>Although:</li>
</ol>
<p>[direct answer] + although 反面 + I still like xxx bacause xxx</p>
<ol start="2">
<li>Direct answer + e.g. (swimming) + WH (I always …)</li>
<li>Direct answer (dislike) + 反面opinion + bad experience</li>
</ol>
<h3 id="Usually-通常题"><a href="#Usually-通常题" class="headerlink" title="Usually 通常题"></a>Usually 通常题</h3><p>问法 </p>
<ul>
<li>usually/like to do during xxx</li>
<li>how do you spend during xxx</li>
</ul>
<p>套路</p>
<ol>
<li><p>时间利用型<br>Sometimes WH1; Other times WH2</p>
</li>
<li><p>分类讨论型<br>It depends, if xxx then I will xxxx; but if yyy, then I will yyyy</p>
</li>
</ol>
<h3 id="频率题"><a href="#频率题" class="headerlink" title="频率题"></a>频率题</h3><ul>
<li>low often</li>
<li>everyday</li>
<li>weekly/once a week</li>
<li>annally/once a year</li>
</ul>
<p>套路</p>
<ol>
<li>(经常) I do sth a lot + e.g.(细分种类) + WH</li>
</ol>
<h3 id="个人偏好"><a href="#个人偏好" class="headerlink" title="个人偏好"></a>个人偏好</h3><p>Do you prefer A or B</p>
<p>like A or B</p>
<p>which better A or B</p>
<p>套路:<br>I would prefer A over B because xxxA√ whereas xxxB√ but </p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ol>
<li>A &amp; B difference </li>
</ol>
<p>What are the difference between A &amp; B</p>
<p>please compare A and B</p>
<p>Do you think A &amp; B feel the same about sth</p>
<p>套路<br>Compared to A, B is xxx for example yyy. On the other hand, A is xxx for example yyy (xxx必须为同一点)</p>
<ol start="2">
<li>past/present comperesion</li>
</ol>
<p>difference between sth in past and now</p>
<p>套路<br>In the past, [Topic] was xxx for example , but after a few years, [Topic] started, xxx and now it is xxx</p>
<h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><p>Do you think sth is good / necessary</p>
<p>What is the benefits of sth</p>
<p>Would you say its good for someone to do sth</p>
<p>套路</p>
<ul>
<li>[direct answer] + 正面opinion + although + 反面opinion</li>
<li>[direct answer] + 客观opinion + 个人经历</li>
</ul>
<h3 id="万能观点"><a href="#万能观点" class="headerlink" title="万能观点"></a>万能观点</h3><ol>
<li>便宜</li>
<li>方便</li>
<li>交友 their custom cultures and histories share th same love for xxx</li>
<li>放松 xxx can help me relax and relieve the pressure from work and study (after a day’s hard work) I feel like my fatigue stress and depress are gone.</li>
</ol>
<h3 id="万能句型"><a href="#万能句型" class="headerlink" title="万能句型"></a>万能句型</h3><ol>
<li>xxx can enhance someone’s xxx, becasue …</li>
</ol>
<p>enhance =&gt; cultivate =&gt; develop =&gt; improve =&gt; build up</p>
<p>技能<br>hands on skill/ independent</p>
<p>运动<br>physical ability/ coordination skill</p>
<p>艺术<br>artistic/creativity talent/taste</p>
<p>文艺<br>mental develop/ knowledge of xxx</p>
<p>social skills/ teamwork ability/ sense of responsibility</p>
<ol start="2">
<li><p>xxx keeps someone posted(了解) about the xxx(文化传播类)</p>
</li>
<li><p>xxx helps someone get a better picture of xxx</p>
</li>
<li><p>xxx brings someone sth(convenient/ happiness/ sense of achievement/ relaxation)</p>
</li>
<li><p>xxx is good/bad for someone’s sth(health/ growth/ future development/ career/ studies)</p>
</li>
<li><p>xxx has a positive/negitive influence/effect on xxx</p>
</li>
<li><p>xxx is a good way to express someone’s 某种心情(emotions/ love/ care/ respect/ gratitude(谢意)/ passion)</p>
</li>
<li><p>xxx add spice(给生活加乐趣) to someone’s life</p>
</li>
<li><p>xxx is a necessary part of life</p>
</li>
<li><p>xxx can fulfill people’s 某需求(spirtual/material/physical/social/curiosity needs)</p>
</li>
</ol>
<h3 id="人物类"><a href="#人物类" class="headerlink" title="人物类"></a>人物类</h3><ol>
<li><p>家人/老师 某次没考好=&gt; frustrated =&gt; 鸡汤 =&gt; 总结</p>
</li>
<li><p>名人</p>
</li>
<li><p>外表描述</p>
</li>
</ol>
<h3 id="地点类"><a href="#地点类" class="headerlink" title="地点类"></a>地点类</h3><ul>
<li>风景</li>
<li>放松</li>
<li>室内装修</li>
</ul>
<p>树: birch 桦 maple 枫 ork 橡 pine 松 willow 柳 carnation 康乃馨 tulip 郁金香 lotus 莲 Yellowstone  </p>
<p>Academy =&gt; art school</p>
<h3 id="物品类"><a href="#物品类" class="headerlink" title="物品类"></a>物品类</h3><h3 id="事件-媒体"><a href="#事件-媒体" class="headerlink" title="事件/媒体"></a>事件/媒体</h3><p>-&gt; 运动</p>
<p>agility 柔韧性</p>
<p>vital capacity 肺活量</p>
<ul>
<li>好处</li>
<li>危险项目</li>
<li>经过</li>
</ul>
<p>natatorium = swimming stadium</p>
<h3 id="风景"><a href="#风景" class="headerlink" title="风景"></a>风景</h3><p>spendid sights</p>
<p>skyscrapers</p>
<p>it has improve effiency</p>
<p>choose to live </p>
<p>spacious</p>
<p>friend in need is a friend indeed</p>
<p>uni<strong>v</strong>ersity</p>
<p><strong>ch</strong>aracteristic (|k|)</p>
<p><strong>stay up</strong> late at night 熬夜</p>
<p>refresh my mind</p>
<p>be refreshed and energetic</p>
<ul>
<li>Shanghai Tower</li>
<li>The Oriental Pearl Radio &amp; TV Tower</li>
<li>Global Center</li>
<li>The Tower of World Trade Center</li>
<li>CBD - Central Business District</li>
</ul>
<p>have a face-to-face communication with sb</p>
<p>have a quickj bite 边走边啃</p>
<p>intimate亲密的</p>
<h3 id="Novel"><a href="#Novel" class="headerlink" title="Novel"></a>Novel</h3><ul>
<li>classic</li>
<li>Romance</li>
<li>Horror</li>
<li>Detective</li>
<li>science-fiction</li>
<li>auto-biography 自传</li>
</ul>
<h3 id="Movie"><a href="#Movie" class="headerlink" title="Movie"></a>Movie</h3><ul>
<li>classic </li>
<li>Romance</li>
<li>Thriller</li>
<li>Detective</li>
<li>science movie</li>
<li>auto-biography 自传</li>
<li>action</li>
</ul>
<p>fight against xxx and protect xxx, try to make a living</p>
<p>enrich vocal</p>
<h3 id="Edu"><a href="#Edu" class="headerlink" title="Edu"></a>Edu</h3><p>tedious 繁重的</p>
<p>fax </p>
<p>online course</p>
<p>distract走神  = absent-mind</p>
<p>nearsighted 近视</p>
<p>cervical problem 颈椎病</p>
<p>unchecked infomation</p>
<p>plot情节</p>
<p>tell right分辨是非</p>
<p>campus bullying 校园霸凌</p>
<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><ul>
<li>校园学习</li>
<li>教育</li>
<li>环保</li>
</ul>
<h3 id="校园学习"><a href="#校园学习" class="headerlink" title="校园学习"></a>校园学习</h3><p>小组讨论/辩论好处 </p>
<p>CN: </p>
<ul>
<li>lecture</li>
<li>tutorial</li>
</ul>
<p>US:</p>
<ul>
<li>seminar</li>
<li>group discussion/ debate</li>
<li>presentation</li>
<li>case study</li>
<li>role play</li>
</ul>
<p>教育 carmming 填鸭式 priority</p>
<p>擅长 be gifted for/ talented in/ skilled in</p>
<p>(diff 后加复数)<br>diff stu have diff talents, some xxx, some yyy</p>
<p>Art = painting music instument sports gymnastics(体操)</p>
<h3 id="环保"><a href="#环保" class="headerlink" title="环保"></a>环保</h3><ul>
<li>污染现状</li>
<li>措施</li>
<li>种树</li>
</ul>
<p>现状</p>
<ul>
<li><strong>water</strong></li>
<li><strong>air</strong></li>
<li>pollution</li>
<li>soil</li>
<li>light</li>
<li>noise</li>
</ul>
<p>encourage 滋生</p>
<p>greenhouse effect</p>
<p>gases: carbon dioxide/ mathane/ ozone</p>
<p>haze雾霾(smog)</p>
<p>措施</p>
<ul>
<li>个人</li>
<li>政府: enact/introduce 颁布</li>
</ul>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>Why …</p>
<ul>
<li>大群体问题 we …</li>
<li>问题解决方案</li>
<li>比较</li>
</ul>
<p>Why … ?</p>
<p>套路</p>
<ol>
<li>one of the main reasons is that that … and also …</li>
<li>Firstly I think it is coz … and also …</li>
</ol>
<p>2 reason * 2 sentences</p>
<p>For starters, xxx. Plus/More importantly</p>
<p>未来计划plan</p>
<p>大群体:</p>
<p>套路</p>
<ol>
<li><p>people 喜欢/习惯 xxx for example xxx. On the other hand, xxx people 喜欢/习惯 xxx for example xxx.</p>
</li>
<li><p>Most people xxx for example xxx , but personally speaking I think [对大群体做出批判] so I xxxx (特例)</p>
</li>
</ol>
<p>解决方案:</p>
<p>How … / Advise for …</p>
<p>套路 </p>
<ol>
<li>As a xxx, xxx. As a xxx, xxx. (2*solution)</li>
<li>It would really be helpful if sb. did sth, you know right now, [现状], so if someone did sth(深层次拓展solution), [问题如何得到解决]</li>
</ol>
<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><ul>
<li>Do you have …</li>
<li>Do you know …</li>
<li>Do you have done xxx before … </li>
</ul>
<h2 id="S3-1"><a href="#S3-1" class="headerlink" title="S3"></a>S3</h2><ul>
<li>风景</li>
<li>室内装修</li>
<li>人物</li>
<li>运动</li>
<li>科技</li>
<li>工作</li>
<li>小说</li>
<li>电影</li>
<li>艺术</li>
</ul>
<h3 id="风景-1"><a href="#风景-1" class="headerlink" title="风景"></a>风景</h3><p>as beautiful as a picture =&gt; picturesque (如画的) </p>
<p>attraction scenic spot</p>
<p>birch 桦 tulip 郁金香</p>
<p>around the lake</p>
<p>live a xxx life</p>
<p>go for a sightseeing</p>
<h3 id="interior-design-decoration-室内设计"><a href="#interior-design-decoration-室内设计" class="headerlink" title="interior design/decoration 室内设计"></a>interior design/decoration 室内设计</h3><p>patio umbrella set 遮阳伞下桌椅 = outdoor</p>
<p>well-furnished</p>
<p>sun-shading</p>
<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><ul>
<li>play + 球类</li>
<li>go + ving</li>
<li>do + 非老外原生运动</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="发音"><a href="#发音" class="headerlink" title="发音"></a>发音</h2><p>暂略</p>
<h1 id="W-写作"><a href="#W-写作" class="headerlink" title="W: 写作"></a>W: 写作</h1><h2 id="基础信息-1"><a href="#基础信息-1" class="headerlink" title="基础信息"></a>基础信息</h2><h3 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h3><p>20min写150，建议不超过180</p>
<p>段落分布</p>
<ol>
<li>Intro</li>
<li>Summary</li>
<li>Body1</li>
<li>Body2</li>
</ol>
<h4 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h4><ol>
<li>Type- line graph, pie chart, bar chart, table</li>
<li>give/show/illurstrate/display/compare info about …</li>
<li>限定词from 1980 to 2030, between 1xxx and 1yyy, from the year until aaaa, over a period of 50y</li>
</ol>
<p>e.g. C9-T1-W1</p>
<p>The line graph illurstrates consumption of energy of the USA from a 2008 report between 1980 and 2030.</p>
<h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><ul>
<li>It is clear that</li>
<li>We can clear see that</li>
<li>Overall</li>
</ul>
<p>TA(task achievement): </p>
<ul>
<li>list figures -&gt; 多组数据优先考虑最大值</li>
<li>compare figures</li>
<li>report figures -&gt; general trend + the most obvious features</li>
</ul>
<p>CC(cohesion and coherence):</p>
<ul>
<li>显性: conversely/ by contrast/ on the other hand/ (不用however) </li>
<li>隐性: likewise/ similarly/ also </li>
</ul>
<p>e.g.</p>
<pre><code>29m ton petrol was consumed in 1980, this figure rose to 90m tons

followed by Solar energy(12m ton)

half of which was Solar energy

as much as Solar energy

followed by a rise of 12m tons in 2000
</code></pre>
<p>LR(Lexical resources):</p>
<ul>
<li>rise/ increase/ grow/ ascend (rose/ increased/ grew/ ascended)</li>
<li>fall/ drop/ decrease/ dip(fell/ dropped/ decreased/ dipped)</li>
<li>Dramatically/ sharply/ hugely</li>
<li>Slightly/ gradually/ slowly</li>
</ul>
<p>GRA(Grammatical range and accuary):</p>
<ul>
<li>Introduction+summary -&gt; present tense</li>
<li>Body (1980xxx) -&gt; past tense</li>
<li>Body (2030xxx) -&gt; future tense</li>
<li>Body (no time) -&gt; present tense </li>
</ul>
<p>趋势类动词句式:</p>
<ul>
<li>xxx increase to 20% in 1990</li>
<li>, reaching 20%</li>
<li>, with a peak at 20%</li>
<li>xxx decrease, with a bottom at 20%</li>
<li>xxx increase, from 20% in 1990 to 30% in 2000</li>
<li>xxx increased by 20 % in 2000</li>
</ul>
<p>趋势类名词句式:</p>
<ul>
<li>rise/ increase/ growth</li>
<li>fall/ decrease/ drop</li>
<li>soar/ plunge</li>
</ul>
<p>xxx experience(witness/ saw) an increase(rise/ growth) in yyyyy</p>
<pre><code>错误: xxx had an increase
正确: had an upword
</code></pre>
<ul>
<li>to/with a peak at 20%</li>
<li>reaching 20%</li>
<li>see an increase in xxx of yyy</li>
<li>see an increase of xxx in yyy</li>
</ul>
<p>趋势（预测）</p>
<ul>
<li>will be expected to</li>
<li>will be thought</li>
<li>be predicted to  错误: saw an increase for<br>  正确: saw an increase in</li>
</ul>
<p>粗略性表达:</p>
<p>About/ approximately/ generally/ nearly</p>
<ul>
<li>4.9% =&gt; just under 5%</li>
<li>5.1% =&gt; just over </li>
<li>98% =&gt; the majority(priority)</li>
<li>25% =&gt; one quarter</li>
</ul>
<p>百分比下的单复数</p>
<ul>
<li>30% of <strong>student</strong> <strong>achieve</strong> a high score</li>
<li>30% of <strong>water</strong> <strong>comes</strong> from sea</li>
</ul>
<p>句式的改写</p>
<ol>
<li>35% of xxx was consumed, followed by/compared to xxx</li>
<li>xxx saw an increase in consumption of xxx had the largest consumption, at xxx</li>
<li>xxx equaled 45 xxx</li>
<li>xxx be equal to 45 xxx</li>
<li>xxx be as much/many as xxx</li>
</ol>
<p>6.5以上，要求each sentence is new</p>
<ul>
<li>old people =&gt; elder people =&gt; people aged 65+</li>
<li>v+adv =&gt; adj+n</li>
<li>The figure for xxx = the contribution of xxx </li>
</ul>
<p>Pie chart的重要表述: 占据</p>
<ul>
<li>account(v.) for</li>
<li>make up </li>
<li>represent 5% of the total/totality</li>
</ul>
<p>Pie chart中的最显著特征: <strong>最大面积</strong></p>
<h4 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h4><p>summary:</p>
<ol>
<li>极值 especially xxx</li>
</ol>
<p>A大， B小。 剩下such dramatic differences are not seen when we compare the figure for xxx</p>
<p>个体过多(&gt;=3) =&gt; 描述<strong>最中之最</strong> less (&lt;12%) -&gt; least at 5% xxx in xxx</p>
<p>波动:<br>It <strong>fluctuated</strong> (and repeat), from the highest of xxx in 1990 to the lowest of xxx in 2000 </p>
<p>It rose from xxx in 1990 to xxx in 2000</p>
<h4 id="工艺流程图"><a href="#工艺流程图" class="headerlink" title="工艺流程图"></a>工艺流程图</h4><p>Flow chart intro + summary</p>
<p>The diagram illurstrates the way in which xxx is produced by xxx</p>
<p>It is clear that the whole process consists of (1/2/3) stages, including A B and C</p>
<p>It is clear that the whole process involves xxx stages</p>
<p>Body(全被动):</p>
<p>Beginning with the first stage, called xxx, [detail1], when it comes to the second stage, [detail2]</p>
<p>Then =&gt; , before =&gt; , followed by =&gt; , after which =&gt; . At that time, =&gt; , at which time =&gt; which is in order to ensure/gurantee that …</p>
<p>最后<br>xxx will be delivered to xxx</p>
<p>俩流程时需要做出比较</p>
<h2 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h2><p>It is clear that although xxx, it saw a decrease xxx </p>
<p>Body2 开头</p>
<pre><code>Regarding xxx, 

With the respect to/Enperienced the less main reason, they xxx
</code></pre>
<p>xxx rose, before falling to 5% == xxx rose and then fall xxx = After rising to 6%, this figure fell to 5%</p>
<h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><table>
<thead>
<tr>
<th>错误情况</th>
<th>正确</th>
</tr>
</thead>
<tbody><tr>
<td>the figure of</td>
<td>the figure for</td>
</tr>
<tr>
<td>xxx. Then xxx</td>
<td>改用,after xxx/,compared to xxx/, followed by (a rise to 40…)</td>
</tr>
<tr>
<td>占大多数描述方式过少</td>
<td>take the majority. the proportion of xxx was the largest. take the largest share</td>
</tr>
<tr>
<td>句式不全面</td>
<td>-ing/-ed, clause(条件约束), There be, v.-&gt;n., positive-&gt;active</td>
</tr>
<tr>
<td>同时写两个不分开</td>
<td>A and B xxx respectively. the absence of Shaun Derry and Adel Taarabt because of illness and injury respectively.</td>
</tr>
<tr>
<td>占据用词过少</td>
<td>occupy = account for … of the (total) / represent/ constitude</td>
</tr>
<tr>
<td>句子之间连贯性不足</td>
<td>Regrading …/ … is used for … / compared to … / … for …</td>
</tr>
<tr>
<td>表达都高</td>
<td>Both rank first</td>
</tr>
<tr>
<td>贼少</td>
<td>merely 2%</td>
</tr>
<tr>
<td>百分比表述</td>
<td>with % of / at %</td>
</tr>
<tr>
<td>数字表达过多</td>
<td>用背后含义表述(e.g. 人口百分比-&gt;人数)，数-&gt;量/concept, percentage =&gt; frequency.</td>
</tr>
<tr>
<td>then 不能用作连词</td>
<td>,and then =&gt; , before …</td>
</tr>
</tbody></table>
<p>采分点</p>
<ul>
<li>v. n. 趋势 in …</li>
<li>被动×1; 主动×1</li>
<li>分词(ing×1,过去分词×1)</li>
<li>介词短语</li>
<li>从句(让步状语，定语从句，时间状语从句)</li>
<li>There be</li>
</ul>
<h4 id="地图题"><a href="#地图题" class="headerlink" title="地图题"></a>地图题</h4><p>The map illustrates the layout of xxx in yyyy and its development in yyyy</p>
<p>It is clear that xxx change considerablly and xxx main features can be seen. During the development, some facilities are available to visitors.</p>
<p>Body Types:</p>
<ul>
<li>Imporovement: expansion + addition + reduction</li>
<li>Relocation: e.g. Western -&gt; Eastern</li>
<li>Function: eduactional xxx</li>
</ul>
<p>sentence pattern</p>
<ul>
<li>be built</li>
<li>be added</li>
<li>be established</li>
<li>be constructed</li>
</ul>
<p>junction 十字路口/ three branches</p>
<p>be replaced by = be deminished in order to </p>
<p>onthe either side = on both side</p>
<p>be expanded/ extended/ enlarged</p>
<p>be reduced in size</p>
<p>The reduction of school is in order to make way for xxx</p>
<p>expansion/extension</p>
<p>run/go from … to … 延伸: e.g. the road goes from east to west. The road goes from the main entrance to the xxx</p>
<p>link with</p>
<p>branch(split) off from</p>
<p>accomodation un./ equipment un./ studio -&gt; studios</p>
<h3 id="W2"><a href="#W2" class="headerlink" title="W2"></a>W2</h3><p>40min写250，建议不超过300</p>
<p>_____ it means that _____, such as _____ , _____  and _____ . In addition, __________ . In fact, __________ , for instance _______________</p>
<p>On the other hand, __________, which means __________ . For example, __________ . Moreover, __________  such as _____ , _____ and _____.</p>
<p>Best =&gt; +可替换方案</p>
<p>salary 可数-&gt; salaries</p>
<p>such as / including …</p>
<p>abundant fund</p>
<p>cram xxx into</p>
<p>intensive courses = lots of courses</p>
<p>arouse interest</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>陈述段<br>Topic sentence + explaination + examples / Topic sentence + examples + explaination</p>
<h4 id="题型-最终奥义"><a href="#题型-最终奥义" class="headerlink" title="题型+最终奥义"></a>题型+最终奥义</h4><ol>
<li>both views =&gt; agree 1, agree 2, my opinion</li>
<li>agree/disagree =&gt; agree reason 1, agree reason 2, disagree 3 but agree.</li>
<li>advantage overweigh disadv? 如上</li>
<li>Reasons? Solution. =&gt; (Reason1 + Reason2) + (Sol1 + Sol2)</li>
<li>Reasons? Pos/Neg? =&gt; (Reason1 + Reason2) + (Pos1 + Pos2)</li>
<li>Solutions? =&gt; S1 + S2 + S3</li>
</ol>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>done</tag>
        <tag>exam</tag>
        <tag>IELTS</tag>
      </tags>
  </entry>
  <entry>
    <title>标准化WASI: 一个网页外运行WebAssembly的系统接口</title>
    <url>/post/standardizing-wasi-a-webassembly-system-interface/</url>
    <content><![CDATA[<p>今天，我们宣布一项新标准化工作的开始——WASI，即WebAssembly系统接口。</p>
<span id="more"></span>

<p><strong>为何需要WASI</strong>：开发人员开始将WebAssembly(译：下称WASM)推向浏览器以外的世界，因为WASM提供了一种快速，可扩展，且安全的方式在所有计算机上运行相同的代码。</p>
<p>但是现在我们还没有坚实的基础可以构建WASI。浏览器外部的代码需要一种与系统对话的方式，即系统接口，这是当前WASM平台还没有的。</p>
<p><strong>WASI是什么</strong>：WebAssembly是用于概念中计算机的汇编语言，而不是用于物理计算机的汇编语言。这就是它可以在各种不同的机器架构上运行的原因。</p>
<p>就像WASM是概念中计算机的汇编语言一样，WebAssembly需要概念中的操作系统（而不是任何一个具体的操作系统）的系统接口。这样，它可以在所有不同的操作系统上运行。</p>
<p>这就是WASI – WASM平台的系统接口。</p>
<p>我们旨在创建一个系统接口，该接口将成为WebAssembly的真正伙伴，并经历时间考验。这意味着要坚持WASM的关键原则——“可移植性和安全性”。</p>
<p><strong>谁在制作WASI</strong>：我们正组织一个WebAssembly子项目组来专攻标准化WASI。我们已经召集了感兴趣的合作伙伴，并正在寻找更多加入的伙伴。</p>
<p>我们与合作伙伴，还有支持者，认为WASI重要的一些原因如下：</p>
<p>Mozilla首席研发官Sean White</p>
<p>“ WebAssembly正在为人们改变网络带来新的引人入胜的内容的方式，并使开发人员和创作者能够在网络上100%发挥实力。到目前为止，这是都是通过浏览器实现的。但是通过WASI，我们可以将WebAssembly和Web的优势交给更多的用户，更多的岗位，更多的设备，并作为更多体验的一部分。”</p>
<p>Fastly的首席技术官Tyler McMullen</p>
<p>“我们将WebAssembly扩展到浏览器之外，作为在边缘云中快速，安全地执行代码的平台。尽管我们的边缘和浏览器之间的环境存在差异，但WASI意味着WebAssembly开发人员无需将其代码移植到每个不同的平台上。”<br>Myles Borins，Node技术指导委员会主任</p>
<p>“ WebAssembly可以解决Node中最大的问题之一 —— 如何以接近本机的速度并像使用本机模块一样重用以C和C++等其他语言编写的代码，同时仍保持可移植性和安全性。标准化此系统接口是实现这一目标的第一步。”</p>
<p>npm的联合创始人Laurie Voss</p>
<p>“ npm对可能的WebAssembly能够扩展npm生态系统的功能感到非常兴奋，同时极大地简化了使本机代码在服务器端JavaScript应用程序中运行的过程。我们期待这一过程的结果。”</p>
<p>所以这是个大新闻！ 🎉</p>
<p>WASI当前有3种实现：</p>
<ul>
<li>wasmtime，Mozilla主导的WebAssembly运行时</li>
<li>Lucet，Fastly主导的WebAssembly运行时</li>
<li>浏览器上的polyfill</li>
</ul>
<p>如果您想了解有关该系统接口应如何工作的建议的更多信息，请继续阅读。</p>
<h2 id="什么是系统接口？"><a href="#什么是系统接口？" class="headerlink" title="什么是系统接口？"></a>什么是系统接口？</h2><p>许多人谈论像C这样可以使您直接访问系统资源的语言。但事实并不是这样的。</p>
<p>这些语言实际上无权直接在大多数系统上执行，打开或创建文件之类的操作。为什么不？</p>
<p>因为这些系统资源（例如文件，内存和网络连接）对于稳定性和安全性来说非常重要。</p>
<p>如果一个程序无意间弄乱了另一个程序的资源，则可能使该程序崩溃。更糟糕的是，如果某个程序（或用户）故意弄乱了另一个程序的资源，它可能会窃取敏感数据。(译：就是缓冲区溢出导致RCE)</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/01-01_crash-data-leak-1-500x220.png" class="" title="crash-data-leak">

<p>因此，我们需要一种方法来控制哪些程序和用户可以访问哪些资源。人们很早就意识到了这一点，并提出了一种提供这种控制的方法：保护环的安保。</p>
<p>借助保护环的安保，操作系统基本上可以在系统资源周围设置保护屏障。这也就是内核(Kernel)。内核是唯一一个需要做比如创建新文件，打开文件或打开网络连接之类的操作的东西。</p>
<p>用户程序在此内核之外以“用户模式”运行。如果程序想要执行任何操作，例如打开文件，则必须要求内核为其打开文件。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/01-02-protection-ring-sec-1-500x298.png" class="" title="protection-ring-sec">

<p>这就是系统调用(syscall)这个概念出现的地方。当程序需要让内核执行这些操作之一时，它会要求使用系统调用。这使内核有机会弄清楚是哪个用户在要求。然后，它可以在该用户在打开文件之前查看用户是否有权访问该文件。</p>
<p>在大多数设备上，这是代码可以通过系统调用访问系统资源的唯一方法。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/01-03-syscall-1-500x227.png" class="" title="syscall">

<p>操作系统使系统调用可用。但是，如果每个操作系统都有自己的系统调用，那么是否就需要为每个操作系统使用不同版本的代码？幸运的是，现在的您不需要。</p>
<p>那这个问题是如何被解决的？抽象化。</p>
<p>大多数语言都提供标准库。进行编码时，程序员无需知道他们针对的系统。他们只是使用接口。</p>
<p>然后，在编译时，您的工具链会根据您要定位的系统来选择要使用的接口实现。此实现使用操作系统API中的功能，因此特定于系统。</p>
<p>这就是系统接口的所在。例如，为Windows机器编译的printf可以使用Windows API与该机器进行交互。如果要针对Mac或Linux进行编译，它将改用POSIX。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/02-01-implementations-1-500x267.png" class="" title="implementations">

<p>但是，这也给WebAssembly带来了一个问题。</p>
<p>使用WebAssembly，即使在编译时，您也不知道要使用哪种操作系统。因此，您不能在标准库的WebAssembly实现中使用任何单个操作系统的系统接口。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/02-02-implementations-1-500x260.png" class="" title="implementations">

<p>我之前说过，为何WebAssembly是个<a href="https://hacks.mozilla.org/2017/02/creating-and-working-with-webassembly-modules/" target="_blank" rel="noopener">用于概念计算机的汇编语言</a>而不是真实计算机的汇编语言。以同样的方式，WebAssembly需要用于概念性操作系统的系统接口，而不是真正的操作系统。</p>
<p>但是，即使没有适当的系统接口，也已经有运行时可以在浏览器外部运行WebAssembly。他们是怎么做到的呢？ 让我们来看看。</p>
<h2 id="当下，WebAssembly是如何在浏览器之外运行？"><a href="#当下，WebAssembly是如何在浏览器之外运行？" class="headerlink" title="当下，WebAssembly是如何在浏览器之外运行？"></a>当下，WebAssembly是如何在浏览器之外运行？</h2><p>生成WebAssembly的第一个工具是Emscripten。它在网页上模拟了特定的OS系统接口POSIX。这意味着程序员可以使用C标准库（libc）中的函数。</p>
<p>为此，Emscripten创建了自己的libc实现。 此实现分为两部分 —— 将一部分编译到WebAssembly模块中，另一部分用JS胶水代码实现；然后，此JS胶水将调用浏览器，此后浏览器将与OS通信。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/03-01-emscripten-1-500x329.png" class="" title="emscripten">

<p>早期的大多数WebAssembly代码都是使用Emscripten编译的。因此，当人们开始希望在没有浏览器的情况下运行WebAssembly时，他们首先通过运行Emscripten编译的代码开始。</p>
<p>所以，为JS胶水代码中的所有这些功能，这些运行时需要创建自己的实现。</p>
<p>不过这里有个问题。该JS胶水代码提供的接口并非标准设计，甚至不是面向外部的接口。因为这不是它当时需要解决的问题。</p>
<p>打个比方，对于一个类似于public接口API上<code>read</code>的函数的调用，JS胶水代码改用 <code>_system3(which, varargs)</code>。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/03-02-system3-1-500x179.png" class="" title="system3">

<p>第一个参数，<code>which</code>，是一个整数，该整数始终与名称中的数字相同（在这种情况下为3）。</p>
<p>第二个参数，<code>varargs</code>，是要使用的参数。之所以称为varargs，是因为您可以使用可变数量的变量。但是WebAssembly无法提供将可变数量的参数传递给函数的方法。因此，参数是通过线性内存传递的。这不是安全的类型，而且比使用寄存器传递参数的速度要慢。</p>
<p>这对于在浏览器中运行Emscripten来说很好。但是现在，运行时将其视为事实上的标准，实现了自己的JS胶水代码版本。他们正在仿真POSIX仿真层的内部细节。</p>
<p>这意味着他们正在重新实现基于Emscripten约束有意义的选择（例如将参数作为堆值传递），即使这些约束不适用于他们当前的环境。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/03-03-emulation-1-500x341.png" class="" title="emulation">

<p>如果我们要建立一个可持续数十年的WebAssembly生态系统，则需要坚实的基础。 这意味着我们的事实上的标准不能是模仿的模仿。</p>
<p>但是，我们应该采用什么原则？</p>
<h3 id="WASI需要遵循哪些原则？"><a href="#WASI需要遵循哪些原则？" class="headerlink" title="WASI需要遵循哪些原则？"></a>WASI需要遵循哪些原则？</h3><p>WebAssembly中包含两个重要的原则：</p>
<ul>
<li>可移植性</li>
<li>安全性</li>
</ul>
<p>在转向浏览器外的使用时，我们需要保证这些关键原则。</p>
<p>事实是，POSIX和Unix的安全性访问控制方法还不能完全解决问题。让我们看看它们的不足之处。</p>
<h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>POSIX提供源代码可移植性。您可以使用不同版本的libc编译相同的源代码，以针对不同的计算机。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-01-portability-1-500x375.png" class="" title="portability">

<p>但是WebAssembly需要超越这一步骤。我们需要能够编译一次并跨一大堆不同的机器运行。我们需要可移植的二进制文件。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-02-portability-1-500x484.png" class="" title="portability">

<p>这种可移植性使向用户分发代码变得更加容易。</p>
<p>例如，如果Node的本机模块是用WebAssembly编写的，则用户在安装带有本机模块的应用程序时无需运行node-gyp，并且开发人员无需配置和分发数十个二进制文件。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>当一行代码要求操作系统进行某些输入或输出时，操作系统需要确定执行代码要求的操作是否安全。</p>
<p>操作系统通常使用基于所有权和组的访问控制来处理此问题。</p>
<p>例如，程序可能要求操作系统打开文件。用户具有他们有权访问的一组文件。</p>
<p>当用户启动程序时，该程序代表该用户运行。如果用户有权访问文件——（因为他们是所有者，或者因为他们在具有访问权限的组中），那么程序也具有相同的访问权限。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-03-access-control-1-500x224.png" class="" title="access-control">

<p>这样可以用户之间进行保护。在早期操作系统的开发中，这很有意义。系统通常是多用户的，并且管理员控制要安装的软件。因此，最主要的威胁是其他用户偷看您的文件。</p>
<p>但是，大人，时代变了。系统现在通常是单用户，但是它们正在运行的代码会引入许多其他可信度未知的第三方代码。现在最大的威胁是您自己正在运行的代码将对您不利。</p>
<p>例如，假设您在应用程序中使用的库获得了一个新的维护程序（在开放源代码中经常发生）。那个维护者可能会引起您的兴趣……或者他们可能是坏人之一。 而且，如果他们有权在您的系统上执行任何操作（例如打开任何文件并通过网络发送文件），那么他们的代码可能会造成很大的破坏。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-04-bitcoin-1-500x258.png" class="" title="bitcoin">

<p>这就是为什么使用可以直接与系统对话的第三方库很危险的原因。</p>
<p>WebAssembly的安全性方法不同。WebAssembly已沙盒化。</p>
<p>这意味着代码无法直接与操作系统对话。但是，它如何处理系统资源呢？主机（可能是浏览器，也可能是wasm运行时）将函数放入代码可以使用的沙箱中。</p>
<p>这意味着主机可以限制程序在逐个程序的基础上可以执行的操作。它不仅可以让程序代表用户执行操作，还可以在具有用户完全权限的情况下调用任何系统调用。</p>
<p>仅仅拥有一种沙箱机制并不能保证系统本身的安全性——因为主机仍然可以将所有功能都放到沙箱中，在这种情况下，我们的状况就不会更好了——但它至少使主机可以能够选择创建一个更安全的系统。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-05-sandbox-1-500x278.png" class="" title="sandbox">

<p>在我们设计的任何系统接口中，我们都需要坚持这两个原则。可移植性使开发和分发软件更加容易，并且绝对必须为主机提供工具以保护自己或他们的用户安全。</p>
<h3 id="WASI应该是什么样？"><a href="#WASI应该是什么样？" class="headerlink" title="WASI应该是什么样？"></a>WASI应该是什么样？</h3><p>给定这两个关键原则，WebAssembly系统接口的设计应该是什么？</p>
<p>这就是我们在标准化过程中要解决的问题。 不过，我们确实有一个建议：</p>
<ul>
<li>创建一组标准接口</li>
<li>从标准化最基本的模块wasi-core开始</li>
</ul>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-01-wasi-1-500x419.png" class="" title="wasi">

<p>wasi-core将会是个啥？</p>
<p>wasi-core将包含所有程序需要的基础。它将覆盖与POSIX相同的大部分内容，包括文件，网络连接，时钟和随机数。</p>
<p>对于许多这些事情，它将采用与POSIX非常相似的方法。例如，它将使用POSIX的面向文件的方式，在此基础上您可以进行诸如open，close，read和write之类的系统调用，而其他所有操作基本上都可以在顶部进行增强。</p>
<p>但是wasi-core无法涵盖POSIX的所有功能。例如，进程概念不能清楚地映射到WebAssembly上。除此之外，说每个WebAssembly引擎都需要支持进程操作（如fork）是没有意义的。 但是我们也想使标准化fork成为可能。</p>
<p>这就是模块化方法的用武之地。通过这种方式，我们可以获得良好的标准化覆盖率，同时仍然允许细分平台仅使用WASI在该平台上有意义的部分。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-02-wasi-1-500x251.png" class="" title="wasi">

<p>像Rust这样的语言将直接在其标准库中使用wasi-core。 例如，Rust的<code>open</code>是通过在编译为WebAssembly时调用<code>__wasi_path_open</code>来实现的。</p>
<p>对于C和C++，我们创建了一个<a href="https://github.com/CraneStation/wasi-sysroot" target="_blank" rel="noopener">wasi-sysroot</a>，它根据wasi-core函数实现了libc。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-03-open-imps-1-500x229.png" class="" title="open-imps">

<p>我们希望像clang这样的编译器准备好与WASI API交互，并且像Rust编译器和Emscripten这样的完整工具链也可以将WASI用作其系统实现的一部分</p>
<p>那么用户的代码需要如何调用这些WASI函数？</p>
<p>答案是，运行代码的运行时将wasi-core函数作为导入(imports)传递进WASM。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-04-imports-1-500x285.png" class="" title="imports">

<p>这给我们带来了可移植性，因为每个主机都可以有自己的wasi-core实现，该实现专门针对其平台编写——从Mozilla的wasmtime和Fastly的Lucet之类的WebAssembly运行时，到Node甚至是浏览器。</p>
<p>这也给我们提供了沙箱管理功能，因为主机可以逐个程序选择要传入的wasi-core函数，因此，可以允许哪个系统调用。 这样可以保持安全性。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-05-sec-port-2-500x705.png" class="" title="sec-port">

<p>WASI为我们提供了进一步扩展此安全性的方法。它从基于功能的安全性中引入了更多概念。</p>
<p>传统上，如果代码需要打开文件，则使用字符串（路径名）调用open。然后，操作系统会检查代码是否具有权限（基于启动程序的用户）。</p>
<p>使用WASI，如果要调用需要访问文件的函数，则必须传入文件描述符，该描述符具有附加的权限。这可以用于文件本身，也可以用于包含文件的目录。</p>
<p>这样，您就不会拥有随机要求打开/etc/passwd的代码。相反，代码只能在传递给它的目录上操作。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-06-openat-path-1-500x192.png" class="" title="openat-path">

<p>这使得可以安全地给沙盒代码更多地访问不同的系统调用的权限，因为这些系统调用的功能可能受到限制。</p>
<p>而且这是逐个模块进行的。默认情况下，模块无权访问文件描述符。但是，如果一个模块中的代码具有文件描述符，则可以选择将该文件描述符传递给它在其他模块中调用的函数。或者，它可以创建文件描述符的更多受限版本以传递给其他功能。</p>
<p>因此，运行时将应用程序可以使用的文件描述符传递给顶层代码，然后根据需要，将文件描述符传播到系统的其余部分。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-07-file-perms-1-500x423.png" class="" title="file-perms">

<p>这使WebAssembly更接近最小特权原则，在该原则下，模块只能访问执行其工作所需的确切资源。</p>
<p>这些概念来自面向功能的系统，例如CloudABI和Capsicum。面向功能的系统的一个问题是，通常很难向其移植代码。但是我们认为这个问题可以解决。</p>
<p>如果代码已经使用了带有相对文件路径的<code>openat</code>，那么编译代码就可以了。</p>
<p>如果代码使用<code>open</code>并且正迁移到<code>openat</code>风格是过度的前期投资，WASI可以提供一个增量解决方案。使用<img src="https://github.com/musec/libpreopen" alt="libpreopen" loading="lazy">，您可以创建应用程序需要合法访问的文件路径的列表。然后，您可以使用open，但只能使用这些路径。</p>
<h3 id="接下来做什么"><a href="#接下来做什么" class="headerlink" title="接下来做什么"></a>接下来做什么</h3><p>我们认为wasi-core是一个好的开始。它保留了WebAssembly的可移植性和安全性，为生态系统奠定了坚实的基础。</p>
<p>但是，在wasi-core完全标准化之后，我们仍然需要解决一些问题。这些问题包括：</p>
<ul>
<li>异步I/O</li>
<li>文件监控</li>
<li>文件锁定</li>
</ul>
<p>这仅仅是开始，因此，如果您有解决这些问题的想法，请加入我们！</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>wasm</tag>
        <tag>wasi</tag>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title>WASM 2Master</title>
    <url>/post/wasm-2-master/</url>
    <content><![CDATA[<p>因为NGIN的缘故，所以相当于是加入了wasmtime这个坑里。</p>
<p>虽然名义上bytecodealliance算是正规军但是有一说一至少这个wasmtime-go做的稀烂啊……</p>
<p>这里就拿rust(写&amp;编译wasm)+wasmtime-go(调用)来介绍。</p>
<span id="more"></span>

<h2 id="Beginning"><a href="#Beginning" class="headerlink" title="Beginning"></a>Beginning</h2><p>首先得推荐一个工具<a href="https://webassembly.github.io/wabt/demo/wasm2wat/" target="_blank" rel="noopener">wasm2wat</a>。既然是想耍wasm那肯定听说过wat，因为现在各个语言对wasm的支持都一言难尽，所以个人经验来说是有事没事转成wat看看挺好的。</p>
<p>然后就是一些基本概念</p>
<p>基本上都在<a href="https://webassembly.github.io/spec/core/" target="_blank" rel="noopener">官方文档</a>里</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p>WASM底层内部就四种值：字节(Bytes),整数(Integers),浮点数(Floating-Point),还有命名(Names，基本上可以理解为string)</p>
<p>这里的值和后面类型里的值是不一样的，这里是底层实现上的，类型的偏应用上。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>值做开发时候一般没啥感知，但是类型就不一样了，处处受它制约。</p>
<p>WASM有这样几个类型：值，结果，函数，约束，内存，表，全局，导出。</p>
<p>好像约束是最近多出来的以前好像没见过(</p>
<h4 id="值-1"><a href="#值-1" class="headerlink" title="值"></a>值</h4><p>就四种值：i32，i64，f32，f64。其中i表示整型，f表示浮点，32，64就是位，比如f64就是等价于其他语言类型的float64。</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>表示一系列指令或者函数执行后的结果</p>
<p>结果本质上是一个值(上面那个i32这样的)的队列</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数类型对函数的签名进行分类，将参数映射到结果。</p>
<p>还用于对指令的输入和输出进行分类。</p>
<p>就类似C语言头文件里那个对函数的预定义，就写个名字，参数(类型)和结果(类型)</p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p>约束对与内存和表关联的可调整大小的存储的大小范围进行分类。</p>
<p>如果没有给出最大值，则相应的存储可以增长到任何大小。</p>
<p>换句话说就是把WASM沙箱当虚拟机client，约束就控制它的内存存储防止它把host资源用了</p>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>内存是个线性的存储器，可以用约束对它进行限制，以页面大小为单位。</p>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>表就相当于一些语言里的hashMap或者Array。</p>
<p>像内存一样，表格的最小和最大大小也受到约束，单位是条目数。</p>
<p>其中元素类型funcref是所有函数的无限并集。因此，有这个类型的表就相当于包含对函数的引用。</p>
<h4 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h4><p>就修饰其他值说明其为全局变量，可变也行不可变也ok。</p>
<h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>导出是修饰其他值来说明其可外部访问/调用。</p>
<h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>也很可能加别的类型，请告知我更新</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>WebAssembly代码由指令序列组成。它的计算模型基于堆栈计算机，其中指令在隐式操作数堆栈上操纵值，消耗（pop）参数值并生成或返回（push）结果值。</p>
<p>除了来自堆栈的动态操作数外，某些指令还具有静态直接变量，通常是索引或类型注释，它们是指令本身的一部分。</p>
<p>一些指令的结构形式是，它们将嵌套的指令序列括起来。</p>
<p>指令里包括： 数值，参数，变量，内存，控制，表达式</p>
<p>简单点讲就是对不同的类型的不同使用方式罢了</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>个人觉得这个很重点，经常考。</p>
<p>WebAssembly中的代码的可分发，可加载和可执行单元称为模块。 </p>
<p>在运行时，可以使用一组导入值实例化一个模块以生成一个实例，该实例是一个不可变的元组，引用了正在运行的模块可访问的所有状态。 </p>
<p>多个模块实例可以访问相同的共享状态，这是WebAssembly中动态链接(dynamic linking)的基础。 WebAssembly模块还可以在将来与ES6模块集成</p>
<p>一个模块包含以下部分：</p>
<ul>
<li>导入</li>
<li>导出</li>
<li>程序开始函数</li>
<li>全局</li>
<li>内存</li>
<li>数据</li>
<li>表</li>
<li>元素</li>
<li>函数和代码</li>
</ul>
<p>一个模块还定义了几个索引空间，这些索引空间由模块中的各种运算符和section字段静态索引：</p>
<ul>
<li>函数索引空间</li>
<li>全局索引空间</li>
<li>线性内存索引空间</li>
<li>表索引空间</li>
</ul>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>一个模块可以声明一系列导入，这些导入在实例化时由宿主机环境提供。有这样几种：</p>
<ul>
<li>函数导入，可以由<code>call</code>函数在模块内部调用；</li>
<li>全局导入，可以由全局操作在模块内部访问；</li>
<li>线性内存导入，可以由内存操作在模块内部访问；和</li>
<li>表导入，将来可以通过call_indirect和其他表运算符在模块内部访问。</li>
</ul>
<p>将来可能会增加其他的导入。导入的目的是在允许模块共享代码和数据情况下，同时允许单独的编译和缓存。</p>
<p>所有导入都包括两个显性名称：模块名称和导入名称，必须是有效的UTF-8。这些名称的解释取决于宿主机环境，但旨在允许宿主机环境（如Web）支持两级命名空间。</p>
<p>每种特定的导入类型都定义了额外字段：</p>
<p>函数导入包括用于模块内部导入函数的签名。主机环境定义了针对模块外部导入功能的签名检查。但是，如果导入的函数是WebAssembly函数，则如果签名不匹配，则宿主机环境必须触发实例化时间错误。</p>
<p>全局变量导入包括全局变量的值类型和可变性。这些字段的含义与“全局”部分中的含义相同。在最简化实现中，全局变量导入必须是不可变的。</p>
<p>线性内存导入包括“线性存储器”部分中定义的相同字段集：初始长度和可选的最大长度。主机环境必须仅允许导入WebAssembly线性内存，这些内存的初始长度大于或等于导入中声明的初始长度，并且最大长度&lt;=导入中声明的最大长度。这样可以确保可以进行单独的编译：在声明的初始长度以下的内存访问始终是入站的，在声明的最大长度以上的内存访问始终是越界的，如果初始等于最大值，则该长度是固定的。在最简实现中，每个内存都是默认内存，因此至多可以有一个线性内存导入或线性内存定义。</p>
<p>表导入包括“表”部分中定义的相同字段集：元素类型，初始长度和可选的最大长度。与线性内存部分一样，主机环境必须确保仅导入具有完全匹配的元素类型，初始长度等于或大于最大长度，或等于或小于等于最大长度的WebAssembly表。在MVP中，每个表都是默认表，因此最多可以有一个表导入或表定义。</p>
<p>由于WebAssembly规范未定义如何解释导入名称：</p>
<ul>
<li>Web环境将名称定义为UTF8编码的字符串；</li>
<li>宿主机环境可以将模块名称解释为文件路径，URL，一组固定的内置模块中的密钥，或者主机环境可以调用用户定义的挂钩将模块名称解析为其中之一；</li>
<li>模块名称不需要解析为WebAssembly模块；它可以解析为内置模块（由主机环境实现）或以其他兼容语言编写的模块；和</li>
<li>调用导入函数的含义是宿主机定义的。</li>
</ul>
<p>模块导入的开放性使得它们可以用于向WebAssembly代码公开任意宿主机环境里的函数，类似于本机syscall。例如，一个shell环境可以定义一个带有内置stdio模块<code>puts</code>的导出。</p>
<h4 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h4><p>模块可以声明一系列导出，这些导出在实例化时返回给主机环境。每个导出都有三个字段：一个名称（必须是有效的UTF-8），其名称由主机环境定义；一个类型（用于说明导出是函数，全局，内存还是表），以及指向类型对应索引空间的索引。</p>
<p>所有定义都是可导出的：函数，全局变量，线性内存和表。导出了的定义的实际含义由宿主机环境定义。但是，如果另一个WebAssembly实例导入该定义，则两个实例将共享相同的定义，并且共享了关联的状态（全局变量值，线性内存字节，表元素）。</p>
<p>导出名称必须唯一。</p>
<p>在最小实现中，只能导出不可变的全局变量。</p>
<h4 id="模块启动函数"><a href="#模块启动函数" class="headerlink" title="模块启动函数"></a>模块启动函数</h4><p>如果模块已定义起始节点，则在实例实例初始化之后，包括通过“数据”和“元素”部分的“内存”和“表”，以及可调用导出的函数之前，加载器应调用它引用的函数。</p>
<ul>
<li>start函数不能接受任何参数或返回任何内容</li>
<li>该功能由功能索引标识，可以是导入的，也可以导出的</li>
<li>每个模块最多只能有一个起始节点</li>
</ul>
<p>例如，模块中的起始节点将是：</p>
<p><code>(start $start_function)</code></p>
<p>要么</p>
<p><code>(start 42)</code></p>
<p>在这第一个示例中，预期环境在调用任何其他模块函数之前先调用函数$start_function。在第二种情况下，预期环​​境将调用索引为42的模块函数。该数字是从0开始的函数索引（与导出相同）。</p>
<p>一个模块可以：</p>
<ul>
<li>最多只有一个起始节点</li>
<li>如果模块包含起始节点，则必须在模块中定义功能</li>
<li>在加载模块之后且对模块函数的任何调用完成之前，将调用start函数</li>
</ul>
<h4 id="全局部分"><a href="#全局部分" class="headerlink" title="全局部分"></a>全局部分</h4><p>全局部分提供了零或数个全局变量的内部定义。</p>
<p>每个全局变量内部定义都声明其类型（值类型），可变性（布尔标志）和初始值设定项（初始值设定项表达式）。</p>
<h4 id="线性内存部分"><a href="#线性内存部分" class="headerlink" title="线性内存部分"></a>线性内存部分</h4><p>线性内存部分提供了一个线性内存的内部定义。在最小实现中，每个内存都是默认内存，并且最多可以有一个线性内存导入或线性内存定义。</p>
<p>每个线性内存部分都声明一个初始内存大小（随后可以通过grow_memory增加）和一个可选的最大内存大小。</p>
<p>如果尝试增长超过声明的最大值，grow_memory将确保失败。 声明后，实现应（非规范性的）尝试保留最大大小的虚拟内存。 分配初始内存大小失败是运行时错误，而保留最大内存失败则不是。 如果未声明最大内存大小，则在虚拟地址空间有限的体系结构上，引擎应仅分配初始大小并按需重新分配。</p>
<h4 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h4><p>线性存储器的初始内容为零。</p>
<p>数据节包含一个可能为空的数据段数组，这些数据段指定给定内存的固定（偏移，长度）范围的初始内容，该内容由其线性内存索引指定。</p>
<p>数据部分类似于原生可执行文件的<code>.data</code>部分。</p>
<p>长度是一个整数常数值（定义给定段的长度）。偏移量是一个初始化表达式。</p>
<h4 id="表部分"><a href="#表部分" class="headerlink" title="表部分"></a>表部分</h4><p>表格部分包含零或数个不同表格的定义。在最小实现中，每个表都是默认表，并且至多一个表导入或表定义。</p>
<p>每个表定义都声明一个元素类型，初始长度和可选的最大长度。</p>
<p>在最小实现中，唯一有效的元素类型是<code>anyfunc</code>，但将来，可能会添加更多元素类型。</p>
<p>在最小实现中，只能通过宿主机定义的API（例如JavaScript的<code>WebAssembly.Table.prototype.grow</code>）来调整表的大小。将来可能会添加一个grow_table。</p>
<p>在任何一种情况下，如果试图增长到声明的最大值以上，表增长都会失败。与线性内存一样，当声明最大值时，实现应（非规范）尝试将虚拟内存保留为最大大小。分配初始内存大小失败是运行时错误，而保留最大内存失败则不是。如果未声明最大内存大小，则在虚拟地址空间有限的体系结构上，引擎应仅分配初始大小并按需重新分配。</p>
<h4 id="元素部分"><a href="#元素部分" class="headerlink" title="元素部分"></a>元素部分</h4><p>表中元素的初始内容是个标记值（如果被调用，则会被捕获）。 </p>
<p>元素部分允许模块使用模块中的任何其他定义初始化（在实例化时）任何导入的或内部定义的表的元素。这与数据部分允许模块初始化任何已导入或已定义存储器的字节对称。</p>
<p>元素部分包含元素段的可能为空的数组，这些元素段指定给定表的固定（偏移，长度）范围的初始内容，该范围由表索引指定。</p>
<p>长度是一个整数常数值（定义给定段的长度）。偏移量是一个初始化表达式。元素由它们在相应索引空间中的索引指定。</p>
<h4 id="功能和代码部分"><a href="#功能和代码部分" class="headerlink" title="功能和代码部分"></a>功能和代码部分</h4><p>一个逻辑功能定义由以下两个部分决定</p>
<ul>
<li>函数部分声明模块中每个内部函数定义的签名</li>
<li>代码部分包含功能部分声明的每个函数的函数主体</li>
</ul>
<p>此拆分通过将构成模块大部分字节大小的函数主体放在结尾处来帮助进行流式编译，以便在编译开始之前可以使用递归模块加载和并行编译所需的所有元数据。</p>
<h4 id="功能索引空间"><a href="#功能索引空间" class="headerlink" title="功能索引空间"></a>功能索引空间</h4><p>函数索引空间对所有导入的和内部定义的函数定义建立索引，并根据模块中定义的顺序（由二进制编码定义）分配单调递增的索引。因此，索引空间从零开始，函数导入（如果有），然后是模块内定义的函数。</p>
<p>函数索引空间由以下部分使用：</p>
<ul>
<li>调用，以识别直接调用的被调用函数。</li>
<li>元素。</li>
<li>导出，以确定哪些功能公开给嵌入器。</li>
<li>启动函数，以确定实例完全初始化后调用哪个函数。</li>
</ul>
<h4 id="全局索引空间"><a href="#全局索引空间" class="headerlink" title="全局索引空间"></a>全局索引空间</h4><p>全局索引空间对所有导入的和内部定义的全局定义进行索引，并根据模块中定义的顺序（由二进制编码定义）分配单调递增的索引。因此，索引空间从零开始，首先是全局导入（如果有），然后是模块内定义的全局。</p>
<p>全局索引空间用于：</p>
<ul>
<li>全局变量访问运算符，标识要读取/写入的全局变量</li>
<li>数据段，以将数据段的偏移量（在线性存储器中）定义为全局变量的值</li>
<li>线性内存索引空间</li>
<li>线性内存索引空间索引所有导入的和内部定义的线性内存定义，并根据模块中定义的顺序（由二进制编码定义）分配单调递增的索引。因此，索引空间从零开始，首先是内存导入（如果有），然后是模块内定义的内存。</li>
</ul>
<p>线性内存的索引空间仅由数据部分使用。在最小实现中，最多只有一个线性内存，因此该索引空间只是当可以有多个内存时使用的占位符。</p>
<h4 id="表索引空间"><a href="#表索引空间" class="headerlink" title="表索引空间"></a>表索引空间</h4><p>表索引空间为所有导入的和内部定义的表定义建立索引，并根据模块中定义的顺序（由二进制编码定义）分配单调递增的索引。因此，索引空间从零开始，首先是表导入（如果有），然后是模块中定义的表。</p>
<p>表索引空间仅由元素部分使用。在最小实现中，最多有一个表，因此该索引空间只是可以存在多个表时的占位符。</p>
<h3 id="初始化程序表达式"><a href="#初始化程序表达式" class="headerlink" title="初始化程序表达式"></a>初始化程序表达式</h3><p>初始化程序表达式在实例化时进行执行，现在用于：</p>
<ul>
<li>定义全局变量的初始值</li>
<li>定义数据段或元素段的偏移量</li>
</ul>
<p>一个初始化程序表达式是纯WebAssembly表达式，其编码与WebAssembly表达式相同。并不是所有的WebAssembly运算符都可以或不应该在初始化表达式中得到支持。初始化表达式表示WebAssembly表达式的最小纯子集。</p>
<p>在最小实现中，为了使事情简单，同时仍支持动态链接的基本需求，初始化器表达式仅限于以下空运算符：</p>
<ul>
<li>四个常量运算符</li>
<li><code>get_global</code>，其中全局索引必须引用不可变的导入。</li>
</ul>
<p>将来，可以添加诸如<code>i32.add</code>之类的运算符，以实现更具表现力的base + offset耗时计算。</p>
<h3 id="Tricks-基本操作"><a href="#Tricks-基本操作" class="headerlink" title="Tricks 基本操作"></a>Tricks 基本操作</h3><p>很明显哈，wasm半点都没提到string或者bytes，那么在使用嵌入式的WASM模块时候我们怎么输入string和bytes(Uint8Array)？</p>
<p>先从非语言相关角度看，由于没法传数组没法传不定参数，所以我们需要一个起点和一个长度来定位需要导入的string。因此就直接发送指针位置和长度两个值作为i32到WASM就充当了string。</p>
<p>就相当于，宿主机往内存写入数据，然后把位置和长度告诉WASM，WASM再从内存上取出来。</p>
<p>这里有个增强WASM的rust库，wasm-bindgen，基本上能帮忙把东西都给实现了</p>
<p>【吐槽一下基本上每个WASM相关rust库都能看到alexcrichton在回答issue……劳模啊……</p>
<p>做WASM开发的时候可以把<code>.wasm</code>看作是一个dll，so或者out，面向的是WASM这个系统，所以就可以意识到为啥内置没string这些高级的类型了【不让你写0101已经很不错了。</p>
<p>那么这么来看wat就是汇编语言了:-)</p>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// no_mangle表示不会为函数进行函数名混淆，保证FFI名字不变</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="function"><span class="keyword">fn</span> <span class="title">string</span></span>() -&gt;  *<span class="keyword">const</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="string">b&quot;Hello, World!\0&quot;</span>.as_ptr()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么我们可以通过<code>instance.GetExport(&quot;memory&quot;).Memory().UnsafeData()</code>获取<code>Hello, World!</code>?</p>
<p>因为编译的时候这个Hello world就被写进了wasm里面，是·个·常·量！初始化之后就理所当然进了线性内存(liner memory)里。call string的时候本质就是string乖乖把<strong>在WASM上的</strong>内存地址给返回了。</p>
<p>也就是说相当于</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="WASI"><a href="#WASI" class="headerlink" title="WASI"></a>WASI</h2><p>WASI 是个很有趣的东西，他就直接把WASM带到了系统上</p>
<p>在<a href="https://github.com/WebAssembly/WASI/issues/223%EF%BC%8C" target="_blank" rel="noopener">https://github.com/WebAssembly/WASI/issues/223，</a> 有个回答很精妙：At an application level though, the direction WASI is heading is away from “A passes B a string, then then B opens the resource”, and toward “A opens the resource and passes B a handle”. 这其实也就是WASM工作的原理。</p>
<h2 id="NGIN"><a href="#NGIN" class="headerlink" title="NGIN"></a>NGIN</h2><p>在链上应用我需要的是其对链上信息(block, tx etc)做出反应。</p>
<p>例如，子网币的发行针对主网矿工，那么其应当在WASM中维护一个account balances，然后对block的事件侦听来实现分发，对tx事件侦听实现交易。</p>
<p>那么换句话说，我们只需要把外部信息(结构体)传递到WASM沙箱中作为事件，然后再加点getter。</p>
<p>当然我们也要提供好存储。</p>
]]></content>
      <tags>
        <tag>wasm</tag>
        <tag>wasi</tag>
        <tag>WebAssembly</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>Reading paper in FIT5152: 知识评估和进展分析与设计的统一框架 A Unified Framework for Knowledge Assessment and Progression Analysis and Design</title>
    <url>/post/fit5152-a1-paper/</url>
    <content><![CDATA[<p>作者 Shuhan Wang, Fang He &amp; Erik Andersen</p>
<p>论文翻译，侵删</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>设计引人入胜的学习内容固然重要，但也很困难，并且通常涉及许多手动规范。 我们提出了一个统一的框架，该框架利用<strong>自动问题分解和部分排序图的构建</strong>来简化多个工作流：知识评估以及进行性分析和设计。 我们通过在线日语评估工具对847名参与者进行了研究，结果表明我们的框架可以有效地衡量学生的能力并预测学生在特定问题上的表现。 我们还提供了对课程分析的结果，结果表明两种不同教科书的进度令人惊讶地相似，并且我们的框架可以导致发现专家进行设计的一般原理。 最后，我们演示了自动进度生成以及所需的排序和步调，允许进行进度定制以及将从一个课程中提取的参数映射到另一个课程</p>
<span id="more"></span>

<p>ACM Classification Keywords</p>
<p>H.5.0 Information Interfaces and Presentation: General</p>
<p>Author Keywords</p>
<p>education; automatic problem decomposition; knowledgeassessment; progression analysis and design</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>教育中的一个关键挑战是保持学生的参与度，而首要考虑的是向特定学生展示最佳知识的顺序。 排序是一个挑战：首先应该引入哪些知识？ 另一个速度是：进步会变得越来越困难。尽管有教育和心理学等方面的指导原则[15，55，59]可以帮助设计进步，但缺乏务实和自动的方法来弥合教育理论与实践之间的差距， 尤其是整个课程的规模。 设计和优化进度的困难也限制了课程适应每个学生需求的能力</p>
<p>在HCI中，此问题与教育软件[7、14]，视频游戏[11、22、33、37、45]和软件可学习性[25、31]的设计有关。目前，我们主要是手工设计进度，这很昂贵，并且限制了我们寻找最佳进度的实验能力。最近，在自动进度设计中已有一些工作[6，11]。尽管这项工作能够自动组织内容，但仅解决了程序性主题和视频游戏级设计。我们仍然缺乏一个通用的框架来表征能够处理一些非过程性主题（如语言学习）的教育进程。此外，我们<strong>需要一种形式上的方法来使用相同的框架来评估学生的知识</strong>，以便<strong>我们可以针对该学生量身定制学习进度和进度</strong>。理想情况下，我们将能够在不费吹灰之力的情况下针对广泛的教育领域建立适应性的进步。</p>
<p>在本文中，我们提出了一个框架，<strong>该框架允许针对非过程性任务进行自动问题分解和部分排序图构造。该框架促进了多个工作流程</strong>。它建立在项目反应理论[53]，知识空间理论[28]和知识追踪[14]的基础之上，以创建学生知识和问题难度的多维度量，从而可以快速评估和预测绩效。它还定义了起搏和其他进度参数的参数空间，并提供了一种方法来表征和比较进度以及设计符合所需参数的新进度。</p>
<p>我们对框架进行了多次评估。首先，我们提出了对自动问题分解和偏序图构建的理论贡献，以帮助外语学习语法，这是一个重要的非程序性主题。然后，我们讨论了一个有847名参与者的用户对日语评估工具的评估，这表明我们的自动评估算法可以根据项目响应理论准确地进行能力评估和绩效预测。我们还提供了自动分析语言学习进度的结果，显示出两本用于学习日语的教科书令人惊讶地具有相似的节奏和其他进阶特征，并且两种在线语言学习工具具有非常不同的进阶设计策略。最后，我们证明了我们的框架可以自动生成具有所需特征的进度，例如学习进度以及学习和复习的比例。这使得从进度分析中获得的见解可以直接应用于进度设计和个人进度剪裁</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="智能辅导系统"><a href="#智能辅导系统" class="headerlink" title="智能辅导系统"></a>智能辅导系统</h3><p>有成功的适应性学习系统，例如认知母语导师[7]。其中一些工作专门针对语言学习[63，65]。认知导师通过跟踪认知模型中个体生产规则的表现来利用知识边缘跟踪[14]来跟踪知识的获取并提供量身定制的指导[14，39]。该模型已通过多种方式扩展，包括估算学生了解技能的初始概率[49]，评估帮助功能对获得概率的影响[10]以及与项目难度模型集成[ 50]。另一种方法是逻辑回归，这对于涉及多种技能的任务特别有效[64]。但是，这些方法通常不考虑起搏。取而代之的是，他们一直给问题赋予特定的生产规则，直到“隐马尔可夫模型”获得了95％的置信度，即学生已经学会了该规则，然后继续研究下一个概念。此外，认知导师很难构建。据估计，设计一个小时的内容需要多达200-300个小时的专家设计工作[3]，尽管更新的设计技术已将其减少到50-100个小时[4]。我们的工作旨在开发自动分析和优化教育进度的途径。</p>
<h3 id="教育与心理学"><a href="#教育与心理学" class="headerlink" title="教育与心理学"></a>教育与心理学</h3><p>许多理论都支持适度的难度对于交往很重要[1，8，16，20，34，47]。当国际象棋选手的排名略高于他们时[1]，最不愉快的情况。对非竞技游戏的进展分析也支持中等难度的使用[44]。 Csikszentmihalyi的流量理论规定，当挑战既不太高又不太低时，人们最会参与其中[16]。 Vygotsky的近端发展区[59]规定，学习者可以在一定指导下获得一系列概念，而教育内容应继续以此为目标。Reigeluth和Stein的阐述理论[55]认为，简单概念的首先应教授一项任务，然后逐步讲解原始任务，然后逐步进行更复杂的任务。 Li等。通过使用机器学习代理检查问题排序来研究问题排序，发现交错的问题排序比阻塞的排序导致更快的学习[43]。当前，我们缺乏实用的，自动的方法来定量描述这些原理并将其应用于实际的进步，而我们的工作旨在做到这一点。</p>
<h3 id="语言教育"><a href="#语言教育" class="headerlink" title="语言教育"></a>语言教育</h3><p>Krashen [42]提出要以可预测的顺序（自然顺序假设）学习概念，并且当学习者接触的语言超出了他或她所能理解的范围（输入假设）时，就会发生语言习得。 语言学习文献中有广泛的证据表明，学习者在使用语法语素[30]，动词否定[13、62]，问题[52]，所有格确定语[61、66]，相对 条款[29、38]和时间参考[48]。 我们的工作旨在创建一个平台，以评估这些理论并确定它们是否能够激发扎根的学习进展，从而促进学习和参与度的提高</p>
<h3 id="基于跟踪的部分排序"><a href="#基于跟踪的部分排序" class="headerlink" title="基于跟踪的部分排序"></a>基于跟踪的部分排序</h3><p>Andersen提出了一种通过对要学习的过程进行静态分析来自动探索任务进度空间的技术[6]。该技术通过分析在该任务上运行过程所获得的执行跟踪来表征任务。通过将每个任务描述为基本操作的序列，可以指定排序问题难度的部分排序。实验证明，这种部分排序可以与用户在教育代数游戏中对困难的感知相匹配[6]。基于轨迹的框架已应用于数学[6]，视频游戏级设计[11]和教学泰语[5]。这项工作还使用了测试输入生成工具，例如Pex [58]和FShell [36]，它们系统地创建具有高代码覆盖率的测试用例套件，以对所有可能的跟踪（在一定范围内）产生问题。但是，此框架不能应用于非过程性主题。例如，尚不清楚如何分析人类如何理解自然语言的执行轨迹。我们在此工作的基础上提出了问题分解和组织的通用框架，该框架可以应用于非过程教育领域，例如语言学习。在此框架内，我们可以衡量学生的能力并预测学生在新问题上的表现</p>
<h3 id="知识评估：IRT和KST"><a href="#知识评估：IRT和KST" class="headerlink" title="知识评估：IRT和KST"></a>知识评估：IRT和KST</h3><p>响应理论（IRT）为知识评估提供了一个框架[26，27，54]。 IRT认为，对某个项目做出正确反应的概率是项目参数和个人能力的函数[32]。勋爵等。提出了3PL模型[46]，该模型考虑了三个项目参数：项目难度，项目歧视和猜测概率。 Rasch [53]提出了一个更简单的模型，该模型规定正确答案的可能性仅由学生的能力和项目难度之间的差异来确定。然而，IRT模型的一个共同缺点是，它们使用一维数值分数来衡量学生的能力和项目难度[28]，这并不反映出学生可能会根据自己掌握的知识而发现各种困难的子集。衡量学生能力和捕获此类差异的问题难度之间差异的方法。我们使用从在线知识评估平台收集的用户数据验证此模型。</p>
<p>知识空间理论（KST）是用于研究知识的层次结构和强大的知识评估工具的公认观点[23，24]。有几种基于KST的辅导系统，例如Alexs [28]，RATH [35]和一种用于学习有机化学的辅导系统[57]。根据KST，学生的知识表示为知识状态，即学生可以解决的一系列问题。问题被组织成一个知识结构，其中包含所有可能的知识状态以及这些状态之间的联系[2，40，41]。研究人员提出了构建知识结构的方法，例如查询专家[41]和贝叶斯推理[21]。由于表示知识状态的复杂性，Falmagne等人。引入了“边缘”的概念来表征学生的知识，可以通过基于“熵”的方法来计算[28]。我们在此工作的基础上提出了一种自动框架，该框架可以将问题分解成其先决条件的基本技能，并为一系列问题建立层次结构。然后，我们的框架可以通过测量学生在该结构中的能力与问题之间的关系，来预测学生在新问题上的表现。</p>
<h2 id="非过程技能的部分排序"><a href="#非过程技能的部分排序" class="headerlink" title="非过程技能的部分排序"></a>非过程技能的部分排序</h2><p>为了选择适合每个学生的难易程度的练习问题，我们需要一个层次结构来编码问题之间的难度关系。 一种简单的方法是请专家指定这些关系。 但是，随着问题集的规模越来越大，这变得异常困难。 理想情况下，我们将具有自动组织问题的方法。</p>
<p>在先前的工作中[6，12]，研究人员为过程任务建立了部分排序图。 这项工作使用过程执行跟踪来组织内容，并对这些跟踪进行部分排序以创建分层的内容结构。 例如，一个人可以识别出解决整数加法问题所需的至少四个基本技能：不带进位的一位数字加法（A），不带进位的一位数字加法（B），写进位（C） ，然后放下最后一个进位（D）。 例如，问题可以分解为以下基本技能</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>2+3</th>
<th>15+18</th>
<th>93+15</th>
<th>298+865</th>
</tr>
</thead>
<tbody><tr>
<td>追溯</td>
<td>A</td>
<td>ACB</td>
<td>AACD</td>
<td>ACBCBD</td>
</tr>
</tbody></table>
<p>但是，在某些领域（例如语言学习）中，目标对象的知识无法轻松地建模为单个过程。要在此类领域引入层次化的知识结构，我们需要对过程领域进行泛化。为此，我们的框架利用了组合性这一概念，即可以将问题分解为较小的概念单元。在一些半程序领域，例如数学和语言学习中，对此进行了充分的研究[6，60]。</p>
<p>例如，日语句子可以分解为语法模板，专家语言教师和语言学家认为语法单元是最重要的语法知识，并让学生实际学习语言课程。这些模板已被证明对语言学习者的文本难度评估很有帮助[60]。我们发现，语法理解日语句子的特定任务可以分解为（多个）语法模板集。例如，这是三个日语句子及其语法模板</p>
<img src="/post/fit5152-a1-paper/image-20210112002236844.png" class="" title="image-20210112002236844">

<p>我们可以看到S1只有一个语法模板：（–の）。对于日语学习者来说，S2比S1更难，因为它不仅具有（–の）而且还有另一个模板（–は）。 S3重复相同的模板（–の）两次，因此也比S1难。 这些关系无法通过[6]中的部分排序来捕获，因为尚不清楚如何程序化人类如何理解这些句子的过程。 但是，通过考虑概念的多集而不是执行跟踪，我们可以按如下方式容纳它们：</p>
<p>**定义1a. ** 一个问题可以分解为问题所需的一系列概念（基本技能）。 由于问题可能会要求学生重复一次或多次重复某些技能，因此我们使用一组表示为p(s)的基本技能来表征问题的难度</p>
<p><strong>定义1b</strong>。我们说，如果且仅当p（s1）⊒ p（s2）时，问题s1至少与s2一样困难，表示为s1≥s2。 这意味着，如果学生能够解决s1，那么他/她也必须能够解决s2 [6]</p>
<p>这里⊒表示多集之间的超集关系。 如果是p（s1）⊒（s2），那么对于问题2次所需的任何概念c，也至少也需要1次。例如，AABC⊒ABC为true，而AABCC⊒ABBC为true，因为ABBC有两个“ B”，而AABCC只有一个</p>
<p><strong>定义1c</strong>。严格偏序1&gt; s2定义为s1≥s2^s2≱s1，这意味着s1（严格来说）比s2难。</p>
<p><strong>定义1d</strong>。如果说且仅当s1&gt; s2并且没有其他问题3使得s1&gt; s3&gt; s2，我们说问题1比s2更难</p>
<p>使用定义1d，我们为一系列问题构建了层次结构，如下所示：</p>
<p><strong>定义2</strong>.我们将一组问题S = {s1，s2，···}（我们称为普遍问题集）组织为偏序图G = 〈S，E〉，其中</p>
<img src="/post/fit5152-a1-paper/image-20210112005148577.png" class="" title="image-20210112005148577">

<p>即，当且仅当sj比si直接困难时，才在部分排序图中存在从问题si到sj的（定向）边。 图1显示了部分排序图的示例。</p>
<img src="/post/fit5152-a1-paper/image-20210112005317740.png" class="" title="image-20210112005317740">

<p>图一（部分排序图中的学生知识边界。 大写字母表示概念，带有字符串的节点表示问题。 学生可以解决绿色问题，而不能解决红色问题。 从每个问题到知识边界的距离以d表示。 空问题s0是一个焦虑问题，被添加来帮助我们计算距离）</p>
<p><strong>定义3</strong>.我们用知识边界K衡量学生的能力，知识边界K是学生可以解决的最困难的问题。 形式上，如果这是学生可以解决的问题集，则</p>
<img src="/post/fit5152-a1-paper/image-20210112172807977.png" class="" title="image-20210112172807977">

<p>以图1中的偏序图为例。 假设一个学生可以解决问题A，AB，B，AABC和BCC（图中的绿色节点），而不能解决ABCB，D或ABCBD（图中的红色节点）。 然后，知识边界仅包含两个问题：AABC和BCC，因为没有其他“绿色”问题比AABC或BCC难。 知识边界不包括A，AB或B，因为存在一个“绿色”问题AABC，比所有问题都难</p>
<h2 id="计算知识边界"><a href="#计算知识边界" class="headerlink" title="计算知识边界"></a>计算知识边界</h2><p>We present a graph coloring algorithm of calculating a stu-dent’s knowledge boundary in the partial ordering graph. Thisalgorithm is based on two properties of the partial ordering: ifa student can solve problems, he must be able to solve anyproblems′that is at most as hard as s(s≥s′); if a studentcannot solve problems, he must not be able to solve any prob-lems′that is at least as hard as s(s′≥s).  For example, if astudent can solve problem AB, he/she can also solve problemsA and B; if a student cannot solve problem ABCB, then he/she cannot solve problem ABCBD either.</p>
<p>我们提出了一种图形着色算法，用于计算部分排序图中学生的知识边界。 该算法基于偏序的两个属性：如果一个学生能够解决问题，那么他必须能够解决至多像s(s≥s’)一样困难的任何问题。 如果学生不能解决问题，则他必须不能解决至少与 s(s’≥s) 一样困难的任何问题。 例如，如果学生可以解决问题AB，那么他/她也可以解决问题A和B； 如果学生不能解决问题ABCB，那么他/她也不能解决问题ABCBD。</p>
<p>At the start of the algorithm, all the problems (nodes) in thepartial ordering graph are uncolored. The algorithm asks thestudent whether he/she can solve some problem s*.  If thestudent can solve s*, all the nodes that are at most as hard as s*(including s* itself) will be colored ‘solvable’; if the studentcannot solve s*, all the nodes that are at least as hard as s* (including s* it self) will be colored ‘unsolvable’.  Figure 2 shows how this coloring process works.</p>
<p>在算法开始时，部分排序图中的所有问题（节点）都是未着色的。 该算法询问学生是否可以解决某些问题s*。 如果学生能够求解s*，则所有与s*一样难的节点（包括s*本身）将被着色为“可求解”； 如果学生不能求解s*，则所有至少s*同等困难的节点（包括s*自身）将被着色为“无法解决”。 图2显示了此着色过程的工作方式。</p>
<p>The algorithm repeatedly selects an uncolored problem s* from the partial ordering graph, asks the student to solve it, and then updates the coloring of the graph based on the response. Thisis a greedy algorithm designed to minimize the number ofproblems that must be given to the student.  Formally, if $n^+_s$ denotes the number of the uncolored problems that are at mostas hard as $s$, and $n^-_s$denotes the number of the uncolored problems that are at least as hard as s, then we can maximize thenumber of problems that can be colored based on the student’s response by greedily selecting a problem s* as follows:</p>
<p>该算法从偏序图中反复选择一个无色问题s*，要求学生解决它，然后根据响应更新该图的颜色。 这是一种贪心算法，旨在最大程度地减少必须给学生的问题。 形式上，如果$n^+_s$ 表示最多没有硬色问题的无色问题的数量，而 $n^-_s$表示至少至少像s一样硬的无色问题的数量，那么我们可以使可以 通过贪婪地选择问题s*，根据学生的回答进行着色：</p>
<img src="/post/fit5152-a1-paper/image-20210112191104189.png" class="" title="image-20210112191104189">

<h2 id="预测特定问题的表现"><a href="#预测特定问题的表现" class="headerlink" title="预测特定问题的表现"></a>预测特定问题的表现</h2><h3 id="到知识边界的距离-Distance-to-Knowledge-Boundary"><a href="#到知识边界的距离-Distance-to-Knowledge-Boundary" class="headerlink" title="到知识边界的距离 Distance to Knowledge Boundary"></a>到知识边界的距离 Distance to Knowledge Boundary</h3><p>In order to recommend problems at appropriate difficulty levels to the students, we need to predict students’ performanceon problems. Existing IRT studies have proposed several popular models stipulating how student performance is related tostudent ability [46, 53].  However, they measure a student’sability and the difficulty of a problem using unidimensionalnumeric scores, which is incomprehensive [28].</p>
<p>为了向学生推荐适当难度的问题，我们需要预测学生在问题上的表现。 现有的IRT研究提出了几种流行的模型，这些模型规定了学生的表现与学生能力之间的关系[46，53]。 但是，他们使用一维数字分数来衡量学生的能力和问题的难度，这是不全面的[28]。</p>
<p>Ideally, prediction of a student’s performance would utilizemultidimensional metrics to measure the distance between aproblem and what a student already knows. The key technicalchallenge in the design of multidimensional metrics is thatit is impossible to measure this distance without taking intoaccount the hierarchical structure of the problem space. In ourframework, we can measure this as the distance from the prob-lem to the knowledge boundary in the partial ordering graph.We use signed numbers to distinguish which ‘side’ of theknowledge boundary a problem is on: problems ‘inside’ theboundary (which the student can solve) have positive distanceswhile problems ‘outside’ the boundary (which the student can-not solve) have negative distances.  Using this distance, wecan leverage IRT models to predict a student’s performanceon new problems.</p>
<p>理想情况下，对学生成绩的预测将利用多维指标来衡量问题和学生已经知道的知识之间的距离。 多维度量设计中的关键技术挑战是，如果不考虑问题空间的层次结构，就无法测量该距离。 在我们的框架中，我们可以用偏序图中图中从问题到知识边界的距离来衡量这个问题。 学生可以解决）的距离为正，而“超出”边界的问题（学生无法解决的）的距离为负。 利用此距离，我们可以利用IRT模型来预测学生在新问题上的表现。</p>
<p>Here, we give the definition of this distance together with theexamples in Figure 1. Assume we have the universal problem set S, and a student can solve a subset of problems T.  For example, in Figure 1,S={A, AB, B, AABC, BCC, ABCB, D,ABCBD},T={A, AB, B, AABC, BCC}, and the knowledge boundary K={AABC, BCC}. We calculate the distance fromany problems∈Sto the knowledge boundaryK, indicated as d(s, K), following the steps below:</p>
<p>在这里，我们给出该距离的定义以及图1中的示例。假设我们有通用问题集S，并且学生可以解决问题T的子集。例如，在图1中，S = {A，AB， B，AABC，BCC，ABCB，D，ABCBD}，T ＝ {A，AB，B，AABC，BCC}，知识边界K ＝ {AABC，BCC}。 我们按照以下步骤计算从任何问题∈S到知识边界K的距离，表示为d(s, K)：</p>
<p><em>Step 1: Calculate distances for problems on the boundary</em></p>
<p><em>步骤1：计算边界上问题的距离对于任何问题，</em></p>
<p>For any problemssuch thats∈K,d(s,K) =0.</p>
<p>对于任何问题s使得s∈K，d(s, K)= 0</p>
<p>For example, the distance of problems AABC and BCC is 0</p>
<p>例如，问题AABC和BCC的距离为0例如，问题AABC和BCC的距离为0</p>
<p><em>Step 2: Calculate distances for problems inside the boundary</em></p>
<p><em>步骤2：计算边界内问题的距离</em></p>
<p>For any problem s such that s∈T−K, based on the definition of K, there must be one or more s′∈K such that s′≥s (otherwise, s should be contained in K) , and</p>
<p>对于基于s的定义s∈T-K的任何问题s，必须存在一个或多个s′∈K使得s′≥s（否则s应该包含在K中），并且</p>
<img src="/post/fit5152-a1-paper/image-20210112211143812.png" class="" title="image-20210112211143812">

<p>where d is(s,s′) indicates the length of the shortest directed path from s to s′ in the partial ordering graph.  If there is no directed path from s to s′,  dis(s,s′) =∞.  Note that if  s′≥s  ,then there must exist at least one directed path from s′ to s.</p>
<p>其中d is（s，s’）表示部分排序图中从s到s’的最短定向路径的长度。 如果没有从s到s’的定向路径，则dis（s，s’）=∞。 请注意，如果s’≥s，则必须存在至少一条从s’到s的定向路径。</p>
<p>For example, the distance of problem AB is 1, since prob-lem AABC, which is on the knowlegde boundary, is directlyharder than AB. Similar for problem B (BCC is direclty harderthan B). The distance of problem A is 2, since the shortest di-rected path from A to any problem on the knowledge boundary(which is A→AB→AABC) has length 2</p>
<p>例如，问题AB的距离为1，因为在知识已知边界上的问题AABC比AB直接困难。 与问题B相似（密件抄送比B硬）。 问题A的距离为2，因为从A到知识边界上任何问题的最短定向路径（A→AB→AABC）的长度为2</p>
<p><em>Step 3:Calculate distances for problems outside the boundary</em></p>
<p><em>步骤3：计算边界外问题的距离</em></p>
<p>In a hierarchical knowledge structure, it follows intuitively thatproblems that are further away from the boundary will be moredifficult to the student. Therefore, for any problemssuch thats∈S−T, we define the distanced(s,K)to be shortest directedpath from any problem inTtos. Note that this distance alsohas a teaching interpretation: if easier problems should alwaysbe taught before harder problems [55], then this distance alsomeasures the number of problems that need to be taught beforeteachings.</p>
<p>在分层的知识结构中，直观地认为，远离边界的问题对学生而言将更加困难。 因此，对于诸如s∈ST的任何问题，我们将距离（s，K）定义为距Ttos中任何问题最短的有向路径。 注意，这个距离也有一个教学上的解释：如果总是在较困难的问题之前总是先教更容易的问题[55]，那么这个距离也可以衡量在教学之前需要教的问题数量。</p>
<p>ince there are some basic problems that have no problemseasier than them, and thus have no incoming edges in the par-tial ordering graph, there is not always a path from a probleminTtos.  For instance, there is no directed path from anyproblem inTto problemDin Figure 1.  To resolve this, weadd anull problems0, the pseudo problem with no prerequisiteconcepts, toT. For any problems∈S−T, if there is no otherproblems′such thatsis directly harder thans′(namely,shas no incoming edges), we add an edge(s0,s)to the partialordering graph</p>
<p>由于存在一些基本问题，没有比这些问题更容易解决的问题，因此在空间排序图中没有传入的边，因此从问题中获取问题的路径并不总是那么容易。 例如，图1中没有从任何问题到问题D的直接路径。要解决此问题，我们将无问题先决条件的伪问题anull问题0添加到T。 对于任何问题∈ST，如果没有其他问题’使假设比’s’直接困难（即没有进入的边），我们将偏边（s0，s）添加到偏序图</p>
<p>Now there is at least one directed path from the null problem s0 or some problem in T to s. We can define the distance as:</p>
<p>现在，从空问题s0或T tos中的某个问题开始，至少有一条有向路径。 我们可以将距离定义为：</p>
<img src="/post/fit5152-a1-paper/image-20210112234958809.png" class="" title="image-20210112234958809">

<p>Note that d(s,K) is negative if and only if s is outside the knowledge boundary.For example, the distance of problem ABCB is -1, since itis directly harder than the “green” problem AB. Problem D has no incoming edges in the partial ordering graph, hence weadd an edge from the null problem s0 to D, and the distanceof problem D is -1 since the path s0→D has length 1. Lastly,the distance of problem ABCBD is -2.  Actually, there aretwo shortest paths with length 2: AB→ABCB→ABCBD ands0→D→ABCBD.</p>
<p>请注意，当且仅当s在知识边界之外时，d(s, K)才为负。例如，问题ABCB的距离为-1，因为它比“绿色”问题AB直接困难。 问题D在偏序图中没有输入边，因此我们将零问题s0到D加上一条边，并且由于路径s0→D的长度为1，因此问题D的距离为-1。最后，问题ABCBD的距离为 -2。 实际上，有两条最短的路径，其长度为2：AB→ABCB→ABCBD和s0→D→ABCBD。</p>
<p>The  metric  of  distance  is  dependent  on  the  density  of  thepartial-ordering graph. This is inevitable since the measure-ment is based on the hierarchical structure of the problemspace. We believe that for most well-defined problem spaces,it is a reasonable assumption that the partial ordering graph will be sufficiently dense.  We will demonstrate this metricworks well for a well-built Japanese language learning corpusin the next section</p>
<p>距离的度量取决于偏序图的密度。 这是不可避免的，因为测量是基于问题空间的层次结构。 我们认为，对于大多数定义明确的问题空间，可以合理地假设偏序图将足够密集。 我们将在下一部分中很好地演示此度量标准，以构建完善的日语学习语料库。</p>
<p>In the later part of this paper, we will use d to denote d(s,K) for convenience</p>
<p>在本文的后半部分，为方便起见，我们将使用d来表示d(s, K)。</p>
<h3 id="Adapted-Rasch-model-改编的Rasch模型"><a href="#Adapted-Rasch-model-改编的Rasch模型" class="headerlink" title="Adapted Rasch model 改编的Rasch模型"></a>Adapted Rasch model 改编的Rasch模型</h3><p>In this section, we describe how we can adapt existing uni-dimensional IRT models to build a multidimensional metricthat leverages the partial ordering graph and the distance d calculated in the previous section in order to predict studentperformance.  One of the most famous models of IRT, the Rasch model [53], stipulates that a student’s performancePis a function of the difference between the student’s ability θ and the problem’s difficulty b</p>
<p>在本节中，我们描述如何适应现有的一维IRT模型以建立多维度量标准，该度量标准利用上一节中计算的偏序图和距离d来预测学生的表现。 Rasch模型[53]是IRT最著名的模型之一，它规定学生的表现是学生的能力θ与问题难度b之差的函数。</p>
<img src="/post/fit5152-a1-paper/image-20210113085907577.png" class="" title="image-20210113085907577">

<p>xxx</p>
<p>In  the  next  section,  we  will  demonstrate  that  this  adaptedmodel nicely fits the data collected from our knowledge as-sessment platform</p>
<p>在下一节中，我们将证明该适应模型非常适合从我们的知识评估平台收集的数据</p>
<h2 id="知识评估的评价-EVALUATION-OF-KNOWLEDGE-ASSESSMENT"><a href="#知识评估的评价-EVALUATION-OF-KNOWLEDGE-ASSESSMENT" class="headerlink" title="知识评估的评价 EVALUATION OF KNOWLEDGE ASSESSMENT"></a>知识评估的评价 EVALUATION OF KNOWLEDGE ASSESSMENT</h2><p>In this section, we will the evaluate our calculation of the knowledge boundary and the distance represented in the previous section by applying it to a Japanese language learning domain.</p>
<p>在本节中，我们将评估我们的知识边界与上一节中表示的距离的计算并把它应用到一个日语学习领域。</p>
<h3 id="语言评估平台-J100-A-Language-Assessment-Platform"><a href="#语言评估平台-J100-A-Language-Assessment-Platform" class="headerlink" title="语言评估平台 J100: A Language Assessment Platform"></a>语言评估平台 J100: A Language Assessment Platform</h3><p>xxx</p>
<h3 id="Reddit部署-Reddit-Deployment"><a href="#Reddit部署-Reddit-Deployment" class="headerlink" title="Reddit部署 Reddit Deployment"></a>Reddit部署 Reddit Deployment</h3><p>xxx</p>
<h3 id="验证知识边界和距离度量-Validating-the-Knowledge-Boundary-and-Distance-Metric"><a href="#验证知识边界和距离度量-Validating-the-Knowledge-Boundary-and-Distance-Metric" class="headerlink" title="验证知识边界和距离度量 Validating the Knowledge Boundary and Distance Metric"></a>验证知识边界和距离度量 Validating the Knowledge Boundary and Distance Metric</h3><p>In order to validate our calculation of the knowledge boundaryand the distance metric, we will demonstrate that the user datacollected from J100 nicely fits the adapted Rasch Model. Wecalculate a user’s knowledge boundaryKbased on his/her responses to the problems in the assessment stage, and foreach problemsresponded in the evaluation stage, we measurethe distance from the problems to the knowledge boundary K.The user responses in the evaluation stage can be regarded as users’ self-estimation of their performance, and we score thefive possible responses uniformly from 1 to 0</p>
<p>为了验证我们对知识边界和距离度量的计算，我们将证明从J100收集的用户数据非常适合改编的Rasch模型。 我们根据用户在评估阶段对问题的回答来计算用户的知识边界K，并针对评估阶段所回答的每个问题，测量从问题到知识边界K的距离。评估阶段中的用户响应可视为用户 对他们的表现的自我评估，我们从1到0对5个可能的回答进行了统一评分</p>
<h2 id="过程分析-PROGRESSION-ANALYSIS"><a href="#过程分析-PROGRESSION-ANALYSIS" class="headerlink" title="过程分析 PROGRESSION ANALYSIS"></a>过程分析 PROGRESSION ANALYSIS</h2><p>良好的进步会增强学生对课程的参与度[43,56]，我们的工作旨在发现良好的进步的一般特征。 在本节中，我们将利用我们的框架来分析教育进度，并介绍良好进度的两个重要特征：组成Composition和步调Pace。 我们研究了现有课程，并证明了专家设计的课程中一些惊人的相似之处</p>
<h3 id="组成：学习与复习的平衡-Composition-The-Balance-of-Learning-and-Review"><a href="#组成：学习与复习的平衡-Composition-The-Balance-of-Learning-and-Review" class="headerlink" title="组成：学习与复习的平衡 Composition: The Balance of Learning and Review"></a>组成：学习与复习的平衡 Composition: The Balance of Learning and Review</h3><p>在设计教育进度时，一个关键的考虑因素是应该花多少时间来增强以前引入的知识，而不是引入新知识。 另一个需要考虑的问题是，通过以新的方式将概念组合在一起，进度是否应该越来越复杂。 理想情况下，我们将能够定义可以简洁地捕获这些重要方面的进度参数空间</p>
<p>xxx</p>
<p>我们可以认为强化是对已学知识的回顾，引入是纯学习，重组是两者的混合。 这三种类型的比例揭示了设计师在教育进步中平衡学习和复习的策略，我们将其称为进步组成</p>
<h3 id="步调：知识的增长率-Pace-The-Growth-Rate-of-Knowledge"><a href="#步调：知识的增长率-Pace-The-Growth-Rate-of-Knowledge" class="headerlink" title="步调：知识的增长率 Pace: The Growth Rate of Knowledge"></a>步调：知识的增长率 Pace: The Growth Rate of Knowledge</h3><p>我们想知道进度中课程（章节，单元等）的难度是否以一致的速度增长，从而使学生可以顺利学习。 我们不是通过数字来衡量每节课的难度，而是计算知识的大小，即每节课之前引入的问题总数。 这可以用通用问题集5S中的问题数量来衡量，该数量被学生的知识边界归类为强化。在掌握了从一开始到当前课程的所有知识之后。 因此，知识大小| K |就是此类问题的数量</p>
<h2 id="进度分析的评估"><a href="#进度分析的评估" class="headerlink" title="进度分析的评估"></a>进度分析的评估</h2><h3 id="教材研究"><a href="#教材研究" class="headerlink" title="教材研究"></a>教材研究</h3><h3 id="在线语言学习工具研究"><a href="#在线语言学习工具研究" class="headerlink" title="在线语言学习工具研究"></a>在线语言学习工具研究</h3><h2 id="自动渐进合成"><a href="#自动渐进合成" class="headerlink" title="自动渐进合成"></a>自动渐进合成</h2><p>We have discussed two features of an educational progression:composition and pace.  In this section, we will demonstratethat educational progressions can be automatically synthesizedaccording to specific composition and pace parameters. To bemore precise, a progression can be characterized as three nu-meric parameters: overall pace (pace), proportion of reinforce-ment (ri), and proportion of introduction (in). The proportionof recombination (rc) is redundant since ri+rc+in=1.</p>
<p>我们讨论了教育进步的两个特征：组成和步调。 在本节中，我们将<strong>证明可以根据特定的构成和速度参数自动合成教育进度</strong>。 更准确地说，可以将进度表示为三个数字参数：总体步速（步幅），增强比例（ri）和引入比例（输入）。 重组比例（rc）是多余的，因为ri + rc + in = 1</p>
<p>We use a greedy algorithm to synthesize progressions.  Thealgorithm starts with an empty progression, repeatedly selectsthe next problem that minimizes the following error function and appends it to the progression:</p>
<p>我们使用贪婪算法来合成进度。 算法以空的级数开始，重复选择下一个使后继误差函数最小化的问题，并将其附加到级数上</p>
<img src="/post/fit5152-a1-paper/image-20210112094950772.png" class="" title="image-20210112094950772">

<p>其中pace, ri, in 都是实际的渐进特性，而pace*, ri*, in*是所需的渐进参数。请注意，可能存在多个具有最小误差的问题。 在这种情况下，我们的算法会从中随机选择一个作为下一个问题</p>
<p><strong>这种贪婪算法并不总是生成具有准确所需参数的级数</strong>。 但是，它运行得非常快。对于一个包含25个问题的通用问题集，它可以在一秒钟内合成100多个进程（每个进程有10个问题），因此，我们可以多次运行此贪婪算法以合成具有所需特征的进程</p>
<p>表2列出了合成过程的四个例子。 我们从Genki进程中提取了以下参数：pace= 0.465，ri = 0.582，in = 0.214。 然后，我们使用这些参数（大约）来合成“ Genki Simulation”进度。 我们还生成了另外三个带有量身定制的参数的进度，这些进度偏向于加强，重组和引入。 这些结果表明，<strong>我们不仅可以利用专家级进度设计的原理并使用对大多数学生都有利的参数来综合进度，而且还可以为具有特定偏好的学生量身定制进度</strong></p>
<img src="/post/fit5152-a1-paper/image-20210112095315867.png" class="" title="image-20210112095315867">

<h2 id="结论与未来工作"><a href="#结论与未来工作" class="headerlink" title="结论与未来工作"></a>结论与未来工作</h2><p>可学习性对于HCI的许多方面都很重要：用户界面，学习工具，视频游戏和软件可用性。 在本文中，我们定义了一个框架，<strong>该框架利用自动问题分解和部分排序图构造来促进与教育相关的多个工作流程：评估学生的知识，确定和描述课程的学习策略以及设计新的学习进度</strong>。 我们以多种方式评估了该框架：通过在线部署日语评估工具，自动从现有课程中提取起搏参数，以及将问题组合成符合所需起搏特征的新项目</p>
<p>我们希望将我们的框架用于几个教育领域，尤其是计算机辅助语言教育。 例如，我们计划利用我们的框架向第二语言学习者推荐适当的阅读材料，并改善用于语言学习的教育游戏[17，18]。 将来，我们不仅将框架应用于语法知识，还将应用于语言学习的其他方面，例如词汇和语义</p>
<p>我们希望这些想法将有助于实现一门进行性分析的科学，在该科学中，可以从涉及多个主题的进展中提取出测序和起搏参数，以识别最佳原则。 此外，我们希望扩展此框架，以便它可以自动构建能够快速进行初始评估和进度调整的自适应学习系统</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>UI</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>工程项目管理应用的低存储量区块链实现</title>
    <url>/post/state-chain-on-pm-paper/</url>
    <content><![CDATA[<p>区块链不仅仅构造了数字货币，作为可信底层架构，区块链通过保存历史信息提供了可追溯的功能。该功能在获得用户信任基础上，保证了产品可信度，降低业务审查、清算等会计成本。状态区块链是一种比传统区块链更加激进的区块链底层架构，它选择了不保存所有历史，而是选择通过总结来归纳出每个可信区段中所有账户的状态，从而实现在现有可信基础上更加灵活的应用部署，彻底摆脱了原本对每个节点存储空间的苛刻要求。工程建设过程中随着工程的推进，尤其是大工程，工程管理对于可信基础上的账簿、设备以及合同等元素管理的需求越加强烈。但由于工程环境及项目成本的限制，相比传统区块链，状态区块链应更具优势。</p>
<p>本文中，在对区块链相关技术进行综述的基础上，对市场上的低存储量区块链技术进行了比较分析，提出了基于状态的低存储量区块链的实现方案和部署思路。然后，在工程项目管理领域中，对提出的低存储量区块链进行了实现和场景分析，表明本文所提方案在保障区块链安全性的基础上，具有项目成本优势。</p>
<span id="more"></span>

<p><strong>论文<a href="/state-chain-on-pm-paper.pdf">PDF标准版下载</a></strong></p>
<h2 id="区块链中存储的成本"><a href="#区块链中存储的成本" class="headerlink" title="区块链中存储的成本"></a>区块链中存储的成本</h2><p>首先，随着技术的提高，假定存储数据的成本呈指数级下降。我们则可得到一个这样的模型</p>
<p>$$c(t)=Ae^{-kt}$$</p>
<p>c(t)是在任何给定年份t中存储1GB数据的成本。</p>
<p>A是当前按存储1GB1年的成本。通过Amazon Elastic File System进行定价。使用EFS，全年存储1GB数据的6个副本的成本为每年21.60美元。即A=21.60美元。</p>
<p>k是存储成本随着时间推移下降的速度。k越大，价格越快降低。根据过去35年的历史数据，k约为0.2502，但对未来存储成本的预测表明未来这种变化率会下降。</p>
<p>这可以得出我们在任何一年内将要花费的存储容量。现在我们可以计算我们的存储总成本。</p>
<p>每年我们必须为当年收到的新数据支付费用，并继续存储前几年的所有数据。所以每年的存储成本为：</p>
<p>$$S(t)=c(t)\sum_{T=0}^nPredictedGB(t)$$</p>
<p>由于众所周知的区块链扩容，比如比特币从1MB过渡到2MB，模型中的Predicted_GB本质也是在逐年增加的值。随着数字货币与区块链逐步被越来越多的人所认可，区块容量(BuiltinSize)增加的步伐也越来越快。作为激进的比特币分叉，比特币现金，已经分叉至32MB。从市场来看，越是热门的区块链产品的信息存储量增速越快。而热门程度我们可以根据其代币的交易量来判断。</p>
<p>$$PredictedGB(t)=\sum_{d=0}^{365}BuiltinSize \times Volume(t,d)$$</p>
<p>那么最终的每年存储成本即为：</p>
<p>$$S(t)=Ae^{-kt}\sum_{T=0}^n\sum_{d=0}^{365}BuiltinSize \times Volume(t,d)$$</p>
<p>总而言之，通过该模型，我们可以清晰地看出，这通过优化后的区块链存储成本模型，最终其是递增膨胀，还是逼近指数下降，取决于科技发展的k值（&lt;1）与年存储量，也可以说是k值与产品热度之间的博弈。作为跑赢市场的明星产品，例如Ethereum，必面临存储量爆炸的问题。当然从一般角度来看，<strong>服务器</strong>硬盘的发展是完全超越一般的区块链增长的。</p>
<p>但是在特定环境，尤其是分布式的物联网环境，区块链上为了实现分布式与数据可信，设备往往分散且数量可观。因此，实际在物联网或多节点等正常区块链环境下，当区块链应用全网设备数为DeviceNum时，存储成本为：</p>
<p>$$S(t)=DeviceNum \times Ae^{-kt}\sum_{T=0}^n\sum_{d=0}^{365}BuiltinSize \times Volume(t,d)$$</p>
<p>也因此，为了节约成本，项目往往选择具有较少的存储空间的设备，这就更进一步限制了区块链存储不能无限制地膨胀。因此，换句话来说，在存储成本较低基础之上，倘若能够限制住区块链数据存储的膨胀，区块链产品则能够部署于更广泛的领域。</p>
<h3 id="区块链在工程管理中的应用"><a href="#区块链在工程管理中的应用" class="headerlink" title="区块链在工程管理中的应用"></a>区块链在工程管理中的应用</h3><p>到目前为止，区块链在建造行业中的实际使用并不常见。有些人正在使用它结合物联网来存储建筑物的传感器数据。还有人认为类似以太坊的分布式平台可以托管BIM应用程序。也有人提到区块链在合建项目中的应用，因为它可以提供一个有用的工具，通过使用智能合约，监控各方在整个设计和施工阶段管理和记录上对BIM模型的更改，即通过编辑和存储建筑模型的所有修改记录到不可变的公共记录中（区块）。</p>
<p>首先，众所周知的是，区块链可以作为数字账簿的存在，如hyperledger，中文名超级账簿。</p>
<p>当前，企业间的战略联盟（partnering模式）中，由于各个企业仍然是独立法人，战略联盟中经常会发生由于道德风险、逆向选择等问题造成的联盟合作关系不稳定。因此，目前急需一种合理的激励机制，保障供应链联盟之间的信息开放共享来防止问题发生。因此，需要一种受到各方信任的信息技术手段，来支持分布式的信息记录储存，联盟中的企业从不同途径来分享多样化的信息。区块链技术的应用，在对企业共识数字化的基础上，受所有人信任，不仅能实现价值共创共享的目标，而且构建了利益相关者之间的共生关系，实现了多元资本共生和利益相关者的共同治理。万达、百度、空客、美国运通、思科、富士通、日立等国内外各个行业的大公司在战略上往往拥有更加错综复杂的联盟关系，因此其对hyperledger的需求更为强烈。除他们以外，hyperledger还有约200余个企业合作伙伴，可见世界领先的企业对区块链在账簿上应用的普遍认可。</p>
<p>虽然区块链技术为项目相关的会计更多样化的工作与管理模式提供了可能。但与金融领域相比，项目管理会计领域拥有复杂性和独特性，区块链技术在该方面应用中依然面临数据存储空间有限、业务数据处理难度高、对现有中心化记录的管理会计基础业务架构和业务规则挑战等问题。</p>
<p>更贴近工程内容的，区块链往往依托着物联网或BIM这类将传统产品信息化的载体，以此方式在工程项目之中得到运用。</p>
<p>以前的方案可用于管理存储在文件中的任何建筑物信息，包括BIM文件。然而，在BIM设置中实施区块链的正确方法是将其与BIM服务器集成。架构如图所示。</p>
<img src="/post/state-chain-on-pm-paper/BIM&BC.jpg" class="" title="BIM">

<p>Barnett正在确定建筑行业中区块链的一些用途，例如维护记录数字财产，基于时间戳记录行为或交易，多重签名交易，智能监控情况并执行自己的计算机程序以及与真实世界结合的智能合约信息存储库。还有争议中能够使用自动化区块链解决方案，基于智能合约的智慧城市，以及区块链房地产投资等也被设想出来。</p>
<!--抄论文-->
<p>Security Ledger指出，“在保卫物联网安全方面最大的挑战之一就是身份问题。更明确一点就是：我们如何确保数十亿或者百亿的智能设备相互之间的连接与交流安全。看起来区块链能够提供答案。”</p>
<p>在与区块链结合之前，物联网一直是个“矛盾的存在”，物联网的发展前景已被所有人认可，但是症结问题一直得不到解决。中心化的管理架构存在无法自证清白的问题，也即不管你是否窃取了参与方的隐私，都容易被怀疑，没有理性的方式可以证明你的清白，完全靠相互的自觉与信任。况且，个人隐私数据被泄露的相关时间时有发生，例如，摄像头被网络直播的事屡见不鲜。物联网的参与者，尤其是工程项目中物联网的参与者，通常不完全被发起方所单独掌控（例如普通私人用户、企业用户），如何让其他的合作方能够更好地参与到项目之中，面临极为复杂的协同成本。</p>
<p>但是如此看待区块链，大多是由于当今区块链产品多基于以太坊等平台，制作思维也跳脱不出数字货币的范畴。以太坊中除了CAP冲突以外，对于合约本身的进行也存在着合约不可修改、合约太过依赖主网等缺陷。这未免太过局限了其区块链应用的发展。本质上来说，区块链的应用重点在于其共识的形成，共识才是一个分布式应用与区块链应用的最大差别，最重要的，包括区块形成条件（挖矿条件）、出块时间、区块存储方式设计等各种被平台所简化的内容本应也是应用的重要内容。</p>
<p>因此除了传统的和物联网、BIM等信息元素结合以外，工程项目之中可以将生产过程、交付过程等一系列费时费力的过程量化编译成数个共识，将这些共识合并起来数字化形成针对项目的合约。</p>
<h3 id="市场上的低存储区块链方案"><a href="#市场上的低存储区块链方案" class="headerlink" title="市场上的低存储区块链方案"></a>市场上的低存储区块链方案</h3><!-- 首先是将状态作为更重要的保存内容。 -->

<p>在UTXO中，比如比特币，抛去了状态的概念，其中账户（即地址）的余额通过与它相关的事务来进行判断，例如某个地址在区块链中的出现是先通过工作证明获得了100货币单位，然后在其之后8个区块时间后它将88个货币单位转移到另一个地址中，其后没有任何相关交易。这样在当一个节点遍历完所有区块之后就可以计算出该地址余额为12个货币单位。</p>
<p>这样的产品设计，虽说要求了节点必须下载并遍历整个区块才能分析出地址余额这样累赘的工作，但是也的确非常成功地解除了他人尤其是非技术人员对区块链的怀疑——至少让区块链概念更加通俗易懂。</p>
<p>可是区块链的不断增长使得这个下载与遍历操作越来越困难。比特币核心开发者团队意识到了这个问题的严肃性。在2016年初bitcoin的区块就已经超过60G，开发者团队在新核心钱包中针对节点新加了区块链存储的修剪模式（prune）。全节点钱包，即核心钱包的使用者通过在个人目录中bitcoin.conf配置文件中，输入“prune=1024”并保存，重启钱包后即可打开节点的修剪模式。通过该模式，节点可以将60多G的存储不断删减直至你设定的值（1024mb），且相比以前能更加快速地打开钱包。但是这个模式仍有局限性——及其耗时且耗计算的同步过程：它需要先从p2p网络上下载这所有的区块，再对已下载的区块逐个进行散列计算生成散列值，并校对散列值的树结构，以此保证所下载区块的完整与安全——这样的下载过程中耗费数G的带宽流量以及堪比数字货币挖矿的计算任务依旧非个人电脑，或者非一般的服务器所能承受。尤其是在用户重新导入一个新私钥后，为了获取这个私钥对应地址的余额信息，节点必须再重复一遍上述所有操作。</p>
<p>随着时代的发展，在2016年开始行业进入了基于区块链的链上应用，即分布式应用（decentralized application，简称DApp）的时代。简单来说，DApp和普通的App原理一样，除了他们是完全去中心化的。由底层区块链网络自己的节点来运作的DApp，不依赖于任何中心化的服务器。虽然DApp是去中心化的，可以完全自动地运行，但是依然也有可能性会被入侵。为了要能够很好地使用这些DApp，就需要定制的入口。例如其中较为著名的就是Augur，一个基于以太坊的去中心化市场预测平台，完全不需要通过任何第三方服务器。目前来看，由于以太坊EVM的健壮，大部分分布式应用都是基于以太坊。</p>
<p>但是，从现状来看，如今很多区块链产品中的“永久存储”特性却仅仅只是一个吸引投资人和购买者的华丽噱头，或者说是一个非常普遍的对当下区块链模式的一种妥协现象：想要让人可信就必须永久存储所有事务。毕竟，在以太坊平台上就已经拥有了在链上存储的功能，无需再多费手脚即可拥有。</p>
<p>但是从产品设计的角度来看，在许多的特定环境下，区块链产品本质上其实并不需求永久的存储——例如游戏、匿名货币以及数据存储等。拿游戏作为例子来看，基于区块链的互联网游戏本身就是在飞速信息交换，在存储和带宽以及共识的限制下，这个交换的成本被无限放大。</p>
<p>如CryptoKitties这个在中心化时代看起来非常简单的养猫游戏。</p>
<p>CryptoKitties(加密猫)是因为一款基于以太坊的DAPP，它由设计工作室AxiomZen打造，它是一个围绕着可育，可收集和可爱生物的游戏，每只猫都是独一无二的，100％归您所有，而且它不能被复制，带走或毁坏。</p>
<p>CryptoKitties是世界上第一款基于区块链技术的游戏，这一突破使得一些像比特币和以太坊的虚拟物品成为可能。比特币和以太币是加密货币，但CryptoKitties是加密的收藏品。就像传统的收藏品一样，你可以购买，出售或交易你的CryptoKitty，在知识产权保护上，区块链会监测保障您的所有权。简单来说，就是利用链来存储了信息。</p>
<p>但是在以太坊网络中部署后，由于销量火爆，直接压垮了以太坊平台的交易传输。据悉以太坊网络在该期间平均堵了近2万笔交易。众所周知，无论是以太坊还是比特币都对每个区块限定了大小，这就决定了每次的区块打包交易中交易总数据量都有上限。对于超出上限的交易，就被拖至下个区块中打包。“近2万笔交易”，可见该应用在链上究竟写入了多少庞大的数据。</p>
<p>因此“永久存储”这个功能对于区块链应用底层来说非常容易成为网络的累赘。纵观当今部署的互联网应用，应用都是以一个“状态”实现的部署——持续集成（CI）就是这种理念的实现，通过不停的覆盖“状态”来达到工程合作的统一；同样的还有应用的持续发布，都是以最终的“状态”作为最终的目的。</p>
<p>对于此问题，以太坊选择的是利用分片技术对其网络进行扩容。</p>
<p>“分片”的大致设计思路是：将区块链网络中的每个区块变为一个子区块链，子区块链中可以容纳若干（目前为100个）打包了交易数据的Collation（大概可以称为“校验块”，为了在分片的情景中将其与区块的概念区分开），这些Collation最终组成一个在主链上区块；因为这些Collation是整体作为区块存在的，所以其数据必定是全部由某个特定的矿工所打包生成，本质上和现有协议中的区块没有区别，所以不再需要增加额外的网络确认。这样，每个区块的交易容量就大概扩大了100倍；而且这种设计还有利于未来的继续扩展，整个扩展计划目前也被大致分为4个阶段；本文所介绍的仅仅是第一阶段的相关实现细节。本质来说就是通过层叠的状态和少量的过程区块来保证性能与可信的双重获利。除此之外，以太坊在新节点部署上通过引入账户（Account）与状态（State）的概念来实现区块更加迅速的同步。其中账户即为已经出现在链上的地址，而状态即为一个时间点上账户及其相关信息的列表。</p>
<p>其实在以太坊启用分片之前，在市场上早已经出现了成型的利用类似技术的数字货币，PascalCoin，它通过pascal编程语言重写了比特币奠定的数字货币的架构，并且引入了账户和状态的概念，实现了其数字货币后台区块链的秒同步。但是，由于高度去中心化的办公模式带来的低效更新以及pascal编程语言死气沉沉的社区，目前情况来看，其在链上应用等方面的发展非常局限。</p>
<!-- pascalcoin的工作模式如图所示balabala -->
<p>简单来说，PascalCoin中的块将超过100的检查点高度新的块将附加到链的顶部，旧的块从底部删除，只有一个任何时候都将需要不断的块数。检查点在每100个区块中发生一次，并简单地压缩成SafeBox。当新节点加入网络时，它只会下载最新的检查点和几十个块。此外，SafeBox现在包含在每一个账户段子结构块头信息中。这使得节点成为能独立地计算、验证和构建SafeBox结构所需的累积工作。</p>
<p>它通过以下方式实现:</p>
<ul>
<li>检查是否所有区块头通过SafeBox以类区块链接方式连接</li>
<li>使用工作证明方式重新计算SafeBox的累积工作</li>
<li>验证是否SafeBox的累积工作是网络中最大的已知工作。</li>
</ul>
<p>因此，相比其他加密货币，PascalCoin会以指数方式达到更高的每单位存储吞吐量，因为节点只需要存储网络吞吐而不是累积的网络吞吐量。 换句话说，PascalCoin存储的是交易流，而不是交易历史 。如果流量不变，存储也是恒定的。这里要提醒的是SafeBox确实在每个区块都变得可以忽略不计，但总是在固定数量中且无论交易数量如何变化。</p>
<p>且由于节点在任何时间只需要保持100个块，所以相比其他加密数字货币，PascalCoin考虑到了以指数方式增长的更大的区块规模。例如，对于相同数量的存储，即一个Bitcoin节点在现在消耗的存储，PascalCoin理论上可以支持吞吐量为每秒72,000个交易，本地只需5.4GB区块大小。</p>
<p>从模型角度来说，传统区块链，例如比特币，区块大小起初线性增长，在触及区块上限后开启扩容分叉。</p>
<p>而状态链限制其账户增长。PascalCoin的主要新功能之一是帐户可以有唯一的公开可见的名称，与域名系统的方式大致相同。这允许用户接收资金到他们的电子邮件地址或聊天昵称。它允许商店用他们的域名或品牌名称收款。支付本质上仍然是通过数字号码来引用帐户，但是名称用于查找背后的帐号，就像是域名是用于查找背后的IP地址。</p>
<h2 id="低存储方案"><a href="#低存储方案" class="headerlink" title="低存储方案"></a>低存储方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>虽然区块链总是存在着在新块生成同时有分叉的风险，但是在旧的区块链中，各节点总是形成相同的一条无任何分叉的链</p>
<p>传统的区块链存储结构与内容如下图所示：</p>
<img src="/post/state-chain-on-pm-paper/OriginBlockchainStructure.jpg" class="" title="OriginBlockchainStructure.jpg">

<p>可见大部分数据（难度、随机数、版本号等）都存在非常严重的冗余。而交易数据根据UTXO形式，分为交易发送者、交易接受者、交易货币数量、以及交易签名。其中交易签名占空间最大且基本上是一次性数据，对区块链后续发展并无推动作用。</p>
<p>因此我们需要从区块链结构入手设计低存储区块链的设计。</p>
<img src="/post/state-chain-on-pm-paper/4NodesNetwork.png" class="" title="4NodesNetwork.png">

<p>如图中四个区块链节点形成了一个区块链网络。我们可以看到每个节点都保存了从创世区块（GenesisBlock）到N号区块（BlockN），因此从创世区块到N号区块之间的链，根据共识来说，它们就是经过了所有节点的审计且已经可以被我们认为是可信的——那么对于可信的内容，我们则无需再进行验算（尤其是私钥导入新节点接入等流程中），因而我们可以将其删除。但是为了下方（N+1）号区块以及更新的节点的安全保证，我们仍然需要k个区块来形成最长链以防止分叉。同时为了防止数据的丢失，我们也应当将从创世区块到N号区块之间的链中的数据以其他格式存储起来。</p>
<p>因此我们将创世区块到（N-k）号区块的内容整合为“状态区块”来保存内容。</p>
<img src="/post/state-chain-on-pm-paper/IntroStateBlock.png" class="" title="IntroStateBlock.png">

<p>在每过一定阶段，根据全网节点状态进行区块删减，形成由数个“状态区块”形成的“状态区块链”。但是由于状态内容的冗余与过时我们仅仅保留数个最新块。最终则形成了我们的新方案。</p>
<img src="/post/state-chain-on-pm-paper/WithBIM.png" class="" title="WithBIM.png">

<p>用公式表示原始方案与改进方案的存储量如下</p>
<p>原始方案即为直接对区块的存储。StorageSize为总存储规模，blockHeight为区块高度（个数），BlockSize为内置的区块大小，例如Bitcoin初始为1M。<br>$$ StorageSize(blockHeight) = BlockSize \times blockHeight $$</p>
<p>而在针对存储内容优化的新方案中，去除了极大部分的区块，引入了新的”状态区块”Generation来存储每个时间段账户信息。其中，StorageSize为总存储规模，blockHeight为区块高度（个数），GenerationSize为单个“状态区块”的大小，为了安全我们本地需要两个状态区块来保证安全性。CredibleHeight为可信高度，在PascalCoin中该高度被固定设定为100个区块。BuiltinTxNum为单个区块中的事务（交易）个数。<br>$$ StorageSize(blockHeight) = BlockSize \times (blockHeight \bmod CredibleHeight) + GenerationSize(blockHeight) + GenerationSize(\lfloor \frac{blockHeight}{CredibleHeight} \rfloor ) $$</p>
<p>$$ GenerationSize(blockHeight) \approx \frac{BlockSize \times blockHeight}{BuiltinTxNum} $$</p>
<p>从数学模型可见，该方案除了删除了大部分冗余数据以外，还限制住了数据量体积，可以有效防止数据量的无限扩张。</p>
<h3 id="为什么该方案依旧安全可信"><a href="#为什么该方案依旧安全可信" class="headerlink" title="为什么该方案依旧安全可信"></a>为什么该方案依旧安全可信</h3><p>Bitcoin从Merkle树，即默克尔树出发来保证区块安全。如上所述，在进行区块“压缩”、“删减”过程之中链的默克尔树实际上是被破坏了——无法从创世区块重新递推至最新块。</p>
<p>但这并不意味着方案的安全性被打破。我们的关注点在于共识之上——在共识中，所有达到了N的节点在确认全网都已经达到N（通常实践上由8个“确认”消息来判断，与Bitcoin交易的广播类似）之后都会将（N-k）号区块之前的区块进行“删减”——这就如同一次简易的硬分叉（hard fork），在共识之中，虽然树被打破，但是所有交易信息所有事务的结果不会丢失。</p>
<p>而且，新方案中依然存在着默克尔树。首先是“状态区块”能够形成简短的默克尔树，防止恶意用户上线多个恶意节点利用共识篡改历史数据。其次，区块的默克尔树依然存在，但仅仅服务于现在与未来，关注于新区块是否安全可信。</p>
<!-- 3. 为什么该方案在低存储基础上还能低膨胀？ -->

<h3 id="低存储的应用部署思路"><a href="#低存储的应用部署思路" class="headerlink" title="低存储的应用部署思路"></a>低存储的应用部署思路</h3><!--非工程环境，通用思路-->
<p>本质来说，低存储方案中应用部署相比正常方案中并不具有相对更多的限制。但是若是需要最大程度地发挥其中优势，则需要更好地对应用进行筛选。</p>
<p>首先，最佳效果之下，信息应当存储于各个账户的状态之中。如此便可直接摆脱UTXO货币在导入新私钥时，或是创建账号地址时，不得不通过P2P网络将所有区块同步之后才能安全进行其余例如交易等操作的这一困境。这对于数字货币钱包来说，是加强了其易用性，几乎能够直接在打开瞬间开始进行操作。且摆脱了SPV协议轻钱包。由于SPV钱包不能检查区块上任意其他的交易，理论上讲，区块就有可能是无效的。而且spv协议往往指向一个中心服务器，这可能被重定向到一个恶意地址，给用户带来财产损失的风险。这对于如以太坊这类的应用入口来说，更可以大大加快应用开发速度，加快应用加载速度。</p>
<p>其次，尽可能地删除不必要的旧区块。在过了可信高度，即几乎所有节点的区块链存储都高于某一高度一定高度之后，区块链系统完全可以将某一高度前的区块进行删除来达到节省存储空间的目的。因为首先数据我们是选择存储在各个账户状态之中，换句话说就是即便删除了历史的区块也不会造成信息的损失。其次我们所有节点都在这“某一高度”上方，我们在这“某一高度”上达成了共识，即每个节点在“某一高度”之前的区块都是完全相同的，之后的区块的merkle树或trie树都可以在这“某一高度”开始进行，不必强制从创世区块开始。对于这之前的区块，已经无特别重要的作用，当然对于存储空间足够的设备来说依然可以保留这些区块，但是对于空间较小或者更加集约的环境下，将这之前的区块删除应当是最为正确的操作。</p>
<p>再者，必须限制账户、事务的膨胀。首先，区块的大小和事务数量有直接关系，因此中本聪利用了fee也就是手续费概念，fee的竞争以及区块打包交易上限增加了事务进入系统的成本，以此来防止事务的过度或恶意的膨胀。</p>
<p>其次由于新的区块链中选择将信息存储于账户之中，因此在打包账户时账户数量和使用存储量有直接的正比关系</p>
<p>$$ StorageSize = kAccountNum $$</p>
<p>倘若不限制账户数量，依旧和比特币一样提供无限的基于私钥与ECDSA椭圆曲线数字签名算法生成的账户地址，那么存储量很容易脱离监管。例如可能有人恶意地通过给许多未在网络出现的地址发送事务，强制增加了许多新的账户，那么在该网络下：</p>
<p>$$ NewAccountNum = TransactionNum $$</p>
<p>而为了交易的速度，我们往往在一个区块中打包许多事务。如比特币中，一般一个交易（事务）在250字节左右，扩容前1M大概就能容纳4000多笔。</p>
<p>$$ NewAccuntNum =  TransactionNum = 4000 $$<br>$$ AccountNum = OriginalAccountNum + NewAccuntNum $$<br>$$ StorageSize = kOriginalAccountNum + 4000k = OriginalStorage + 4000k $$</p>
<p>即每次都需要增加整整4000k大小存储空间，而由于在攻击下，大部分账户不具有真实性，并不真正被他人使用，即很可能这4000k大小将是无用的。随着时间推移以及区块高度增加，在攻击之下的真实账户所占空间增长缓慢，无用账户所占空间却越来越多，最终和改良前无用区块冗余的状态一致。即无法达到限制膨胀，无法将其应用于多设备尤其是类似物联网的场景之中。可见限制账户与事务非常有必要。</p>
<!-- 另外，更切实的智能合约。结合工程详情 -->

<h2 id="项目案例"><a href="#项目案例" class="headerlink" title="项目案例"></a>项目案例</h2><p>实际工程项目中可能涉及工地环境，计算机环境以及经济环境等等具有非常鲜明特点且各不相同的方面。</p>
<p>因此，区块链在工程的每个部分中的应用都有所不同。但是在大多数场景中，我们都可以将其功能与需求部署在区块链中，从最基本的可信数据存储的基础之上开始向上增加特性。</p>
<h3 id="应用概述"><a href="#应用概述" class="headerlink" title="应用概述"></a>应用概述</h3><p>本案例从事务存储角度进行，假设进行的是一个混合了高频率的物联网监管信息监管以及企业间合约的共识化</p>
<p>首先，我们通过定义一系列参数为常见数字货币公有链中内置参数，来模拟通用状态下，基于状态的理论低存储非膨胀方案相比原始中本聪论文内方案在存储上的差异。</p>
<!--多扯点-->
<p>其次针对工程设计与安全责任的监控项目的低存储区块链化的目标设定相关内容，进行实验</p>
<p>最后根据工程合同的低存储区块链化来制定另一实验。</p>
<h3 id="不同的区块链底层设计"><a href="#不同的区块链底层设计" class="headerlink" title="不同的区块链底层设计"></a>不同的区块链底层设计</h3><!--代码细节-->
<p>首先，基于Python，我们可以从中本聪（Satoshi）论文中轻易地制作一个基本的区块链模型。</p>
<p>为了快速地实现多层的区块，我们可以将其中繁杂的工作证明、密钥交换、交易签名等安全细节删去。最终我们生成一个较为简易但具有完整的在挖矿成功后建立新区块并对数据进行存储的功能。</p>
<p>然后我们再建立一个基于状态的区块链系统。除了Block区块以外，我们还需要一个新的对象——该对象需要保存一个时间点上的账户状态信息以及之前历史区块信息，同时它也和传统的区块一样能够通过散列值来形成一个链。如前文介绍中简写，该“状态区块”也可以叫做Generation（代）。同样地为了测试我们将其中繁杂的工作证明、密钥交换、交易签名等安全细节删去，将判断可信高度的方法简便化。但是依然保留状态区块链之中删除历史区块的功能。</p>
<!--介绍！！！-->

<p>最终我们再写一个程序，通过该程序我们能对两个系统进行“挖矿”操作。简单来说，该程序能够在两个系统之中分别注入相对相同的事务信息，并不断激活两者新区块打包存储功能。在这个过程之中，两个不同的区块链系统会用两者不同的方式打包交易。但是，状态区块链除了单纯的打包储存以外，也会将交易信息在生成状态区块的过程中归纳进账户信息之中，在每个可信高度之后追加一个包含当前时间点链上所有账户的“状态区块”，并删除可信高度个“状态区块”之前的过久的区块。</p>
<p>公平起见，所有写入区块的交易本质相同，唯一不同在于低存储区块链中为数字（账户编号），传统区块链之中为对该数字进行类比特币地址生成方式处理（即sha256计算散列后将该值进行base58加密）后得到的地址。</p>
<p>此外，我们还可以通过修改模拟生成的交易内容来控制对实验内容的模拟。</p>
<p>在工程设计与安全责任的监控项目的低存储区块链化中，大部分事务是由物联网设备的工作证明与工作状态构成。这里的工作证明和传统的数字货币的工作证明挖矿是有些许区别的，工作内容不再是通过计算无意义的散列值，而是根据工程环境进行定制。例如在我们假设的传感器监控环境之中，所有进行正常工作（搜集数据，打包数据，分析数据等等）的时间都可以被视为其工作，而其对于每个时间段进行的工作总结即为工作证明。换句话说，我们是摆脱了账户间交易，或者说是只考虑工作证明并没有其他账户之间的交易，即我们可以选择将事务发送目标与发送货币数量字段都设置为空且增加可能的账户数（通用场景中设为100，在多设备的监控环境之中设置为10万，即100000）。对应的，又由于高速出块，我们将可信高度也拔高数倍（10000）。</p>
<p>在工程合同的低存储区块链化项目之中，往往参与账户相对较少（100），企业之间即合约内的总代币量不变。公司（账号0）为总发包方，即最终的代币兑现方，在初始即创世区块中账户就具备该代币量。其他各个承包方与“0”公司，或承包方之间，进行代币交易并在交易内签署合同落实细则来实现现实中项目转接或合同内外事件的发生。该场景下对于共识中区块生成条件没有额外要求，但是在最优情况下，应当结合底层设施，或者底层人员，对于项目工作落实的监测与管理汇报，在与实际工作相有机结合之后来实现上层管理（合约）与下层劳动的联动。在保证工作基础上，透明化联盟内合作企业之间关系，真正实现付出换来收获，也最大幅度地扩大各企业效益。</p>
<h3 id="模拟数据"><a href="#模拟数据" class="headerlink" title="模拟数据"></a>模拟数据</h3><!--图表-->
<p>通过Python制作的相关应用，我们可以得到各方案在区块存储方面随着区块高度逐步增加而变化的状况。我们将数据再次用Python清洗整理后，通过JavaScript配合Echarts进行渲染，我们即可得到可视化的数据图。</p>
<p>最终我们能够得到对比结果</p>
<img src="/post/state-chain-on-pm-paper/image0001.png" class="" title="image0001">

<p>具体的，对于传统区块链的存储使用情况如下：</p>
<img src="/post/state-chain-on-pm-paper/image0002.png" class="" title="image0002">

<p>对于状态的低存储区块链模型在使用中存储情况如下：</p>
<img src="/post/state-chain-on-pm-paper/image0003.png" class="" title="image0003">

<p>首先我们录入的数据分为两种。</p>
<p>第一种工程设计与安全责任的监控项目的低存储区块链化中，与第二种在工程合同的低存储区块链化项目之中，我们得到的结果都和通用情况下结果相近。</p>
<p>更详细<strong>实验与后续分析</strong>请见最上面PDF</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>blockchain</tag>
        <tag>paper</tag>
        <tag>project manegement</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly核心标准：WebAssembly Core Specification</title>
    <url>/post/wasm-core-1/</url>
    <content><![CDATA[<p>细枝末节略，无关内容略。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文档介绍了WebAssembly核心标准的1.0版。WebAssembly是一种安全，可移植的低级代码格式，旨在有效执行和紧凑表达。</p>
<p>相关文档：核心WebAssembly规范，WebAssembly JS接口和WebAssembly Web API。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1. 引言"></a>1.1. 引言</h3><p>WebAssembly（缩写为Wasm）是一种安全，可移植的低级代码格式，旨在高效执行和紧凑表达。</p>
<p>它的主要目标是在Web上启用高性能应用程序，但是它没有做任何特定于Web的假设或提供特定于Web的功能，因此它也可以在其他环境中使用。</p>
<p>WebAssembly是W3C组织开发的开放标准。</p>
<p>本文档介绍了核心WebAssembly标准的1.0版。其未来将被替换为添加具有其他功能的新增量发行版。</p>
<h4 id="1-1-1-设计目标"><a href="#1-1-1-设计目标" class="headerlink" title="1.1.1. 设计目标"></a>1.1.1. 设计目标</h4><p>WebAssembly的设计目标如下：</p>
<ul>
<li>快速，安全和可移植的语义：</li>
</ul>
<p><strong>快速</strong>：利用几乎所有现代硬件共有的功能，以接近本机的代码性能执行。</p>
<p><strong>安全</strong>：代码经过验证并在内存安全的[2]沙盒环境中执行，可防止数据损坏或安全漏洞。</p>
<p><strong>定义明确</strong>：以易于非正式地和正式地进行推理的方式，全面而精确地定义有效的程序及其行为。</p>
<p><strong>与硬件无关</strong>：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。</p>
<p><strong>与语言无关</strong>：不青睐任何特定的语言，编程模型或对象模型。</p>
<p><strong>与平台无关</strong>：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。</p>
<p><strong>开放</strong>：程序可以通过简单通用的方式与其环境进行互操作。</p>
<ul>
<li>高效便携的表示形式：</li>
</ul>
<p><strong>紧凑</strong>：具有比典型文本或本机代码格式小的传输速度快的二进制格式。</p>
<p><strong>模块化</strong>：程序可以分成较小的部分，可以分别传输，缓存和使用。</p>
<p><strong>高效</strong>：可以通过一次快速遍历进行解码，验证和编译，等同于即时（JIT）或提前（AOT）编译。</p>
<p><strong>可流式传输</strong>：允许在看到所有数据之前尽快开始解码，验证和编译。</p>
<p><strong>可并行化</strong>：允许将解码，验证和编译分为许多独立的并行任务。</p>
<p><strong>可移植性</strong>：没有任何现代硬件无法广泛支持的架构假设。</p>
<p>WebAssembly代码还旨在易于检查和调试，尤其是在Web浏览器之类的环境中，但是此类功能超出了本规范的范围。</p>
<p>[1]“WebAssembly”的缩写，而不是首字母缩写，因此未使用大写字母。</p>
<p>[2]没有任何程序可以破坏WebAssembly的内存模型。当然，它不能保证编译为WebAssembly的不安全语言不会破坏其自身的内存布局，例如WebAssembly的线性内存中。</p>
<h4 id="1-1-2-作用域"><a href="#1-1-2-作用域" class="headerlink" title="1.1.2. 作用域"></a>1.1.2. 作用域</h4><p>WebAssembly的核心是一套<em>虚拟指令集体系结构（虚拟ISA）</em>。<br>因此，其具有许多用例，且可以嵌入许多不同的环境中。<br>为了涵盖它们的多样性并实现最大程度的重用，WebAssembly规范被拆分并分层为多个文档。</p>
<p>本文档与WebAssembly的核心ISA层有关。<br>它定义了指令集，二进制编码，验证和执行语义以及文本表示形式。<br>但是，它没有定义WebAssembly程序如何与它们在其中执行的特定环境交互，也没有定义如何从这样的环境中调用它们。</p>
<p>取而代之的是，此规范得到了其他文档的补充，这些文档定义了到特定嵌入环境（例如Web）的接口。<br>这些都将定义适合给定环境的WebAssembly<em>应用程序编程接口（API）</em>。</p>
<h3 id="1-2-安全性考量"><a href="#1-2-安全性考量" class="headerlink" title="1.2. 安全性考量"></a>1.2. 安全性考量</h3><p>WebAssembly不提供对执行代码的计算环境的环境访问。<br>与环境的任何交互（例如I/O，对资源的访问或操作系统调用）只能通过调用嵌入器提供的功能并将其导入WebAssembly模块中来执行。<br>嵌入程序可以通过控制或限制其可用于导入的功能来建立适用于相应环境的安全策略。<br>这些注意事项是嵌入程序的责任，也是特定环境的API定义的内容。</p>
<p>由于WebAssembly旨在转换为直接在主机硬件上运行的机器代码，因此可能会在硬件级别受到旁通道攻击。<br>在这是一个潜在的脆弱的环境中，嵌入程序可能必须设置适当的缓解措施以隔离WebAssembly计算。</p>
<h4 id="1-2-1-依赖"><a href="#1-2-1-依赖" class="headerlink" title="1.2.1. 依赖"></a>1.2.1. 依赖</h4><p>WebAssembly依赖于两个现有标准：</p>
<ul>
<li>[IEEE-754-2019]，用于表示浮点数据和相应数字运算的语义。</li>
<li>[UNICODE]，用于表示导入/导出名称和文本格式。</li>
</ul>
<p>但是，为了使本规范变得独立，将上述标准的相关方面定义并正式化为本规范的一部分，例如二进制表示和浮点值的取整，以及Unicode的值范围和UTF-8编码字符。</p>
<blockquote>
<p>注意!</p>
<p>前述标准是所有各个定义的权威来源。本规范中给出的形式化旨在与这些定义匹配。所描述的语法或语义上的任何差异均应视为错误。</p>
</blockquote>
<h3 id="1-3-概览"><a href="#1-3-概览" class="headerlink" title="1.3. 概览"></a>1.3. 概览</h3><h4 id="1-3-1-概念"><a href="#1-3-1-概念" class="headerlink" title="1.3.1 概念"></a>1.3.1 概念</h4><p>WebAssembly编码一种低级的，类似于程序集的编程语言。该语言围绕以下概念构建。</p>
<p><strong>值Values</strong></p>
<blockquote>
<p>WebAssembly仅提供四种基本值类型。这些是整数和<a href="https://www.w3.org/TR/wasm-core-1/#biblio-ieee-754-2019" target="_blank" rel="noopener">IEEE-754-2019</a>数字，分别为32位和64位宽度。32位整数还用作布尔值和内存地址。可以使用这些类型的常规操作，包括它们之间转换的完整矩阵。有符号和无符号整数类型之间没有区别。取而代之的是，整数会被相应的操作解释为无符号或有两个补码表示形式的符号。</p>
</blockquote>
<p><strong>指令Instructions</strong></p>
<blockquote>
<p>WebAssembly的计算模型基于<em>堆栈计算机</em> 。代码由按顺序执行的指令序列组成。指令在隐式操作数堆栈[1]上操作值，并分为两个主要类别。简单的指令对数据执行基本操作。它们从操作数堆栈中弹出参数，并将结果压回该操作数堆栈。控制指令会改变控制流程。控制流是结构化的，这意味着它可以用嵌套好的结构（例如块，循环和条件）来表示。分支只能针对此类构造。</p>
</blockquote>
<p><strong>陷阱Traps</strong></p>
<blockquote>
<p>w在某些情况下，某些指令可能会产生陷阱，该陷阱会立即中止执行。陷阱不能由WebAssembly代码处理，但是会报告给外部环境，通常可以在外部环境中捕获它们。</p>
</blockquote>
<p><strong>功能Functions</strong></p>
<blockquote>
<p>代码被组织成单独的功能。每个函数都将值序列作为参数，并返回值序列作为结果。 [2]函数可以互相调用，包括递归调用，从而导致无法直接访问的隐式调用堆栈。函数还可以声明可用作虚拟寄存器的可变局部变量。</p>
</blockquote>
<p><strong>表Tables</strong></p>
<blockquote>
<p>表是特定元素类型的不透明值的数组。它允许程序通过动态索引操作数间接选择这些值。当前，唯一可用的元素类型是无类型的函数引用。因此，程序可以通过向表中的动态索引间接调用函数。例如，这允许通过表索引模拟功能指针。</p>
</blockquote>
<p><strong>线性内存Linear Memory</strong></p>
<blockquote>
<p>线性内存是连续，可变的原始字节数组。这样的存储器以初始大小创建，但是可以动态增长。程序可以在任何字节地址（包括未对齐）将线性存储器中的值加载/存储在线性存储器中或将其存储在其中。整数加载和存储可以指定小于各自值类型的大小的存储大小。如果访问不在当前内存大小的范围内，则会发生陷阱。</p>
</blockquote>
<p><strong>模块Modules</strong></p>
<blockquote>
<p>WebAssembly二进制文件采用模块的形式，该模块包含函数，表和线性内存的定义以及可变或不可变的全局变量。也可以导入定义，指定模块/名称对和合适的类型。每个定义可以选择以一个或多个名称导出。除定义外，模块还可以为其内存或表定义初始化数据，该初始化数据采用复制到给定偏移量的段的形式。他们还可以定义自动执行的启动功能。</p>
</blockquote>
<p><strong>嵌入器Embedder</strong></p>
<blockquote>
<p>WebAssembly实现通常将嵌入到主机环境中。此环境定义了如何启动模块加载，如何提供导入（包括主机端定义）以及如何访问导出。但是，任何特定嵌入的细节都超出了本规范的范围，而是由互补的，特定于环境的API定义提供。</p>
</blockquote>
<p>[1]实际上，实现无需维护实际的操作数堆栈。取而代之的是，堆栈可以看作是一组由指令隐式引用的匿名寄存器。类型系统可确保始终静态地了解堆栈高度，从而确保所有引用的寄存器。<br>[2]在当前版本的WebAssembly中，最多只有一个结果值。</p>
<h4 id="1-3-2-语义解析"><a href="#1-3-2-语义解析" class="headerlink" title="1.3.2. 语义解析"></a>1.3.2. 语义解析</h4><p>从概念上讲，WebAssembly的语义分为三个阶段。对于语言的每个部分，规范都会对其进行指定。</p>
<p><strong>解码Decoding</strong></p>
<blockquote>
<p>WebAssembly模块以二进制格式分发。解码过程将格式化并将其转换为模块的内部表示形式。在本规范中，此表示是通过抽象语法建模的，但是实际的实现可以改为直接编译为机器代码。</p>
</blockquote>
<p><strong>验证Validation</strong></p>
<blockquote>
<p>被解码的模块必须<em>有效</em>。验证检查许多格式​​正确的条件，以确保模块有意义且安全。特别是，它对功能及其内部的指令序列进行类型检查，以确保例如一致地使用操作数堆栈。</p>
</blockquote>
<p><strong>执行Execution</strong></p>
<blockquote>
<p>最后，一个有效的模块可以被<em>执行</em>。执行可以进一步分为两个阶段：</p>
<p><strong>实例化Instantiation</strong>。模块实例是模块的动态表示，带有其自己的状态和执行堆栈。实例化将执行模块主体本身，并为其定义所有导入。它将初始化全局变量，内存和表，并调用模块的启动函数（如果已定义）。它返回模块导出的实例。</p>
<p><strong>调用Invocation</strong>。一旦实例化，就可以通过在模块实例上<em>调用</em>导出的函数来启动进一步的WebAssembly计算。给定必需的参数，该函数将执行相应的函数并返回其结果。</p>
<p>实例化和调用是在嵌入环境中的操作。</p>
</blockquote>
<h2 id="2-架构"><a href="#2-架构" class="headerlink" title="2. 架构"></a>2. 架构</h2><h3 id="2-1-规定"><a href="#2-1-规定" class="headerlink" title="2.1. 规定"></a>2.1. 规定</h3><p>WebAssembly是一种编程语言，具有多种具体表示形式（其二进制格式和文本格式）。 两者都映射到一个共同的结构。为简明起见，以抽象语法的形式描述了此结构。本规范的所有部分均根据此抽象语法定义。</p>
<h4 id="2-1-1-语法符号"><a href="#2-1-1-语法符号" class="headerlink" title="2.1.1. 语法符号"></a>2.1.1. 语法符号</h4><p>在定义抽象语法的语法规则时采用以下约定。</p>
<ul>
<li>结束符号（原子）以sans-serif字体编写$\mathrm{i32, end}$。</li>
<li>非结束符以斜体字体表示：$valtype，instr$。</li>
<li>$A^n$是A的$n\geq0$个迭代的序列。</li>
<li>$A^*$是A的可能是空的迭代序列。（这是n无关的$A^n$的简写。）</li>
<li>$A^+$是A的非空迭代序列。（这是$A^n$的简写，其中n≥1。）</li>
<li>$A^?$是A的可选出现。（这是$A^n$的简写，其中n≤1。）</li>
<li>产生式被写成$sym::=A_1∣…∣A_n$。</li>
<li>大型产生式可能会分为多个定义，可以用第一个以显式椭圆$sym::=A_1|…$结束，并以椭圆以$sym::=…∣A_2$开头来表示。</li>
<li>一些产品在括号中加上附加条件“$(\mathrm{if} condition)$”，这为将产品组合扩展为许多单独的案例提供了捷径。</li>
</ul>
<h4 id="2-1-2-辅助符号"><a href="#2-1-2-辅助符号" class="headerlink" title="2.1.2. 辅助符号"></a>2.1.2. 辅助符号</h4><p>在处理语法结构时，还使用以下表示法：</p>
<ul>
<li>$\epsilon$表示空序列。</li>
<li>$|s|$表示序列s的长度。</li>
<li>$s[i]$表示序列s的第i个元素，从0开始。</li>
<li>$s[i:n]$表示序列s的子序列$s[i]…s [i+n-1]$。</li>
<li>$s\ with [i] = A$表示与s相同的序列，除了第i个元素被A代替。</li>
<li>$s\ with [i:n] = A^n$表示与s相同的序列，不同之处在于子序列$s[i:n]$被An取代。</li>
<li>$concat(s^*)$表示通过将$s^*$中的所有序列$s^i$串联而形成的平坦序列。</li>
</ul>
<p>此外，采用以下约定：</p>
<ul>
<li><p>符号$x^n$（其中x是非终结符号）被视为跨x的各个序列（类似于$x^*$，$x^+$，$x^?$）的元变量。</p>
</li>
<li><p>当给定一个序列$x^n$时，则假定在$(A1xA2)^n$中写入的序列中x的出现与xn呈逐点对应关系（对于$x^*$，$x^+$，$x^?$同样）。这隐式表达了在序列上映射语法结构的形式。</p>
</li>
</ul>
<p>以下形式的生产被解释为分别将一组固定的字段$field_i$映射到“值” Ai的记录：<br>$$r ::= { field_1 A_1, field_2 A_2,… }$$</p>
<p>使用以下表示法来处理此类记录：</p>
<ul>
<li><p>$r.field$表示r的字段filed的内容。</p>
</li>
<li><p>$r\ with\ field = A$表示与r相同的记录，除了字段组件的内容被A代替。</p>
</li>
<li><p>$r1 \oplus r2$通过逐点追加每个序列来表示具有相同序列字段的两个记录的组合：</p>
</li>
</ul>
<p>$${ field_1 A_1^*, field_2 A_2^*, … } {field_1 B_1^*, field_2 B_2^*, … } = { field_1 A_1^* B_1^*, field_2 A_2^* B_2^*,… }$$</p>
<ul>
<li>$\oplus r^*$分别表示记录序列的组成；如果序列为空，则结果记录的所有字段均为空。</li>
</ul>
<p>序列和记​​录的更新符号递归地概括为“路径” $pth ::=([…]|.field)^+$所访问的嵌套组件：</p>
<ul>
<li>$s\ with\ [i]\ pth = A$是$s\ with [i] =(s[i]\ with\ pth = A)$的缩写。</li>
<li>$r\ with\ field\ pth = A$是$r\ with\ field =(r.field\ with\ pth = A)$的缩写。</li>
</ul>
<p>其中$r\ with\ .field = A$缩写为$r\ with\ field = A$</p>
<h4 id="2-1-3-向量"><a href="#2-1-3-向量" class="headerlink" title="2.1.3. 向量"></a>2.1.3. 向量</h4><p>向量是形式为$A^n$（或$A^*$）的有界序列，其中A可以是值或复杂的构造。一个向量最多可包含$2^32-1$（即MaxUint256）个元素。</p>
<p>$$vec(A) ::= A^n\ (if\ n&lt;2^{32})$$</p>
<h3 id="2-2-值"><a href="#2-2-值" class="headerlink" title="2.2. 值"></a>2.2. 值</h3><p>WebAssembly程序对原始数值进行操作。<br>此外，在程序的定义中，值的不可变序列出现以表示更复杂的数据，例如文本字符串或其他向量。</p>
<h4 id="2-2-1-Bytes"><a href="#2-2-1-Bytes" class="headerlink" title="2.2.1. Bytes"></a>2.2.1. Bytes</h4><p>值的最简单形式是未解释的原始字节。<br>在抽象语法中，它们表示为十六进制文字。</p>
<p>$$ byte​::=​0x00 |…| 0xFF​ $$</p>
<h5 id="2-2-1-1-惯例"><a href="#2-2-1-1-惯例" class="headerlink" title="2.2.1.1. 惯例"></a>2.2.1.1. 惯例</h5><ul>
<li><p>元变量$b$的范围为字节。</p>
</li>
<li><p>字节有时被解释为自然数$n &lt; 256$。</p>
</li>
</ul>
<p>2.2.2. 整数</p>
<p>具有不同值范围的不同类别的整数通过其<em>位宽</em>$N$以及是<em>无符号</em>还是<em>有符号</em>来区分。</p>
<p>$$uN ::= 0 | 1| … | 2^N-1$$<br>$$sN ::= -2^N-1|…| -1 | 0 | 1 | … | 2^N-1$$<br>$$iN ::= uN$$</p>
<p>后者定义了未解释的整数，其有符号性解释会根据上下文而变化。<br>在抽象语法中，它们表示为无符号值。<br>但是，某些运算会根据二进制补码解释将其转换为带符号。</p>
<blockquote>
<p>注意</p>
<p>在本规范中出现的主要整数类型是u32，u64，s32，s64，i8，i16，i32，i64。但是，例如在浮点数的定义中，其他大小也可以作为辅助结构。</p>
</blockquote>
<h5 id="2-2-2-1-惯例"><a href="#2-2-2-1-惯例" class="headerlink" title="2.2.2.1. 惯例"></a>2.2.2.1. 惯例</h5><ul>
<li>元变量$m，n，i$的范围是整数。</li>
<li>如上面的语法所示，数字可以用简单的算术表示。<br>为了区分$2^N$之类的算术与$(1)^N$之类的序列，用括号将后者区分。</li>
</ul>
<h4 id="2-2-3-浮点数"><a href="#2-2-3-浮点数" class="headerlink" title="2.2.3. 浮点数"></a>2.2.3. 浮点数</h4><p>浮点数据表示32或64位值，它们对应于[IEEE-754-2019]标准（第3.3节）的相应二进制格式。</p>
<p>每个值都有一个符号和大小。 幅值可以表示为形式为$m_0 m_1 m_2 \ldots m_M \cdot 2^e$的正态数，其中$e$是指数，m是其最高位$m_0$为1的有效数，或者以次正规数来表示 指数固定为最小可能值，且$m_0$为0; 在次法线中的是零正值和负值。 由于有效位数是二进制值，因此法线以$(1 +m\cdot 2^{-M})\cdot 2e$的形式表示，其中$M$是$m$的位宽； 对于次普通人也是如此。</p>
<p>可能的大小还包括特殊值$\infty$（无穷大）和nan（即NaN，非数字）。NaN值具有一个有效载荷，该载荷描述了基础二进制表示形式中的尾数位。 信号和安静的NaN之间没有区别。</p>
<p>$$fN ::= +fNmag | -fNmag$$<br>$$\displaylines{fNmag ::=(1+uM\cdot 2^{-M})\cdot 2^e ((if\ −2^{E−1} + 2 \leq e \leq 2^{E−1}−1))\<br>|\ (0+uM\cdot 2^{-M})\cdot 2^e (if\ e=-2^{E-1}+2)\<br>\infty\<br>nan(n)\ (if 1\leq n\lt 2^M)}$$</p>
<p>当 M=signif(N) 且 E=expon(N) 则</p>
<p>$$\displaylines{signif(32) = 23 \<br>expon(32) =8 \<br>signif(64)=52\<br>expon(64)=11}$$</p>
<p>一个*规范的(canonical)*NaN是浮点数值$\pm nan(canon_N)$，其中$canon_N$是有效载荷，其最高有效位为1而所有其他均为0：</p>
<p>$$canon_N = 2^{signif(N)-1}$$</p>
<p>一个*算术(arithmetic)*NaN是$n\geq canon_N$的浮点值$\pm nan(n)$，因此最高有效位为1，其他所有位均为任意。</p>
<blockquote>
<p>注意</p>
<p>在抽象语法中，子范数以有效数字的前导0区分。 次正态的指数与正态数的最小可能指数具有相同的值。 仅在二进制表示中，次正态的指数与任何正态数的指数的编码方式不同。</p>
</blockquote>
<h5 id="2-2-3-1-惯例"><a href="#2-2-3-1-惯例" class="headerlink" title="2.2.3.1. 惯例"></a>2.2.3.1. 惯例</h5><ul>
<li>元变量z取自从上下文清晰可辨的浮点值。</li>
</ul>
<h4 id="2-2-4-名称Names"><a href="#2-2-4-名称Names" class="headerlink" title="2.2.4. 名称Names"></a>2.2.4. 名称Names</h4><p>名称是字符序列，是[UNICODE]（第2.4节）定义的标量值。</p>
<p>$$\displaylines{name::= char^* \ (if\ |utf8(char^*)|&lt;2^{32})\<br>char ::= U+00|\ldots|U+D7FF|U+E000|…U+10FFFF}$$</p>
<p>由于二进制格式的限制，名称的长度受其UTF-8编码的长度限制。</p>
<h5 id="2-2-4-1-惯例"><a href="#2-2-4-1-惯例" class="headerlink" title="2.2.4.1. 惯例"></a>2.2.4.1. 惯例</h5><ul>
<li>字符（Unicode标量值）有时与n &lt;1114112的自然数互换使用。</li>
</ul>
<h3 id="2-3-类型Types"><a href="#2-3-类型Types" class="headerlink" title="2.3 类型Types"></a>2.3 类型Types</h3><p>WebAssembly中的各种实体按类型分类。<br>在验证，实例化以及可能的执行期间检查类型。</p>
<h4 id="2-3-1-值-Value-类型"><a href="#2-3-1-值-Value-类型" class="headerlink" title="2.3.1 值(Value)类型"></a>2.3.1 值(Value)类型</h4><p>值类型对WebAssembly代码可以计算的单个值以及变量接受的值进行分类。</p>
<p>$$valtype ::= i32|i64|f32|f64$$</p>
<p>i32和i64类型分别将32位和64位整数分类。<br>整数不是固有地带符号或无符号的，它们的解释由单个操作确定。</p>
<p>f32和f64类型分别将32位和64位浮点数分类。<br>它们分别对应于[IEEE-754-2019]标准（第3.3节）定义的相应二进制浮点表示形式，也称为单精度和双精度。</p>
<h5 id="2-3-3-1-惯例"><a href="#2-3-3-1-惯例" class="headerlink" title="2.3.3.1. 惯例"></a>2.3.3.1. 惯例</h5><ul>
<li>元变量t可以从清晰的上下文中范围内的值类型。</li>
<li>符号$|t|$表示值类型的位宽。即，$|i32|=|f32|=32$和$|i64|=|f64|＝64$。</li>
</ul>
<h4 id="2-3-2-结果-Result-类型"><a href="#2-3-2-结果-Result-类型" class="headerlink" title="2.3.2. 结果(Result)类型"></a>2.3.2. 结果(Result)类型</h4><p>结果类型对执行指令或块的结果进行分类，该指令或块是用括号写入的一系列值。</p>
<p>$$resulttyle ::= [valtype^?]$$</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，结果最多允许一个值。但是，这可能会泛化为将来版本中的值序列。</p>
</blockquote>
<h4 id="2-3-3-函数-Function-类型"><a href="#2-3-3-函数-Function-类型" class="headerlink" title="2.3.3 函数(Function)类型"></a>2.3.3 函数(Function)类型</h4><p>函数类型对函数的签名进行分类，将参数向量映射到结果向量，如下所示。</p>
<p>$$ functype ::= [vec(valtype)] -&gt; [vec(valtype)]$$</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，有效函数类型的结果类型向量的长度最多为1。此限制在将来的版本中可能会消除。</p>
</blockquote>
<h4 id="2-3-4-限制"><a href="#2-3-4-限制" class="headerlink" title="2.3.4. 限制"></a>2.3.4. 限制</h4><p>限制对与内存类型和表类型关联的可调整大小的存储的大小范围进行分类。</p>
<p>$$limits ::= {min u32, max u32^?}$$</p>
<p>如果没有给出最大值，则相应的存储可以增长到任何大小。</p>
<h4 id="2-3-5-内存-Memories-类型"><a href="#2-3-5-内存-Memories-类型" class="headerlink" title="2.3.5. 内存(Memories)类型"></a>2.3.5. 内存(Memories)类型</h4><p>存储器类型将线性存储器及其大小范围分类。</p>
<p>$$memtype ::= limits$$</p>
<p>这些限制限制了内存的最小和最大可选大小。 限制以页面大小为单位给出。</p>
<h4 id="2-3-6-表格类型"><a href="#2-3-6-表格类型" class="headerlink" title="2.3.6. 表格类型"></a>2.3.6. 表格类型</h4><p>表类型根据大小范围内的元素类型的元素对表进行分类。</p>
<p>$$\displaylines{tabletype ::= limits elemtype\<br>elemtype::=funcref}$$</p>
<p>像内存一样，表格的最小和最大大小限制也受到限制。<br>限制以条目数给出。</p>
<p>元素类型funcref是所有函数类型的无限并集。<br>因此，该类型的表包含对异构类型函数的引用。</p>
<blockquote>
<p>注意</p>
<p>在WebAssembly的未来版本中，可能会引入其他元素类型。</p>
</blockquote>
<h4 id="2-3-7-全局变量类型"><a href="#2-3-7-全局变量类型" class="headerlink" title="2.3.7. 全局变量类型"></a>2.3.7. 全局变量类型</h4><p>全局变量类型对全局变量进行分类，这些全局变量具有一个值，并且可以是可变的或不可变的。</p>
<p>$$\displaylines{globaltype ::= mut valtype\mut ::= const | var}</p>
<h4 id="2-3-8-外部类型"><a href="#2-3-8-外部类型" class="headerlink" title="2.3.8. 外部类型"></a>2.3.8. 外部类型</h4><p>外部类型使用各自的类型对导入和外部值进行分类。</p>
<p>$$ externtype :: = func functype| table tabletype | mem memtype | global globaltype $$</p>
<h5 id="2-3-8-1-惯例"><a href="#2-3-8-1-惯例" class="headerlink" title="2.3.8.1 惯例"></a>2.3.8.1 惯例</h5><p>为外部类型的序列定义了以下辅助符号。<br>它以保留顺序的方式筛选出特定种类的条目：</p>
<p>$$\displaylines{funcs(externtype^*)=[functype|(func functype) \in externtype^*] \<br>tables(externtype^*)=[tabletype | (table tabletype)\in externtype^*] \<br>mems(externtype^*)=[memtype | (mem memtype)\in externtype^*] \<br>globals(externtype^*)=[globaltype | (global globaltype)\in externtype^*]}$$</p>
<h3 id="2-4-指令Instructions"><a href="#2-4-指令Instructions" class="headerlink" title="2.4. 指令Instructions"></a>2.4. 指令Instructions</h3><p>WebAssembly代码由指令序列组成。 它的计算模型基于堆栈机，其中指令在隐式操作数堆栈上操纵值，使用（弹出）自变量值并生成或返回（推入）结果值。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，单个指令最多可以推入一个结果值。在将来的版本中可能会取消此限制。</p>
</blockquote>
<p>除了来自堆栈的动态操作数之外，某些指令还具有静态中间参数，通常是索引或类型注释，它们是指令本身的一部分。</p>
<p>某些指令的结构在于将嵌套的指令序列括起来。</p>
<p>以下各节将指令分为许多不同的类别。</p>
<h4 id="2-4-1-数值指令"><a href="#2-4-1-数值指令" class="headerlink" title="2.4.1. 数值指令"></a>2.4.1. 数值指令</h4><p>数值指令提供对特定类型数值的基本操作。<br>这些操作与硬件中可用的各个操作紧密匹配。</p>
<p>$$nn,mm::= 32| 64$$<br>$$sx ::=  \rm{u} |  \rm{s}$$<br>$$\displaylines{instr ::= \mathrm{i} nn.\mathrm{const}\ inn | \mathrm{i}nn.\mathrm{const}\ fnn \<br>| \mathrm{i}nn.iunop | \mathrm{f}nn.funop \<br>| \mathrm{i}nn.ibinop | \mathrm{f}nn.fbinop \<br>| \mathrm{i}nn.itestop \<br>| \mathrm{i}nn.irelop | \mathrm{f}nn.frelop \<br>| \mathrm{i32.wrap_i64} | \mathrm{i64.extend_i32_}sx | \mathrm{i}nn.\mathrm{trunc_f}mm_sx \<br>| \mathrm{f32.demote_f64} | \mathrm{f64.promote_f32} | \mathrm{f}nn.\mathrm{convert_i}mm_sx \<br>| \mathrm{i}nn.\mathrm{reinterpret_f}nn | \mathrm{i}nn.\mathrm{reinterpret_i}nn \<br>| \ldots}$$<br>$$ iunop ::= \mathrm{clz | ctz | opocnt}$$<br>$$ \displaylines{ibinop ::= \mathrm{add | sub | mul | div_}sx \mathrm{|rem_}sx \<br>| \mathrm{and | or | xor | shl | shr_}sx \mathrm{| rtol | rtor} }$$<br>$$ funop ::= \mathrm{abs | neg | sqrt | ceil | floor | trunc | nearest}$$<br>$$ fbinop ::= \mathrm{add | sub | mul | div | min | max | copysign}$$<br>$$ itestop ::= \mathrm{eqz}$$<br>$$ irelop ::= \mathrm{eq | ne | lt_}sx \mathrm{| gt_}sc \mathrm{| le_}sx \mathrm{| ge_}sx$$<br>$$ frelop ::= \mathrm{eq | ne | lt | gt | le | ge }$$</p>
<p>数字指令按值类型划分。 对于每种类型，可以区分几个子类别：</p>
<ul>
<li>常量：返回静态常量。</li>
<li>一元运算符：使用一个操作数并产生相应类型的一个结果。</li>
<li>二进制运算符：使用两个操作数并产生一个相应类型的结果。</li>
<li>测试：消耗一个相应类型的操作数，并产生一个布尔整数结果。</li>
<li>比较：消耗两个各自类型的操作数，并产生一个布尔整数结果。</li>
<li>转换：使用一种类型的值并产生另一种类型的结果（转换的源类型是“_”之后的类型）。</li>
</ul>
<p>一些整数指令有两种形式，其中带符号注释sx区分是将操作数解释为无符号整数还是带符号整数。<br>对于其他整数指令，对有符号的解释使用二进制补码意味着无论有符号性如何，它们的行为都相同。</p>
<h5 id="2-4-1-1-惯例"><a href="#2-4-1-1-惯例" class="headerlink" title="2.4.1.1. 惯例"></a>2.4.1.1. 惯例</h5><p>有时，根据以下语法速记将操作分组在一起很方便：</p>
<p>$$unop ::= iunop | funop$$<br>$$binop ::= ibinop | fbinop$$<br>$$testop ::= itestop$$<br>$$relop ::= irelop | frelop$$<br>$$cutop ::= \mathrm{wrap | entend | trunc | convert | demote | promote | reinterpret}$$</p>
<h4 id="2-4-2-参数指令"><a href="#2-4-2-参数指令" class="headerlink" title="2.4.2. 参数指令"></a>2.4.2. 参数指令</h4><p>该组中的指令可以对任何值类型的操作数进行运算。</p>
<p>$$ \displaylines{ instr ::= \ldots \<br>| \mathrm{drop} \<br>| \mathrm{select} }$$ </p>
<p>drop运算符只是丢掉单个操作数。</p>
<p>select运算符根据其第三个操作数是否为零来选择执行其前两个操作数之一。</p>
<h4 id="2-4-3-变量指令"><a href="#2-4-3-变量指令" class="headerlink" title="2.4.3. 变量指令"></a>2.4.3. 变量指令</h4><p>变量指令涉及对局部或全局变量的访问。</p>
<p>$$ \displaylines{ instr ::= \ldots \<br>| \mathrm{local.get}\ localidx \<br>| \mathrm{local.set}\  localidx \<br>| \mathrm{local.tee}\ localidx \<br>| \mathrm{global.get}\ globalidx \<br>| \mathrm{global.set}\ globalidx}$$</p>
<p>这些指令分别获取或设置变量的值。<br>local.tee指令类似于local.set，但会返回其参数。</p>
<h4 id="2-4-4-内存指令"><a href="#2-4-4-内存指令" class="headerlink" title="2.4.4. 内存指令"></a>2.4.4. 内存指令</h4><p>该组指令与线性内存有关。</p>
<p>$$ memarg ::= { \mathrm{offset}\ u32, \mathrm{align}\ u32 }$$</p>
<p>内存可以通过使用不同<em>值类型</em>的加载（load）和存储（store）指令来访问。<br>它们都使用一个内存中间值memarg，该值包含一个地址<em>偏移量（offset）</em>和一个预期的<em>编排方式</em>（表示为2的幂的指数）。<br>整数的加载和存储可以选择指定小于各自值类型的位宽度的存储大小。<br>在一些加载情况下，则需要符号扩展模式$sx$来选择适当的行为。</p>
<p>静态地址偏移量被添加到动态地址操作数，从而产生33位长度的<em>有效地址</em>，该地址是从零开始的索引，可从该索引访问内存。<br>所有值以Little-Endian读取和写入。<br>如果任何已访问的内存字节超出了内存当前大小所隐含的地址范围，就会产生陷阱（Trap）。</p>
<blockquote>
<p>注意</p>
<p>WebAssembly的未来版本可能会提供具有64位地址范围的内存指令。</p>
<p>（这也是为啥现在叫wasm32）</p>
</blockquote>
<p>memory.size指令返回当前的内存大小。<br>memory.grow指令将内存增加给定的增量，并返回先前的大小；如果无法分配足够的内存，则返回-1。<br>两条指令均以页面大小为单位。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，所有内存指令都隐式地（默认）对内存索引0进行操作。此限制在将来的版本中可能会取消。</p>
</blockquote>
<h4 id="2-4-5-控制指令"><a href="#2-4-5-控制指令" class="headerlink" title="2.4.5. 控制指令"></a>2.4.5. 控制指令</h4><p>该组中的指令会影响控制流程。</p>
<p>$$ \displaylines{ instr ::= \ldots \<br>| \mathrm{nop} \<br>| \mathrm{unreachable} \<br>| \mathrm{block}\ resulttype\ instr^<em>\ \mathrm{end} \<br>| \mathrm{loop }\ resulttype\ instr^</em>\ \mathrm{end} \<br>| \mathrm{if}\ resulttype\ instr^<em>\ \mathrm{else}\ instr^</em>\ \mathrm{end} \<br>| \mathrm{br}\ labelidx \<br>| \mathrm{br_if}\ labelidx \<br>| \mathrm{br_table}\ vec(labelidx)\ labelidx \<br>| \mathrm{return} \<br>| \mathrm{call}\ funcidx \<br>| \mathrm{call_indirect}\ typeidx}$$</p>
<p>nop指令不执行任何操作。</p>
<p>unreachable指令触发无条件的陷阱。</p>
<p>block,loop以及if指令是结构化指令。<br>它们将嵌套的指令序列（称为块）括起来，以指令末尾或伪指令终止或分隔。<br>正如语法规定的那样，必须将它们嵌套好。<br>结构化指令可以产生一个如注释结果类型描述的值。</p>
<p>每个结构化控制指令都会引入一个隐式标签。<br>标签（Label）是分支指令通过标签索引引用的目标。<br>与其他索引空间不同，标签的索引是相对于嵌套深度的，也就是说，标签0指的是包围引用分支指令的最内部结构化控制指令，而递增的索引则引用更远的索引。<br>因此，只能从关联的结构化控制指令中引用标签。<br>这也意味着分支只能指向外部，“脱离”它们所针对的控制构造的块。<br>具体效果取决于该控制结构：<br>在block或if情况下，向前跳转直到匹配到end后恢复执行。<br>在loop循环情况下，向后跳到loop开始。</p>
<blockquote>
<p>注意</p>
<p>这将强制执行结构化的控制流程。<br>直观地讲，在大多数类似于C的语言中，针对块的if分支的行为类似于break语句，而针对循环的分支的行为类似于continue语句。</p>
</blockquote>
<p>分支（Branch）指令有以下几种形式：<br>br：执行无条件分支<br>br_if：执行条件分支<br>br_table：通过操作数索引到标签向量的间接操作来执行该间接操作，该标签向量是指令的直接执行对象，如果操作数超出范围，则指向默认目标。<br>return：无条件分支到最外层代码块的快捷方式，该块隐式地是当前函数的主体。<br>采取分支将操作数堆栈展开到输入目标结构化控制指令的高度。<br>但是，以非空结果类型为目标的控制指令作为目标的前向分支首先消耗匹配的操作数，并在展开后将它们推回操作数堆栈中，以作为终止的结构化指令的结果。</p>
<p>call指令调用另一个函数，从堆栈中使用必要的参数并返回调用的结果值。<br>call_indirect指令通过将操作数索引到表中来间接调用函数。<br>由于表（table）可能包含异构类型funcref的函数元素，因此将根据指令的立即数对被调用方进行动态检查，以检查该函数类型（function type），如果调用不匹配，则调用将使用陷阱（trap）中止。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，call_indirect默认对表索引（tableidx）0操作。在将来的版本中可能会取消此限制。</p>
</blockquote>
<h4 id="2-4-6-表达式Expression"><a href="#2-4-6-表达式Expression" class="headerlink" title="2.4.6. 表达式Expression"></a>2.4.6. 表达式Expression</h4><p>函数（function）主体，全局变量（globals）的初始化值以及元素（element）或数据（data）段的偏移量都作为表达式给出。表达式是由结束（end）标记终止的指令（instruction）序列。</p>
<p>$$ expr ::= instr* \mathrm{end}$$</p>
<p>在某些地方，验证器将表达式限制为常量，从而限制了被允许的指令集。</p>
<h3 id="2-5-模块-Modules"><a href="#2-5-模块-Modules" class="headerlink" title="2.5 模块 Modules"></a>2.5 模块 Modules</h3><p>WebAssembly程序被组织成模块，这些模块是部署，加载和编译的单元。<br>一个模块包含了类型（types），函数（functions），表（tables），内存（memories）和全局变量（globals）的定义。<br>此外，它可以声明导入（imports）和导出（exports），并以数据（data）和元素（element）段或启动函数的形式提供初始化逻辑。</p>
<p>$$ \displaylines{ module ::= { types\ vec(functype),<br>funcs\ vec(func), \<br>tables\ vec(table), \<br>mems vec(mem), \<br>globals\ vec(elem), \<br>data\ vec(data), \<br>start\ start^?, \<br>imports\ vec(import),<br>exports\ vec(export) }}$$</p>
<p>每个向量，甚至整个模块，都可能是空的。</p>
<h4 id="2-5-1-索引"><a href="#2-5-1-索引" class="headerlink" title="2.5.1. 索引"></a>2.5.1. 索引</h4><p>定义被以从0开始的索引引用。<br>每个定义类都有其自己专属的索引空间，如以下类所示。</p>
<p>$$\displaylines{ typeidx ::= u32\<br>funcidx ::= u32\<br>tableidx ::= u32\<br>memidx ::= u32\<br>globalidx ::= u32\<br>localidx ::= u32\<br>labelidx ::= u32}$$</p>
<p>函数（functions），表（tables），内存（memories）和全局变量（globals）的索引空间包括在同一模块中声明的相应导入（imports）中。<br>这些导入（imports）的索引在同一索引空间中优先于其他定义的索引。</p>
<p>局部变量（locals）的索引空间只能在函数内部访问，并且包括以此为参数的函数。这种函数位于局部变量之前。</p>
<p>标签（label）索引引用指令序列内的结构化控制指令。</p>
<h5 id="2-5-1-1-惯例"><a href="#2-5-1-1-惯例" class="headerlink" title="2.5.1.1. 惯例"></a>2.5.1.1. 惯例</h5><ul>
<li>元变量l覆盖标签索引。</li>
<li>元变量x，y覆盖其他任何索引空间中的索引。</li>
</ul>
<h4 id="2-5-2-类型"><a href="#2-5-2-类型" class="headerlink" title="2.5.2. 类型"></a>2.5.2. 类型</h4><p>模块的类型组件定义了一个功能类型（function types）的向量。</p>
<p>所有功能类型必须在此组件中定义模块中使用。<br>它们由类型索引引用。</p>
<blockquote>
<p>注意</p>
<p>WebAssembly的未来版本可能会添加类型定义的其他形式。</p>
</blockquote>
<h4 id="2-5-3-函数"><a href="#2-5-3-函数" class="headerlink" title="2.5.3. 函数"></a>2.5.3. 函数</h4><p>模块的funcs组件定义具有以下结构的函数向量：</p>
<p>$$ func ::= {\mathrm{type}\ typeidx, \mathrm{locals}\ vec(valtype), \mathrm{body}\ expr}$$</p>
<p>函数（function）的类型通过引用模块中定义的类型来声明其签名。<br>该函数的参数通过函数主体中从0的局部索引进行引用； 他们是可变的。</p>
<p>局部变量（locals）声明一个可变局部变量及其类型的向量。<br>这些变量是通过函数体内的局部索引来引用的。<br>第一个局部变量的索引是最小索引，其不引用任何参数。</p>
<p>主体（body）是一个指令序列，在终止时必须产生一个与函数类型的结果类型（result type）匹配的堆栈。</p>
<p>函数通过函数索引被引用，由最小索引开始，不引用任何函数导入（function import）。</p>
<h4 id="2-5-4-表"><a href="#2-5-4-表" class="headerlink" title="2.5.4. 表"></a>2.5.4. 表</h4><p>模块的表组件定义了由表类型描述的一个表向量：</p>
<p>$$ table ::= { \mathrm{type}\ tabletype }$$</p>
<p>表是特定表元素类型的不透明值的向量。<br>表类型的限制中的最小的大小指定了该表的初始大小。<br>而如果存在最大则其大小限制该表稍后可以增长至的大小。</p>
<p>可以通过元素段（element segment）初始化表。</p>
<p>通过表索引引用表，从最小索引开始，不需要引用一个表导入（table import）。<br>大多数构造都隐式引用表索引0。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，最多可以在一个模块中定义或导入一个表，并且所有构造都隐式引用表0。此限制在将来的版本中可能会取消。</p>
</blockquote>
<h4 id="2-5-5-内存"><a href="#2-5-5-内存" class="headerlink" title="2.5.5. 内存"></a>2.5.5. 内存</h4><p>模块的内存（mems）组件定义了一个线性存储器（或简称为存储器）的向量，如其存储器类型所述：</p>
<p>$$ mem := {\mathrm{type}\ memtype }$$</p>
<p>内存是未被解释的原始字节的向量。<br>内存类型的限制中的最小（Min）大小指定该内存的初始大小，而最大内存大小（Max，如果存在）则限制了以后可以增长的大小。<br>两者均以页面大小为单位。</p>
<p>可以通过数据段（data segment）初始化内存。</p>
<p>内存被内存索引引用，从最小索引开始，不引用内存导入（memory import）。<br>大多数构造都隐式引用内存索引0。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，最多可以在一个模块中定义或导入一个内存，并且所有构造都隐式引用此内存0。此限制在将来的版本中可能会取消。</p>
<p>（换句话说现在的mems根本就是个单元素数组，里面就一个memory）</p>
</blockquote>
<h4 id="2-5-6-全局变量Globals"><a href="#2-5-6-全局变量Globals" class="headerlink" title="2.5.6. 全局变量Globals"></a>2.5.6. 全局变量Globals</h4><p>模块的全局变量组件定义了一个全局变量的向量（或简称为globals）：</p>
<p>$$global ::= { \mathrm{type}\ globaltype, \mathrm{init}\ expr}$$</p>
<p>每个全局变量都存储给定全局变量类型（global type）的单个值。<br>它的类型还指定了全局变量是不可变的还是可变的。<br>此外，每个全局变量都使用常量初始化表达式（expr）给出的初始化值进行初始化。</p>
<p>全局变量通过全局索引引用，从最小的索引开始，不引用全局导入。</p>
<h4 id="2-5-7-元素段-Element-Segments"><a href="#2-5-7-元素段-Element-Segments" class="headerlink" title="2.5.7. 元素段 Element Segments"></a>2.5.7. 元素段 Element Segments</h4><p>表的初始内容未初始化。<br>模块的elem组件定义元素段的向量，这些向量以给定的偏移量从元素的静态向量初始化表的子范围。</p>
<p>$$ elem ::= { \mathrm{table}\ tableidx, \mathrm{offset}\ express, \mathrm{init} vec(funcidx)}$$</p>
<p>偏移量（offset）由一个常量表达式给出。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，模块中最多允许一个表。因此，唯一有效的tableidx为0。</p>
</blockquote>
<h4 id="2-5-8-数据段-Data-Segments"><a href="#2-5-8-数据段-Data-Segments" class="headerlink" title="2.5.8. 数据段 Data Segments"></a>2.5.8. 数据段 Data Segments</h4><p>内存的初始内容为一堆零值字节。<br>模块的数据组件定义数据段的向量，这些数据段以给定的偏移量和静态字节向量来初始化内存范围。</p>
<p>$$ data ::= { \mathrm{data}\ memidx, \mathrm{offset}\ expr, \mathrm{init}\ vec(byte) }$$</p>
<p>偏移量（offset）由一个常量表达式给出。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，一个模块中最多允许有一个内存。 因此，唯一有效的memidx为0。</p>
</blockquote>
<h4 id="2-5-9-启动函数-Start-Function"><a href="#2-5-9-启动函数-Start-Function" class="headerlink" title="2.5.9. 启动函数 Start Function"></a>2.5.9. 启动函数 Start Function</h4><p>模块的启动（start）组件声明一个启动函数的函数索引，该函数在初始化表和内存后在实例化模块时自动调用。</p>
<p>$$ start ::= { \mathrm{func}\ funcidx }$$</p>
<blockquote>
<p>注意</p>
<p>启动功能用于初始化模块的状态。在初始化完成之前，无法访问模块及其导出（exports）。</p>
</blockquote>
<h4 id="2-5-10-导出-exports"><a href="#2-5-10-导出-exports" class="headerlink" title="2.5.10. 导出 exports"></a>2.5.10. 导出 exports</h4><p>模块的导出组件定义了一组导出。一旦实例化该模块，主机环境就可以访问它们。</p>
<p>$$ export ::= { \mathrm{name}\ name, \mathrm{desc}\ exportdesc }$$<br>$$ \displaylines{ exportdesc ::= \mathrm{func}\ funcidx\<br>| \mathrm{table}\ tableidx\<br>| \mathrm{mem}\ memidx\<br>| \mathrm{global}\ globalidx}$$</p>
<p>每个导出都用唯一的名称标记。<br>可导出的定义是函数，表，内存和全局变量，它们通过相应的描述符进行引用。</p>
<h5 id="2-5-10-1-惯例"><a href="#2-5-10-1-惯例" class="headerlink" title="2.5.10.1. 惯例"></a>2.5.10.1. 惯例</h5><p>为导出序列定义了以下辅助符号，以保留顺序的方式过滤出特定种类的索引：</p>
<ul>
<li>$func(export^*)=[ funcidx | \mathrm(func)\ funcidx \in (export.\mathrm{desc}) ]$</li>
<li>$tables(export^*)=[ tableidx | \mathrm(table)\ tableidx \in (export.\mathrm{desc}) ]$</li>
<li>$mems(export^*)=[ memidx | \mathrm(mem)\ memidx \in (export.\mathrm{desc}) ]$</li>
<li>$globals(export^*)=[ globalidx | \mathrm(global)\ globalidx \in (export.\mathrm{desc}) ]$</li>
</ul>
<h4 id="2-5-11-导入-imports"><a href="#2-5-11-导入-imports" class="headerlink" title="2.5.11. 导入 imports"></a>2.5.11. 导入 imports</h4><p>模块的导入组件定义了实例化所需的一组导入。</p>
<p>$$ import ::= { \mathrm{module}\ name, \mathrm{name}\ name, \mathrm{desc}\ importdesc}$$<br>$$ \displaylines{ importdesc ::= \mathrm{func}\ typeidx\<br>| \mathrm{table}\ tabletype\<br>| \mathrm{mem}\ memtype\<br>| \mathrm{global}\ globaltype}$$</p>
<p>每个导入都由两级名称空间标记，该名称空间由<em>模块名称</em>和该模块内<em>实体的名称</em>组成。<br>可导入的定义为函数，表，内存和全局变量。<br>每个导入都由一个描述符指定，该描述符的类型与实例化期间提供的定义必须匹配。</p>
<p>每次导入都会在相应的索引空间（index space）中定义一个索引。<br>在每个索引空间中，导入索引都位于模块本身包含的任何定义的第一个索引之前。</p>
<blockquote>
<p>注意</p>
<p>与导出名称不同，导入名称不一定是唯一的。<br>可以多次导入同一“模块名::名称”。<br>这样的导入甚至可能具有不同的类型描述，包括不同种类的实体。<br>仍然可以实例化具有此类导入的模块，具体取决于<em>嵌入程序</em>如何允许解析和提供导入的细节。<br>但是，不需要嵌入程序来支持此类重载，并且WebAssembly模块本身无法实现重载名称。</p>
</blockquote>
<h2 id="3-验证"><a href="#3-验证" class="headerlink" title="3. 验证"></a>3. 验证</h2><h3 id="3-1-惯例"><a href="#3-1-惯例" class="headerlink" title="3.1. 惯例"></a>3.1. 惯例</h3><p>验证将检查WebAssembly模块的格式是否正确，因为只能有效的模块能够被实例化。</p>
<p>有效性是由类型系统根据模块及其内容的抽象语法定义的。<br>对于每个抽象语法，都有一个键入规则，用于指定适用于它的约束。<br>所有规则均以两种等效形式给出：</p>
<ul>
<li>用行文，以直观的形式描述含义。</li>
<li>用公式表示法，以数学形式描述规则。[1]</li>
</ul>
<blockquote>
<p>注意</p>
<p>行文和公式规则是等效的，因此阅读本规范不需要理解公式符号。<br>公式提供了更简洁的符号描述，该符号广泛用于编程语言的语义中，并易于进行数学证明。</p>
</blockquote>
<p>在这两种情况下，规则都是以声明方式制定的。也就是说，它们仅制定约束条件，而没有定义算法。<br>附录中提供了根据本规范的用于类型检查指令序列的健全完整算法的框架。</p>
<h4 id="3-1-1-上下文"><a href="#3-1-1-上下文" class="headerlink" title="3.1.1. 上下文"></a>3.1.1. 上下文</h4><p>单个定义的有效性被制定为与上下文相关，该上下文收集有关周围模块和范围内定义的相关信息：</p>
<ul>
<li>类型：当前模块中定义的类型列表。</li>
<li>函数：在当前模块中声明的功能列表，以其功能类型表示。</li>
<li>表：在当前模块中声明的表格列表，以表格类型表示。</li>
<li>内存：在当前模块中声明的内存列表，以其内存类型表示。</li>
<li>全局变量：在当前模块中声明的全局变量列表，以其全局类型表示。</li>
<li>局部变量：在当前函数中声明的本地列表（包括参数），以其值类型表示。</li>
<li>标签：从当前位置可访问的标签堆栈，以其结果类型表示。</li>
<li>返回值：当前函数的返回类型，表示为可选结果类型，当不允许返回时（如独立表达式），该结果类型不存在。</li>
</ul>
<p>换句话说，上下文包含每个索引空间的一系列适当类型，描述该空间中的每个定义条目。<br>局部变量，标签和返回类型仅用于验证函数体中的指令，而在其他地方保留为空。<br>标签栈是上下文中随指令序列的验证而变化的唯一部分。</p>
<p>更具体地说，上下文被定义为具有抽象语法的记录（records），$C$：</p>
<p>$$ \displaylines{C::=\mathrm{types}\ functype^*,\<br>\mathrm{funcs}\ functype^*,\<br>\mathrm{tables}\ tabletype^*,\<br>\mathrm{mems}\ memtype^*,\<br>\mathrm{globals}\ globaltype^*,\<br>\mathrm{locals}\ valtype^*,\<br>\mathrm{labels}\ resulttype^*,\<br>\mathrm{return}\ resulttype^?}$$</p>
<p>除了使用$C.\mathrm{field}$编写的现场访问外，还采用以下表示法来处理上下文：</p>
<ul>
<li>拼写上下文时，将省略空白字段。</li>
<li>$C, \mathrm{field}\ A^*$表示与$C$相同的上下文，但元素$A^*$附加在其$\mathrm{field}$组件序列之前。</li>
</ul>
<blockquote>
<p>注意</p>
<p>我们使用诸如$C.labels[i]$之类的索引符号在上下文中的相应索引空间中查找索引。<br>上下文扩展符号$C，\mathrm{field}\ A$主要用于局部扩展相对索引空间，例如标签索引。<br>因此，将符号定义为附加在各个序列的前面，引入新的相对索引0并移动现有的相对索引。</p>
</blockquote>
<h4 id="3-1-2-行文符号"><a href="#3-1-2-行文符号" class="headerlink" title="3.1.2. 行文符号"></a>3.1.2. 行文符号</h4><p>验证由程式化规则为抽象语法的每个相关部分指定。 这些规则不仅说明定义短语何时有效的约束，而且还使用类型对短语进行分类。 在说明这些规则时采用了以下约定。</p>
<ul>
<li>当且仅当满足相应规则表示的所有约束时，短语A才被称为“对于T型有效”。 T的形式取决于A是什么。</li>
</ul>
<blockquote>
<p>注意</p>
<p>例如，如果$A$是一个函数，则$T$也是一个函数类型。<br>如果$A$是全局类型，则$T$也是全局类型； 如此类推。</p>
</blockquote>
<ul>
<li><p>规则隐式假定给定上下文$C$。</p>
</li>
<li><p>在某些地方，此上下文在本地扩展到带有其他条目的上下文$C’$。措词“*在上下文中$C’$，…声明…*”用于表示以下声明必须在扩展上下文中包含的假设下适用。</p>
</li>
</ul>
<h4 id="3-1-3-正式符号"><a href="#3-1-3-正式符号" class="headerlink" title="3.1.3. 正式符号"></a>3.1.3. 正式符号</h4><blockquote>
<p>注意</p>
<p>本节简要说明了正式指定键入规则的表示法。<br>对于感兴趣的读者，可以在相应的书中找到更全面的介绍。 [2]</p>
</blockquote>
<p>短语$A$具有各自类型$T$的命题被写为$A:T$。<br>但是，总的来说，键入取决于上下文$C$。<br>为明确表示这一点，完整的形式为判断$C\vdash A:T$，它表示$A:T$在C的假设下成立。</p>
<p>正式的符号规则使用一种标准的方法来指定类型系统，将它们呈现为<em>推理规则</em>。<br>每个规则具有以下一般形式：</p>
<p>$$\frac{<br>     {premise}_1 \qquad {premise}_2 \qquad \dots \qquad {premise}_n<br>   }{<br>     {conclusion}<br>   }$$</p>
<p>这样的规则被认为是一个大含义：如果所有前提都成立，那么结论成立。<br>有些规则没有前提；它们是其结论无条件成立的<em>公理</em>。<br>结论始终是判断$C \vdash A : T$，并且抽象语法的每个相关构造A都有一个相应的规则。</p>
<blockquote>
<p>注意</p>
<p>例如，可以将i32.add指令的输入规则作为一个公理给出：<br>$$\frac{<br>      }{<br>        C \vdash i32.add : [i32, i32] \to [i32]<br>      }$$</p>
<p>该指令对于[i32, i32]→[i32]类型始终有效（假设它使用两个i32值并产生一个i32），而与任何其他条件无关。<br>像local.get这样的指令可以按如下方式键入：<br>$$\frac{<br>        C.locals[x] = t<br>      }{<br>        C \vdash \mathrm{local.get}\ x : [] \to [t]<br>      }$$<br>在此，前提要求上下文中存在直接本地索引x。<br>该指令产生其各自类型t的值（并且不消耗任何值）。<br>如果C.locals[x]不存在，则前提不成立，并且指令类型错误。</p>
<p>最后，结构化指令需要一个递归规则，其中前提本身就是键入判断：<br>$$\frac{<br>        C,\ \mathrm{label}[t^?] \vdash instr^\ast : [] \to [t^?]<br>      }{<br>        C \vdash \mathrm{block}[t^?]\ instr^\ast \ \mathrm{end}: [] \to [t^?]<br>      }$$<br>一个block指令仅在其主体中的指令序列有效时才有效。<br>此外，结果类型必须与区块的注解$[t^?]$匹配。<br>如果是这样，则块指令与主体具有相同的类型。<br>在内部，可以使用相同类型的其他标签，这可以通过使用前提的其他标签信息扩展上下文C来表示。</p>
</blockquote>
<p>[1]语义来自以下文章：Andreas Haas，Andreas Rossberg，Derek Schuff，Ben Titzer，Dan Gohman，Luke Wagner，Alon Zakai，JF Bastien，Michael Holman。 《通过WebAssembly加速Web》。 第38届ACM SIGPLAN编程语言设计和实现会议（PLDI 2017）的会议记录。 ACM 2017年。</p>
<p>[2]例如：Benjamin Pierce。 《类型和编程语言》。 麻省理工学院出版社2002</p>
<h3 id="3-2-类型"><a href="#3-2-类型" class="headerlink" title="3.2. 类型"></a>3.2. 类型</h3><p>大多数类型都是普遍有效的。<br>但是，限制适用于函数类型以及表类型和内存类型的限制，必须在验证期间进行检查。</p>
<h4 id="3-2-1-限制Limits"><a href="#3-2-1-限制Limits" class="headerlink" title="3.2.1. 限制Limits"></a>3.2.1. 限制Limits</h4><p>界限必须具有在给定范围内的有意义的界限。</p>
<h5 id="3-2-1-1-min-n-max-m"><a href="#3-2-1-1-min-n-max-m" class="headerlink" title="3.2.1.1. ${min\ n, max\ m^?}$"></a>3.2.1.1. ${min\ n, max\ m^?}$</h5><ul>
<li>n的值不能大于k。</li>
<li>如果最大值$m^?$不为空，则：<ul>
<li>它的值不能大于k。</li>
<li>它的值不能小于n。</li>
</ul>
</li>
<li>然后该限制在范围k内有效。</li>
</ul>
<p>$$\frac{<br>     n \leq k<br>     \qquad<br>     (m \leq k)^?<br>     \qquad<br>     (n \leq m)^?<br>   }{<br>     \vdash limits { min<del>n, max</del>m^? } : k<br>   }$$</p>
<h4 id="3-2-2-函数类型"><a href="#3-2-2-函数类型" class="headerlink" title="3.2.2. 函数类型"></a>3.2.2. 函数类型</h4><p>函数类型不能指定一个以上的结果。</p>
<h5 id="3-2-2-1-t-1-n-to-t-2-m"><a href="#3-2-2-1-t-1-n-to-t-2-m" class="headerlink" title="3.2.2.1. $[t_1^n] \to [t_2^m]$"></a>3.2.2.1. $[t_1^n] \to [t_2^m]$</h5><ul>
<li>参数m不得大于1。</li>
<li>则函数类型有效。</li>
</ul>
<p>$$\frac{<br>   }{<br>     \vdash [t_1^\ast] \to [t_2^?] ~ok<br>   }$$</p>
<blockquote>
<p>注意</p>
<p>在将来的WebAssembly版本中，可能消除对返回值至多一个的限制。</p>
</blockquote>
<h4 id="3-2-3-表类型"><a href="#3-2-3-表类型" class="headerlink" title="3.2.3. 表类型"></a>3.2.3. 表类型</h4><h5 id="3-2-3-1-元素类型：限制"><a href="#3-2-3-1-元素类型：限制" class="headerlink" title="3.2.3.1. 元素类型：限制"></a>3.2.3.1. 元素类型：限制</h5><ul>
<li>限制limits必须在$2^32$范围内有效</li>
<li>则表类型有效。</li>
</ul>
<p>$$   \frac{<br>     \vdash limits: 2^{32}<br>   }{<br>     \vdash limits<del>elemtype</del>\mathrm{ok}<br>   }$$</p>
<h4 id="3-2-4-内存类型"><a href="#3-2-4-内存类型" class="headerlink" title="3.2.4. 内存类型"></a>3.2.4. 内存类型</h4><h5 id="3-2-4-1-限制"><a href="#3-2-4-1-限制" class="headerlink" title="3.2.4.1. 限制"></a>3.2.4.1. 限制</h5><ul>
<li>限制limits必须在$2^16$范围内有效</li>
<li>则内存类型有效。</li>
</ul>
<p>$$   \frac{<br>     \vdash limits: 2^{16}<br>   }{<br>     \vdash limits~\mathrm{ok}<br>   }$$</p>
<h4 id="3-2-5-全局类型"><a href="#3-2-5-全局类型" class="headerlink" title="3.2.5. 全局类型"></a>3.2.5. 全局类型</h4><h5 id="3-2-5-1-可变值类型"><a href="#3-2-5-1-可变值类型" class="headerlink" title="3.2.5.1. 可变值类型"></a>3.2.5.1. 可变值类型</h5><ul>
<li>全局类型有效</li>
</ul>
<p>$$   \frac{<br>   }{<br>     \vdash globaltype\ mut<del>valtype</del>\mathrm{ok}<br>   }$$</p>
<h4 id="3-2-6-外部类型"><a href="#3-2-6-外部类型" class="headerlink" title="3.2.6. 外部类型"></a>3.2.6. 外部类型</h4><h5 id="3-2-6-1-函数类型-func"><a href="#3-2-6-1-函数类型-func" class="headerlink" title="3.2.6.1. 函数类型 func"></a>3.2.6.1. 函数类型 func</h5><ul>
<li>func的函数类型functype必须有效。</li>
<li>则外部类型有效。</li>
</ul>
<p>$$   \frac{<br>     \vdash functype<del>ok<br>   }{<br>     \vdash func</del>functype~ok<br>   }$$</p>
<h5 id="3-2-6-2-表类型-table"><a href="#3-2-6-2-表类型-table" class="headerlink" title="3.2.6.2. 表类型 table"></a>3.2.6.2. 表类型 table</h5><ul>
<li>差不多同上，仅类型区别，类型有效则有效</li>
</ul>
<h5 id="3-2-6-3-内存类型-mem"><a href="#3-2-6-3-内存类型-mem" class="headerlink" title="3.2.6.3. 内存类型 mem"></a>3.2.6.3. 内存类型 mem</h5><ul>
<li>差不多同上，仅类型区别，类型有效则有效</li>
</ul>
<h5 id="3-2-6-4-全局类型-global"><a href="#3-2-6-4-全局类型-global" class="headerlink" title="3.2.6.4. 全局类型 global"></a>3.2.6.4. 全局类型 global</h5><ul>
<li>差不多同上，仅类型区别，类型有效则有效</li>
</ul>
<h3 id="3-3-指令"><a href="#3-3-指令" class="headerlink" title="3.3. 指令"></a>3.3. 指令</h3><p>指令按函数类型[t]→[t]进行分类，这些函数类型描述了指令如何操纵操作数堆栈。 这些类型描述了必需的输入堆栈，其中弹出了一条指令的类型为t的参数值，以及提供的输出堆栈，其返回的结果为类型t的结果。</p>
<h2 id="4-执行"><a href="#4-执行" class="headerlink" title="4. 执行"></a>4. 执行</h2><h2 id="5-二进制格式"><a href="#5-二进制格式" class="headerlink" title="5. 二进制格式"></a>5. 二进制格式</h2><h2 id="6-文本格式"><a href="#6-文本格式" class="headerlink" title="6. 文本格式"></a>6. 文本格式</h2><h2 id="A-附录"><a href="#A-附录" class="headerlink" title="A. 附录"></a>A. 附录</h2>]]></content>
      <tags>
        <tag>wasm</tag>
        <tag>WebAssembly</tag>
        <tag>todo</tag>
        <tag>specification</tag>
      </tags>
  </entry>
</search>
